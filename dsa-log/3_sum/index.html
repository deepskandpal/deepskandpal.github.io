<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#brainstorming>Brainstorming</a><ul><li><a href=#bug-1-the-outer-loop-duplicate-check><strong>Bug #1: The Outer Loop Duplicate Check</strong></a></li><li><a href=#bug-2-the-inner-loop-duplicate-check-after-finding-a-match><strong>Bug #2: The Inner Loop Duplicate Check (after finding a match)</strong></a></li><li><a href=#bug-3-loop-range><strong>Bug #3: Loop Range</strong></a></li></ul></li><li><a href=#putting-it-all-together-corrected-structure><strong>Putting It All Together (Corrected Structure)</strong></a></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i, j, and k are distinct indices, and nums[i] + nums[j] + nums[k] == 0.
Important Constraint: The solution set must not contain duplicate triplets.
Example:
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [-1, -1, 2], [-1, 0, 1]
Explanation:
(-1) + 0 + 1 = 0
(-1) + 2 + (-1) = 0
Notice [0, 1, -1]
is the same triplet as [-1, 0, 1], so we only include it once.</p><h2 id=brainstorming>Brainstorming</h2><p>So the idea is we have to move greedily i.e we make sure we satisfy the first constraint that is the 3 numbers should add up to the target and the second constraint that we should avoid creating duplicate triplets.</p><p>The core strategy we have whenever we have to deal with removing duplicates is to always sort the array , unless and until there is some added constraints on sorting or if some issue may arise because of it.</p><p>Why sorting? it brings all the duplicate elements together</p><p>lets take the example in the problem [-1, 0, 1, 2, -1, -4] , sorted this would be [-4, -1,-1,0,1,2] if you notice -1 are grouped together hence while iterating over a for loop we can just skip an element if its similar to the previous element</p><p>This solves the duplicate triplets issue by skipping it, now coming to the original problem. We need to make sure 3 numbers in this sorted array if they sum up to target they should be appended to the list. The good thing is since its a sorted array all the elements are increasing order , we can use it to our advantage. A 2 pointer search space minimization technique can work here , with a 3rd pointer iterating over this whole array element by element, they will work together like this</p><ol><li>For each element<ol><li>If its similar to the previous element just skip everything and move to the next element</li><li>create a search space witth boundary starting from the next element of it all the way till the end</li><li>caculate a current sum that is a total of element + left boundary element + right boundary element</li><li>if its equal to target then add it as a triplet</li><li>if its greater than target that means the right most element is big hence we should reduce the search space from right</li><li>if its less than the target that means the left most element is too small hence we should reduce the search space from the left</li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nums<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>): <span style=color:#75715e># we need to make sure that we don&#39;t get index out of bounds</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>!=</span> nums[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check and make sure the current element is not same as the next element</span>
</span></span><span style=display:flex><span>		left <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		right <span style=color:#f92672>=</span> len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right: <span style=color:#75715e># boundary condition</span>
</span></span><span style=display:flex><span>			current_sum <span style=color:#f92672>=</span> nums[i] <span style=color:#f92672>+</span> nums[left] <span style=color:#f92672>+</span> nums[right]
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> current_sum <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>				result<span style=color:#f92672>.</span>append([nums[i], nums[left], nums[right]])
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>while</span> nums[i] <span style=color:#f92672>!=</span> nums[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>						left <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>elif</span> current_sum <span style=color:#f92672>&lt;</span> target:
</span></span><span style=display:flex><span>				left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>				right <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>				 
</span></span></code></pre></div><p>This is perfectly fine lets try with some cases
target = 9
[1,2,5,3,9,4,3]</p><p>sorted</p><p>nums = [1,2,3,3,4,5,9]</p><p>for i in range(nums):
1. i = 0 nums[0] = 1
1. check for duplicate 1 != 2 hence we can proceed
1. left 2 (nums[1]) right 9 (nums[5])
1. left &lt; 5
1. sum = 1 + 2 + 9 > 9 hence reduce from right, nums[4] (5)
1. sum = 1 + 2 + 5 &lt; 9 hence reduce from left nums[2] (3)
2. sum = 1 + 3 + 5 == 9 add triplet
1. now we should move the left pointer but we have duplicate at nums[3] (3) hence we should add a check and skip it as well
2. skip nums[3] go to nums[4] (4)
3. sum = 1 + 4 + 5 > 9 hence reduce from right nums[3] 3
1. while breaks left (4) is not less than right(3)
2. i = 1 nums[1] = 2
3.</p><p>This is a great attempt, and you are thinking about all the right components: sorting, the outer loop, the two-pointer inner loop, and duplicate handling. This is exactly the thought process of a developer working through a complex problem.</p><p>Let&rsquo;s debug your implementation together. It has the correct high-level structure, but there are a few logical bugs in the details, particularly around the duplicate checks.</p><p>Here is your code again for reference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span> 
</span></span><span style=display:flex><span>nums<span style=color:#f92672>.</span>sort() <span style=color:#75715e># Becomes [1, 2, 3, 3, 4, 5, 9]</span>
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>!=</span> nums[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># Bug 1: Duplicate check logic</span>
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right: 
</span></span><span style=display:flex><span>      current_sum <span style=color:#f92672>=</span> nums[i] <span style=color:#f92672>+</span> nums[left] <span style=color:#f92672>+</span> nums[right]
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> current_sum <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>          result<span style=color:#f92672>.</span>append([nums[i], nums[left], nums[right]])
</span></span><span style=display:flex><span>          <span style=color:#75715e># Bug 2: Incorrect duplicate check for &#39;left&#39;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>while</span> nums[i] <span style=color:#f92672>!=</span> nums[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>elif</span> current_sum <span style=color:#f92672>&lt;</span> target:
</span></span><span style=display:flex><span>          left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>          right <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Let&rsquo;s break down the issues.</p><hr><h3 id=bug-1-the-outer-loop-duplicate-check><strong>Bug #1: The Outer Loop Duplicate Check</strong></h3><p><strong>Your Code:</strong> <code>if nums[i] != nums[i+1]:</code></p><p><strong>The Problem:</strong> This checks the current element against the <em>next</em> one. Let&rsquo;s trace this with a relevant part of our sorted array: <code>..., 3, 3, 4, ...</code></p><ul><li>When <code>i</code> points to the <strong>first</strong> <code>3</code>, <code>nums[i]</code> is <code>3</code> and <code>nums[i+1]</code> is also <code>3</code>. Your condition <code>3 != 3</code> is <strong>false</strong>. This means your code will <strong>skip</strong> the first <code>3</code>, which is wrong! We need to process the first occurrence of any number.</li><li>When <code>i</code> points to the <strong>second</strong> <code>3</code>, <code>nums[i]</code> is <code>3</code> and <code>nums[i+1]</code> is <code>4</code>. Your condition <code>3 != 4</code> is <strong>true</strong>. Your code will now run the two-pointer logic for the second <code>3</code>.</li></ul><p>This is the opposite of what we want. We want to process the first <code>3</code> and skip the second <code>3</code>.</p><p><strong>The Fix (Hint):</strong> Instead of comparing <code>nums[i]</code> to the <em>next</em> element, you should compare it to the <strong>previous</strong> element. The rule should be: &ldquo;If I am the same as the guy before me, then I&rsquo;m a duplicate starter, so just skip me.&rdquo; This ensures you only run the main logic for the first occurrence of each number.</p><ul><li>The check should look like: <code>if i > 0 and nums[i] == nums[i-1]: continue</code></li></ul><hr><h3 id=bug-2-the-inner-loop-duplicate-check-after-finding-a-match><strong>Bug #2: The Inner Loop Duplicate Check (after finding a match)</strong></h3><p><strong>Your Code:</strong> <code>while nums[i] != nums[i+1] and left &lt; right: left += 1</code></p><p><strong>The Problem:</strong> The condition here, <code>nums[i] != nums[i+1]</code>, has nothing to do with the <code>left</code> pointer. We&rsquo;ve found a valid triplet <code>[nums[i], nums[left], nums[right]]</code>. Now we need to skip any duplicates of <code>nums[left]</code> to avoid finding the same triplet again.</p><p>Let&rsquo;s say <code>nums = [-2, 0, 0, 2, 2]</code> and our triplet is <code>[-2, 0, 2]</code>.</p><ul><li>We found this with <code>i=0</code>, <code>left=1</code>, <code>right=4</code>. The triplet is <code>[-2, 0, 2]</code>.</li><li>We must now advance <code>left</code>. It becomes <code>2</code>.</li><li>The new <code>nums[left]</code> is also <code>0</code>. If we don&rsquo;t do anything special, our next check will be <code>[-2, 0, 2]</code>, which is a duplicate triplet.</li></ul><p><strong>The Fix (Hint):</strong> After you find a match and increment <code>left</code> once, you need a new <code>while</code> loop that checks if the new <code>nums[left]</code> is the same as the <em>previous value of left</em>. The condition should be <code>while left &lt; right and nums[left] == nums[left - 1]:</code>.</p><hr><h3 id=bug-3-loop-range><strong>Bug #3: Loop Range</strong></h3><p><strong>Your Code:</strong> <code>for i in range(len(nums) - 1):</code></p><p><strong>The Problem:</strong> We need to leave room for at least two other numbers for the <code>left</code> and <code>right</code> pointers. If <code>i</code> goes all the way to <code>len(nums) - 2</code>, then <code>left</code> will be <code>len(nums) - 1</code> and <code>right</code> will be <code>len(nums) - 1</code>. The loop <code>while left &lt; right</code> will not run. This is correct. But if <code>i</code> is <code>len(nums) - 1</code>, the code will crash.</p><ul><li><strong>The Fix:</strong> The loop for <code>i</code> only needs to go up to <code>len(nums) - 3</code>, so the range should be <code>range(len(nums) - 2)</code>.</li></ul><hr><h2 id=putting-it-all-together-corrected-structure><strong>Putting It All Together (Corrected Structure)</strong></h2><p>Here is how the logic looks with the fixes incorporated. This isn&rsquo;t the final code, but the corrected pseudocode structure for you to implement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span> 
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>nums<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>!=</span> nums[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e># we need to check with the previous value</span>
</span></span><span style=display:flex><span>		left <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		right <span style=color:#f92672>=</span> len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>			curr_sum <span style=color:#f92672>=</span> nums[i] <span style=color:#f92672>+</span> nums[left] <span style=color:#f92672>+</span> nums[right]
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> curr_sum <span style=color:#f92672>==</span> target
</span></span><span style=display:flex><span>				result<span style=color:#f92672>.</span>append([nums[i], nums[left], nums[right]])
</span></span><span style=display:flex><span>				<span style=color:#75715e># increment left pointer so that we don&#39;t recomupute a new triplet</span>
</span></span><span style=display:flex><span>				left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right <span style=color:#f92672>and</span> nums[left] <span style=color:#f92672>==</span> nums[left <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>					left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>elif</span> curr_sum <span style=color:#f92672>&lt;</span> target:
</span></span><span style=display:flex><span>				left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>				right <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>