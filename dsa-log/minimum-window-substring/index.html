<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#code-review>Code Review</a></li></ul></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><h1 id=problem>Problem</h1><p>You are given two strings, s (the &ldquo;search string&rdquo;) and t (the &ldquo;pattern&rdquo;). You need to find the <strong>minimum length substring</strong> of s that contains <strong>all the characters</strong> of t. The frequency of characters in the substring must be greater than or equal to the frequency in t.</p><p>Example: s = &ldquo;ADOBECODEBANC&rdquo;, t = &ldquo;ABC&rdquo;</p><ul><li>&ldquo;ADOBEC&rdquo; contains &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;. Length 6.</li><li>&ldquo;CODEBA&rdquo; is not valid (missing &ldquo;C&rdquo;).</li><li>&ldquo;BANC&rdquo; contains &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;. Length 4. This is the minimum.</li><li>The answer is &ldquo;BANC&rdquo;.</li></ul><h1 id=brainstorming>Brainstorming</h1><p>i think a has map should should work an example for it would be like t = &ldquo;ABC&rdquo; {&ldquo;A&rdquo; : 1 , &ldquo;B&rdquo;: 1, &ldquo;C&rdquo;:1}<br>as we move right we need to ask if the character we are looking at is it in our hash map? if we collect it we can simply reduce the counts of the char by 1
now an idea would be a sum of all the chars counts in the has map which for our example be 3 that helps us keep a track of how many we have found by removing each char found from it for eg we found A so we remove one from this char_counts but this may not keep track of the char individually the form and needed can work if the counts of chars is 1 in the pattern string but i am not sure how it will work for more than 1 occurance.
in the while loop we will move the left pointer till we have not hit 1 of the chars from our pattern string</p><p>so the algorithm is pretty clear now<br>we have 2 strings s = <code>"ADOBECODEBANC"</code>, t = &ldquo;ABC&rdquo; we create a hashmap for pattern string {&ldquo;A&rdquo;:1, &ldquo;B&rdquo;:1, &ldquo;C&rdquo;:1}<br>needed is the unique count of the chars so it can be a count of set of chars in t here its 3<br>formed is computed when the value of counts of a char in the hash map is exactly 0 for a char ie say {A:0} after we have found it then we update formed by 1<br>so the for loop will be for the right pointer<br>at each step fos <code>s[right]</code> we check if its in the hashmap or not if it is we just move ahead , if it is then thats when our window starts ie left pointer is moved to this position.<br>we move ahead till the time we formed == needed<br>now once we will enter the while loop to shrink the window , the condition for it is while the window is valid ie formed == needed<br>we store a min_length for it<br>we move the left pointer forward<br>now we get the left char which is <code>s[left]</code> if left in the frequencey , we increment its counter , the count is now greater than zero hence we decrement the formed .</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> Counter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ADOBECODEBANC&#34;</span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ABC&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>char_count <span style=color:#f92672>=</span> Counter(t) <span style=color:#75715e># create hash map with chars and its frequency</span>
</span></span><span style=display:flex><span>needed <span style=color:#f92672>=</span> len(char_count) <span style=color:#75715e># unqiue characters we need</span>
</span></span><span style=display:flex><span>left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># the left pointer</span>
</span></span><span style=display:flex><span>formed <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>start_of_ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># to generate the substring </span>
</span></span><span style=display:flex><span>min_window <span style=color:#f92672>=</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)): <span style=color:#75715e># the main for loop</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> s[right] <span style=color:#f92672>in</span> char_count: <span style=color:#75715e># check if we have found the character or not</span>
</span></span><span style=display:flex><span>		char_count[s[right]] <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># decrement from the hashmap</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> char_count[s[right]] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>: <span style=color:#75715e># we have found all occurances of this char</span>
</span></span><span style=display:flex><span>			formed <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>and</span> formed <span style=color:#f92672>==</span> needed: <span style=color:#75715e># we need both conditions so that the while loop continues even if formed is not same as needed</span>
</span></span><span style=display:flex><span>			current_window <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># get the current length</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> current_window <span style=color:#f92672>&lt;</span> min_window: <span style=color:#75715e># compare it with the window we have found so far</span>
</span></span><span style=display:flex><span>				start_of_ans <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>				min_window <span style=color:#f92672>=</span> current_window
</span></span><span style=display:flex><span>			left_char <span style=color:#f92672>=</span> s[left]
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> left_char <span style=color:#f92672>in</span> char_count: 
</span></span><span style=display:flex><span>				char_count[left_char] <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># increment its count by 1</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> char_count[left_char] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>: <span style=color:#75715e># IMP check we only decrement formed if we loose a char i.e if its count goes from 0 to 1</span>
</span></span><span style=display:flex><span>					formed <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># decrement the form by 1</span>
</span></span><span style=display:flex><span>			
</span></span><span style=display:flex><span>			left <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>			
</span></span><span style=display:flex><span>print(s[start_of_ans:start_of_ans<span style=color:#f92672>+</span>min_window])
</span></span></code></pre></div><p>This is an outstanding piece of work. You have translated the complex logic into code almost perfectly. You are on the verge of the correct solution.</p><p>Let&rsquo;s do a quick code review and trace it to find the one or two small logical bugs.</p><h3 id=code-review>Code Review</h3><ol><li><p><strong>The Initial Frequency Map:</strong>
You have <code>char_count = Counter(s)</code>. The frequency map should be for the <strong>pattern string <code>t</code></strong>, not the search string <code>s</code>.</p><ul><li><strong>Fix:</strong> <code>char_count = Counter(t)</code></li></ul></li><li><p><strong>The <code>needed</code> variable:</strong>
This should also be based on <code>t</code>. <code>needed = len(char_count)</code> is correct <em>after</em> you fix the line above.</p></li><li><p><strong>The <code>while</code> loop condition:</strong>
You have a great comment: <code>we need both conditions so that the while loop continues even if formed is not same as needed</code>. This is slightly off. The <code>while</code> loop&rsquo;s only job is to <strong>shrink a valid window</strong>. It should only run <em>if</em> the window is valid.</p><ul><li><strong>Fix:</strong> The condition is simply <code>while formed == needed:</code>.</li></ul></li><li><p><strong>The Shrinking Logic:</strong>
This is the most subtle part. Let&rsquo;s look at your code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> left_char <span style=color:#f92672>in</span> char_count: 
</span></span><span style=display:flex><span>    char_count[left_char] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    formed <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># &lt;-- The Bug</span>
</span></span></code></pre></div><p>You are decrementing <code>formed</code> every time you lose a required character. But <code>formed</code> should only decrement when you &ldquo;un-fulfill&rdquo; a requirement.
Let&rsquo;s say <code>t = "AAB"</code>. The map is <code>{ 'A': 2, 'B': 1 }</code>.</p><ul><li>You find an <code>'A'</code>. Map is now <code>{ 'A': 1, 'B': 1 }</code>. <code>formed</code> is 0.</li><li>You find another <code>'A'</code>. Map is now <code>{ 'A': 0, 'B': 1 }</code>. <code>formed</code> becomes 1.</li><li>Now you shrink. You lose the first <code>'A'</code>. The map becomes <code>{ 'A': 1, 'B': 1 }</code>. Did you just break the full set? No, because you still have one <code>'A'</code> left, and the count for <code>'A'</code> (which is 1) is not what made <code>formed</code> increment.</li><li>You only decrement <code>formed</code> when a character&rsquo;s count goes from <code>0</code> to <code>1</code>.</li></ul></li></ol><ul><li><strong>Prompt (The Fix):</strong> Inside the <code>if left_char in char_count:</code> block, you correctly increment <code>char_count[left_char] += 1</code>. What is the <code>if</code> condition you need to check on that character&rsquo;s count <em>after</em> you increment it, that tells you &ldquo;I have just broken the requirement for this character&rdquo;? If that condition is met, then you decrement <code>formed</code>.</li></ul><p>You are extremely close. You have the entire structure. This is just the final, subtle piece of the puzzle.</p><p>ideal version</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> Counter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_window_substring</span>(s: str, t: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> t <span style=color:#f92672>or</span> <span style=color:#f92672>not</span> s:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 1. Your perfect setup: Create the frequency map for the pattern &#39;t&#39;.</span>
</span></span><span style=display:flex><span>    char_count <span style=color:#f92672>=</span> Counter(t)
</span></span><span style=display:flex><span>    needed <span style=color:#f92672>=</span> len(char_count) <span style=color:#75715e># The number of unique characters we need to find.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 2. Sliding window variables</span>
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    formed <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 3. Variables to track the best answer found so far.</span>
</span></span><span style=display:flex><span>    min_len <span style=color:#f92672>=</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span>    ans_start_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 4. Your main expansion loop</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right, char <span style=color:#f92672>in</span> enumerate(s):
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 5. If the current character is part of our pattern</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> char <span style=color:#f92672>in</span> char_count:
</span></span><span style=display:flex><span>            char_count[char] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># If we&#39;ve just found all required instances of this character</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> char_count[char] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                formed <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 6. Your contraction loop: try to shrink the window</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># This runs as soon as the window becomes valid.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>and</span> formed <span style=color:#f92672>==</span> needed:
</span></span><span style=display:flex><span>            current_len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Check if this is a new best answer</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> current_len <span style=color:#f92672>&lt;</span> min_len:
</span></span><span style=display:flex><span>                min_len <span style=color:#f92672>=</span> current_len
</span></span><span style=display:flex><span>                ans_start_index <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Get the character we are about to remove from the left of the window</span>
</span></span><span style=display:flex><span>            left_char <span style=color:#f92672>=</span> s[left]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># If the character we&#39;re removing is part of the pattern</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> left_char <span style=color:#f92672>in</span> char_count:
</span></span><span style=display:flex><span>                char_count[left_char] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Your brilliant fix: if the count is now &gt; 0, it means we</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># just &#34;broke&#34; the requirement for this character.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> char_count[left_char] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                    formed <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e># Shrink the window</span>
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If we never found a valid window, min_len will still be infinity.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#66d9ef>if</span> min_len <span style=color:#f92672>==</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>) <span style=color:#66d9ef>else</span> s[ans_start_index : ans_start_index <span style=color:#f92672>+</span> min_len]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Example usage from your code</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ADOBECODEBANC&#34;</span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ABC&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># print(min_window_substring(s, t)) # Expected output: &#34;BANC&#34;</span>
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>