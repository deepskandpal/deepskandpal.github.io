<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#final-algorithm><strong>Final Algorithm</strong></a></li></ul></li></ul><ul><li><a href=#cementing-the-idea>Cementing the idea</a><ul><li><a href=#on-duplicates-a-final-thought-exercise><strong>On Duplicates (A Final Thought Exercise)</strong></a></li><li><a href=#session-reflection><strong>Session Reflection</strong></a></li></ul></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Arrays]]</p><h1 id=problem>Problem</h1><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).
Prior to being passed to your function, <code>nums</code> is <strong>possibly left rotated</strong> at an unknown index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be left rotated by <code>3</code> indices and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> nums = <code>[4,5,6,7,0,1,2]</code>, target = 0
<strong>Output:</strong> 4</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> nums = <code>[4,5,6,7,0,1,2]</code>, target = 3
<strong>Output:</strong> -1</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> nums = <code>[1]</code>, target = 0
<strong>Output:</strong> -1</p><h1 id=brainstorming>Brainstorming</h1><p>so the inputs are the nums array and the target just like the binary search , the numbers in nums are all integers<br>we can use the idea of binary search but it would need modification the key insight is at every step of slicing the search space by half we can guarantee that alteast one half will be sorted and we can search in that half first<br>the target being the first or the last element doesn&rsquo;t affect our process since we will follow the following method</p><ol><li>find the mid point</li><li>check if the mid element is the target or not<br>if not check which side is sorted , which ever is sorted search in that side.<br>if its not in that side , it means its on the other side</li></ol><p>to determine wether the left half is sorted and contains or number or not we can do <code>nums[left] &lt; nums[mid] the other thing would be to check can be if nums[left] &lt; nums[target] &lt; nums[mid]</code></p><p>the lower bound is <code>nums[0]</code> and <code>nums[mid-1]</code> is the upper bound of the left half, if after that we don&rsquo;t find our target between those bounds it means that we should check in the in the right half where the bounds are <code>nums[mid +1]</code> till len(nums)<br>so if its not in the left half that means we need to move the left pointer to mid + 1<br>so the logic is<br>check if <code>nums[0] &lt;= nums[mid]</code> if its not it means that the right half is sorted we move the left pointer to mid + 1<br>if it is check if <code>nums[0] &lt; target &lt; nums[mid]</code> if its not it means we need to search in the right half we move the left pointer to mid + 1<br>if the above check is correct that means the the target is in the bounds of the left array hence we move the right pointer to mid -1</p><p>before me move we need to check if target is in the sorted area of not so whether the sorted area is left or right we need to check immediately if target is between the bounds or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># check for sorted</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... inside while loop  </span>
</span></span><span style=display:flex><span>mid  <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right ) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># we have a check which checks if mid == target not relevant here)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if half is sorted</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> target <span style=color:#f92672>&lt;</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if target is in the sorted half</span>
</span></span><span style=display:flex><span>      left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># then you move the left pointer ahead</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> : <span style=color:#75715e># the right is sorted </span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> target <span style=color:#f92672>&lt;</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if target is in the sorted half</span>
</span></span><span style=display:flex><span>      right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>  <span style=color:#75715e># then you move the right pointer behind</span>
</span></span></code></pre></div><p>as the search space narrows we need to move away from static boundaries to more dynamic ones</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># check for sorted</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... inside while loop  </span>
</span></span><span style=display:flex><span>mid  <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right ) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># we have a check which checks if mid == target not relevant here)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if half is sorted</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;</span> target <span style=color:#f92672>&lt;</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if target is in the sorted half</span>
</span></span><span style=display:flex><span>     right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># then you move the left pointer ahead</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> : <span style=color:#75715e># the right is sorted </span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> nums[right] <span style=color:#f92672>&lt;</span> target <span style=color:#f92672>&lt;</span> nums[len(n)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># check if target is in the sorted half</span>
</span></span><span style=display:flex><span>     left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># then you move the right pointer behind</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># ... inside while loop</span>
</span></span><span style=display:flex><span>mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># (check for nums[mid] == target is here)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;=</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># we check for left to be sorted </span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;=</span> target <span style=color:#f92672>&lt;=</span> nums[mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># target not in sorted array </span>
</span></span><span style=display:flex><span>     right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>else</span>: <span style=color:#75715e># we move the left pointer</span>
</span></span><span style=display:flex><span>     left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> : <span style=color:#75715e># the right is sorted </span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> nums[right] <span style=color:#f92672>&lt;=</span> target <span style=color:#f92672>&lt;</span> <span style=color:#f92672>=</span>nums[len(n)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]: <span style=color:#75715e># we check </span>
</span></span><span style=display:flex><span>       left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>: <span style=color:#75715e># its not in the sorted array</span>
</span></span><span style=display:flex><span>      right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><ol><li><strong>Correct Boundary Checks:</strong> You are now using <code>&lt;=</code> which correctly handles cases where the target might be one of the boundary elements.</li><li><strong>Correct Sorted Half Identification:</strong> <code>if nums[left] &lt;= nums[mid]</code> is the robust way to check if the left half is the sorted portion. (Note: your pseudocode still has <code>mid-1</code>, but your thinking is on <code>mid</code>, which is correct).</li><li><strong>The &ldquo;Invisible Else&rdquo; is Now Visible:</strong> You&rsquo;ve correctly added the <code>else</code> blocks.<ul><li>If the left half is sorted BUT the target is not in it, you correctly deduce you must search the right half by setting <code>left = mid + 1</code>.</li><li>If the right half is sorted BUT the target is not in it, you correctly deduce you must search the left half by setting <code>right = mid - 1</code>.</li></ul></li><li><strong>Dynamic Boundaries:</strong> You&rsquo;ve correctly identified that the bounds for the right-half check should be <code>nums[mid]</code> to <code>nums[right]</code>. (Note: your pseudocode still has <code>len(n)-1</code>, but your logic implies <code>nums[right]</code>).</li></ol><p>Let&rsquo;s refine your pseudocode into the final, clean algorithm. This is <strong>Phase 4: The Articulation</strong>.</p><hr><h3 id=final-algorithm><strong>Final Algorithm</strong></h3><p><strong>Setup:</strong></p><ul><li>Initialize <code>left = 0</code>, <code>right = len(nums) - 1</code>.</li></ul><p><strong>Main Loop:</strong></p><ul><li><code>while left &lt;= right:</code><ol><li>Calculate <code>mid = (left + right) // 2</code>.</li><li>If <code>nums[mid] == target</code>, you&rsquo;ve found it. <strong>Return <code>mid</code></strong>.</li><li><strong>Check if the left half is the sorted portion:</strong> <code>if nums[left] &lt;= nums[mid]</code>:<ul><li><strong>Check if the target is within the bounds of this sorted left half:</strong> <code>if nums[left] &lt;= target &lt; nums[mid]</code>:<ul><li>Yes, it is. Discard the right half: <code>right = mid - 1</code>.</li></ul></li><li><strong>Else (target is not in the sorted left half):</strong><ul><li>You must search the unsorted right half. Discard the left half: <code>left = mid + 1</code>.</li></ul></li></ul></li><li><strong>Else (the right half must be the sorted portion):</strong><ul><li><strong>Check if the target is within the bounds of this sorted right half:</strong> <code>if nums[mid] &lt; target &lt;= nums[right]</code>:<ul><li>Yes, it is. Discard the left half: <code>left = mid + 1</code>.</li></ul></li><li><strong>Else (target is not in the sorted right half):</strong><ul><li>You must search the unsorted left half. Discard the right half: <code>right = mid - 1</code>.</li></ul></li></ul></li></ol></li></ul><p><strong>Termination:</strong></p><ul><li>If the loop finishes (<code>left > right</code>), the target was not found. <strong>Return <code>-1</code></strong>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>] 
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_in_rotated_array</span>(nums:List[int], target:int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>	left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	right <span style=color:#f92672>=</span> len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;=</span> right:
</span></span><span style=display:flex><span>		mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> mid
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;=</span> nums[mid]: <span style=color:#75715e># check if left is sorted</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> nums[left] <span style=color:#f92672>&lt;=</span> target <span style=color:#f92672>&lt;=</span> nums[mid]: <span style=color:#75715e># check if target is in the sorted half</span>
</span></span><span style=display:flex><span>				right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># move the right to shrink the search space</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>				left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># move the left to shrink the search space</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>: <span style=color:#75715e># the right have is sorted</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>&lt;=</span> target <span style=color:#f92672>&lt;=</span> nums[right]: <span style=color:#75715e># check if the target is in the sorted half</span>
</span></span><span style=display:flex><span>				left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># move the left to shrink the search space</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>				right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># move the right to shrink the search space</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>search_in_rotated_array(nums, target)
</span></span><span style=display:flex><span>				
</span></span></code></pre></div><h1 id=variations-duplicates>Variations duplicates</h1><h2 id=cementing-the-idea>Cementing the idea</h2><ol><li><strong>Key Information:</strong> &ldquo;at each iteration at least 1 half is sorted.&rdquo; Correct.</li><li><strong>How it Helped:</strong> &ldquo;since we checked which half is sorted we could safely discard the other half if the target also fell in that sorted list&mldr;&rdquo; Precisely. You used the sorted half as your point of reference. If the target was within the bounds of the sorted half, you searched there. If not, you knew with certainty it had to be in the <em>other</em>, messier half, and you could discard the sorted portion.</li></ol><p>This pattern is a modification of Binary Search. You can think of it as <strong>&ldquo;Binary Search on a Conditionally Sorted Array.&rdquo;</strong> The core is the same—find a condition that lets you throw away half the data.</p><hr><h3 id=on-duplicates-a-final-thought-exercise><strong>On Duplicates (A Final Thought Exercise)</strong></h3><p>You said you don&rsquo;t know what you would do if there are duplicates. Let&rsquo;s explore that. You have all the tools to figure it out.</p><p><strong>The Problematic Case:</strong>
Imagine <code>nums = [3, 1, 2, 3, 3, 3, 3]</code> and <code>target = 1</code>.</p><ul><li><code>left = 0</code>, <code>right = 6</code>. <code>mid = 3</code>.</li><li><code>nums[left]</code> is <code>3</code>. <code>nums[mid]</code> is <code>3</code>. <code>nums[right]</code> is <code>3</code>.</li></ul><p>Now, apply the first check from your perfect algorithm:
<code>if nums[left] &lt;= nums[mid]:</code></p><ul><li>Is <code>3 &lt;= 3</code>? <strong>Yes</strong>.</li><li>Your code concludes the left half (<code>[3, 1, 2, 3]</code>) is the sorted portion.</li><li><strong>Is that conclusion correct?</strong></li></ul><p>What has just broken down? And what is the simplest, safest action you could take in this specific, ambiguous situation where <code>nums[left] == nums[mid] == nums[right]</code>?</p><p>You are spot on with your first two points. And your third point is the million-dollar question. You&rsquo;ve correctly identified that this action degrades the performance.</p><p>Let&rsquo;s be very precise about <em>how</em> it degrades. Your guess of <code>O(n log n)</code> is a great starting point, but let&rsquo;s trace the absolute worst-case to find the real answer.</p><p><strong>The Worst-Case Scenario:</strong></p><p>Consider this array: <code>nums = [3, 3, 3, 3, 3, 3, 1, 3]</code> and <code>target = 1</code>.</p><ul><li><code>left = 0</code>, <code>right = 7</code>. <code>mid = 3</code>.</li><li><code>nums[left]</code> is 3. <code>nums[mid]</code> is 3.</li><li>This is the ambiguous case (<code>nums[left] == nums[mid]</code>).</li><li>You apply your rule: <code>left += 1</code>.</li><li>New search space: <code>[3, 3, 3, 3, 3, 1, 3]</code> (indices 1 to 7).</li></ul><p><strong>Next Iteration:</strong></p><ul><li><code>left = 1</code>, <code>right = 7</code>. <code>mid = 4</code>.</li><li><code>nums[left]</code> is 3. <code>nums[mid]</code> is 3.</li><li>This is the ambiguous case again.</li><li>You apply your rule: <code>left += 1</code>.</li><li>New search space: <code>[3, 3, 3, 1, 3]</code> (indices 2 to 7).</li></ul><p>What is happening here? Are we dividing the search space in half? Or are we just chipping one element off the front?</p><p>In this worst-case scenario, the algorithm stops being a &ldquo;divide and conquer&rdquo; algorithm. It degenerates. What does its behavior look like in this specific situation?</p><p>In the worst-case scenario caused by duplicates (specifically, <code>nums[left] == nums[mid] == nums[right]</code>), the algorithm can no longer guarantee that it&rsquo;s discarding a known sorted half. Your safe fallback—shrinking the boundaries by one—is correct, but in the worst case, it degrades the search from a logarithmic <code>O(log n)</code> to a <strong>linear <code>O(n)</code> search</strong>.</p><p>This is the key trade-off and the correct answer for the &ldquo;follow-up with duplicates&rdquo; question. You maintain correctness, but you have to sacrifice the strict <code>O(log n)</code> guarantee in that one ambiguous case. The average case is still much better than linear, but the worst case is not.</p><hr><p>This concludes our session on Binary Search and &ldquo;Search in Rotated Sorted Array.&rdquo;</p><h3 id=session-reflection><strong>Session Reflection</strong></h3><ol><li><strong>First Principles:</strong> You started with the core idea of &ldquo;divide and conquer&rdquo; for binary search and correctly identified that the key to the rotated array problem was to find the &ldquo;always sorted&rdquo; half in any given search space.</li><li><strong>Logic Refinement:</strong> You successfully navigated the tricky boundary conditions (<code>&lt;=</code> vs <code>&lt;</code>, <code>mid-1</code> vs <code>mid</code>) and the nested <code>if/else</code> logic to build a complete, robust algorithm.</li><li><strong>Complexity Analysis:</strong> You correctly identified the time complexities of both the brute-force (<code>O(n)</code>) and optimized (<code>O(log n)</code>) solutions, and you reasoned through why the introduction of duplicates could degrade the performance back to <code>O(n)</code> in the worst case.</li></ol><p>This is exactly the thought process of a senior-level engineer. You&rsquo;ve built the solution from the ground up, not from memorization.</p><p>What problem would you like to tackle in our next session?</p></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>