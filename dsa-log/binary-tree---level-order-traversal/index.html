<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Linked List Stacks and Queues a Primer]] [[Binary trees and Binary search trees]]</p><h1 id=problem>Problem</h1><p>You are given the root of a binary tree.</p><p><strong>Your task:</strong> Write a function level_order_traversal(root) that returns a list of lists, where each inner list contains the values of the nodes at that level, from left to right.</p><p><strong>Example:</strong><br>For a tree like this:</p><pre tabindex=0><code>      3
     / \
    9   20
       /  \
      15   7
</code></pre><p>The function should return: <code>[[3], [9, 20], [15, 7]]</code></p><h1 id=brainstorming>Brainstorming</h1><p>So the idea is pretty simple , image the tree having levels level 1 being at the top. If we have to do it by hand how will that look like?</p><ol><li>Level 1 : root i.e 3 you add it to your <code>result = [[3]]</code></li><li>Level 2 : we have left = 9 and right = 20 we add this to our result <code>[[3], [9,20]]</code></li><li>Level 3 : we have left = 15 and right = 7 we add this to our result <code>[[3], [9,20], [15,7]]</code></li><li>We turn the result</li></ol><p>The challenge is how will we let the computer now these <code>levels</code> . we need to store this tree in a way that we always go wide first before we go deep. The problem is all the standard tree traversals are Depth first since they try to hit a base case before the recursive stack get unraveled. Queue seems to be a good data structure for this problem as we want to first process what we have before we move down the tree ( First in first out) a standard way of processing the queue is</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> dque
</span></span><span style=display:flex><span>queue <span style=color:#f92672>=</span> dqueue()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> queue: <span style=color:#75715e># while we have elements to process in the queue</span>
</span></span><span style=display:flex><span>	element <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>	<span style=color:#75715e># do your work</span>
</span></span></code></pre></div><p>We can utilise this information for our use case . Below is how the algorithm will look like</p><ol><li>Initialise an empty <code>queue</code> add the <code>root</code> node to it, initalise a final results list <code>results = []</code></li><li>Loop on the queue if its not empty:<ol><li>Get the length of the current level by checking the length of the <code>len_level = len(queue)</code></li><li>Initalize a list for the current level value <code>current_level = []</code></li><li>Loop till the len of the loop <code>for _ range(len_level)</code></li><li>Get node from the left of the queue <code>node = queue.popleft()</code></li><li>Add its value to the current level <code>current_level.append(node.val)</code></li><li>Check if this node have children if they do add them to the queue <code>if node.left : queue.append(node.left) if node.right : queue.append(node.right)</code></li><li>As the loop ends add the <code>current_level</code> results to the <code>results</code> <code>results.append(current_level)</code></li></ol></li><li>The while loop will continue as it goes to the next level</li></ol><p>below is the python code for the same</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span>: 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, val<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, left<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, right<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>): 
</span></span><span style=display:flex><span>	self<span style=color:#f92672>.</span>val <span style=color:#f92672>=</span> val 
</span></span><span style=display:flex><span>	self<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> left 
</span></span><span style=display:flex><span>	self<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>level_order_traversal</span>(root:TreeNode):
</span></span><span style=display:flex><span>	queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>	queue<span style=color:#f92672>.</span>append(root)
</span></span><span style=display:flex><span>	results <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>		level_len <span style=color:#f92672>=</span> len(queue)
</span></span><span style=display:flex><span>		current_level_val <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(level_len):
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>			current_level_val<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>val)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>left : queue<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>right: queue<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>		results<span style=color:#f92672>.</span>append(current_level_val)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> results
</span></span><span style=display:flex><span>	
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>