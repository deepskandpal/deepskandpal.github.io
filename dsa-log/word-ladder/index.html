<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#lets-refine-two-subtle-details-to-make-it-bulletproof>Let&rsquo;s Refine Two Subtle Details to Make it Bulletproof</a></li><li><a href=#the-final-algorithm-based-on-your-logic>The Final Algorithm (Based on Your Logic)</a></li></ul></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><h1 id=problem>Problem</h1><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -> s1 -> s2 -> ... -> sk</code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>sk == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> beginWord = &ldquo;hit&rdquo;, endWord = &ldquo;cog&rdquo;, wordList =<code>["hot","dot","dog","lot","log","cog"]</code>
<strong>Output:</strong> 5
<strong>Explanation:</strong> One shortest transformation sequence is &ldquo;hit&rdquo; -> &ldquo;hot&rdquo; -> &ldquo;dot&rdquo; -> &ldquo;dog&rdquo; -> cog", which is 5 words long.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> beginWord = &ldquo;hit&rdquo;, endWord = &ldquo;cog&rdquo;, wordList = <code>["hot","dot","dog","lot","log"]</code>
<strong>Output:</strong> 0
<strong>Explanation:</strong> The endWord &ldquo;cog&rdquo; is not in wordList, therefore there is no valid transformation sequence.</p><h1 id=brainstorming>Brainstorming</h1><p>So we want to basically transform this problem from a word problem to a graph problem. We do that by essentially defining the nodes and the edges. The key here is to see each word as only one character way from the other word. For eg &ldquo;hot&rdquo; and &ldquo;hit&rdquo; are separated by one character that is <code>i</code> so the words that are in this relationship will have a edge between them. We are essentially trying to create an adjacency list like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>words_list <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>			  <span style=color:#e6db74>&#34;hit&#34;</span>: [<span style=color:#e6db74>&#34;hot&#34;</span>,<span style=color:#e6db74>&#34;dot&#34;</span>, <span style=color:#e6db74>&#34;lot&#34;</span>],
</span></span><span style=display:flex><span>			  <span style=color:#e6db74>&#34;hot&#34;</span> : [<span style=color:#e6db74>&#34;hit&#34;</span>, <span style=color:#e6db74>&#34;dot&#34;</span>, <span style=color:#e6db74>&#34;lot&#34;</span>],
</span></span><span style=display:flex><span>			  <span style=color:#e6db74>&#34;dot&#34;</span> : [<span style=color:#e6db74>&#34;hot&#34;</span>, <span style=color:#e6db74>&#34;lot&#34;</span>, <span style=color:#e6db74>&#34;dog&#34;</span>],
</span></span><span style=display:flex><span>			  <span style=color:#e6db74>&#34;dog&#34;</span> : [<span style=color:#e6db74>&#34;log&#34;</span>, <span style=color:#e6db74>&#34;cog&#34;</span>, <span style=color:#e6db74>&#34;dot&#34;</span>],
</span></span><span style=display:flex><span>			  <span style=color:#e6db74>&#34;log&#34;</span> : [<span style=color:#e6db74>&#34;cog&#34;</span>, <span style=color:#e6db74>&#34;dog&#34;</span>, <span style=color:#e6db74>&#34;lot&#34;</span>],
</span></span><span style=display:flex><span>			  }
</span></span></code></pre></div><p>But how do we do that. One way is to change each character of the start word with all the letters in the alphabet and then see if they are in the world list</p><ol><li>Create a hash set of the original word list</li><li>create a visited hash set</li><li>take your start word add it queue</li><li>add this word to your visited hash set</li><li>start your while loop</li><li>deque your word</li><li>now using brute force try to find its neighbours<ol><li><code>HIT</code> start with <code>H</code> replace it with all the characters starting from <code>A</code> all the way to <code>Z</code></li><li>check if the <code>new</code> word is in the word list if yes add it to its neighbours</li><li>then we try with <code>O</code> and <code>T</code> we add all of them to the neighbours of <code>HIT</code></li><li>we add all the neighbours to the queue after we make sure they are already not in visited , we add them to visited too.</li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>words_list <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;hot&#34;</span>,<span style=color:#e6db74>&#34;dot&#34;</span>,<span style=color:#e6db74>&#34;dog&#34;</span>,<span style=color:#e6db74>&#34;lot&#34;</span>,<span style=color:#e6db74>&#34;log&#34;</span>,<span style=color:#e6db74>&#34;cog&#34;</span>]
</span></span></code></pre></div><p>the best part is we don&rsquo;t have to play favourites , we can explore all possible neighbours of each word that we process</p><p>but going through the word list in a queue is not enough we also need to know how many words did it take to reach till there. so for each word that we find we can update a variable say distance that gets added and then that can be made part of a tuple with the word processing.</p><p>if we hit the end word we can just return the distance + 1 calculated so far. if the queue is empty and we don&rsquo;t reach our end word it means there is no path we can traverse from start word to end word hence we can return an illegal value say -1</p><h3 id=lets-refine-two-subtle-details-to-make-it-bulletproof>Let&rsquo;s Refine Two Subtle Details to Make it Bulletproof</h3><p>Your logic is sound. Let&rsquo;s just clarify two small points to turn your description into a flawless implementation plan.</p><p><strong>Subtle Detail 1: The Initial State</strong></p><p>When you start, your queue needs its first item. Based on your logic, this would be:</p><ul><li><code>queue.append(("HIT", 1))</code>
We start the distance at <strong>1</strong>, not 0. This is because the problem asks for the <em>length</em> of the sequence (how many words are in it), not the number of <em>steps</em> (which would be length - 1). So, &ldquo;HIT&rdquo; itself is the 1st word in the sequence. This makes the final return value very clean.</li></ul><p><strong>Subtle Detail 2: The <code>visited</code> Set Timing</strong></p><p>This is a classic BFS optimisation that you touched upon. When is the absolute best time to add a word to the <code>visited</code> set?</p><ul><li><strong>Good:</strong> Add it when you <em>pop</em> it from the queue. This works, but it&rsquo;s slightly inefficient.</li><li><strong>Better:</strong> Add it <strong>just before you add it to the queue</strong>.</li></ul><p>Why is this better? Imagine <code>word_A</code> can be reached from both <code>word_B</code> and <code>word_C</code>, which are in the same &ldquo;layer.&rdquo; If you only mark <code>word_A</code> as visited when you <em>pop</em> it, both <code>B</code> and <code>C</code> will add <code>word_A</code> to the queue. You&rsquo;ll end up with duplicate work. By marking it as visited the moment you discover it, you ensure a word can only ever enter the queue once.</p><h3 id=the-final-algorithm-based-on-your-logic>The Final Algorithm (Based on Your Logic)</h3><p>Your description translates directly into this high-level plan:</p><ol><li><p><strong>Setup:</strong></p><ul><li>Create a <code>word_set</code> from the <code>word_list</code> for O(1) lookups.</li><li>Initialize a <code>queue</code> with the tuple <code>(start_word, 1)</code>.</li><li>Initialize a <code>visited_set</code> and add <code>start_word</code> to it.</li></ul></li><li><p><strong>BFS Loop:</strong></p><ul><li><code>while queue is not empty:</code><ul><li><code>current_word, distance = queue.popleft()</code></li><li><code>if current_word == end_word:</code><ul><li><code>return distance</code> (We found it!)</li></ul></li><li><strong>Find Neighbors:</strong><ul><li>Generate all possible one-letter-different words for <code>current_word</code>.</li><li>For each <code>new_word</code>:<ul><li><code>if new_word in word_set and new_word not in visited_set:</code><ul><li><code>visited_set.add(new_word)</code></li><li><code>queue.append((new_word, distance + 1))</code></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>Failure:</strong></p><ul><li>If the loop finishes (queue is empty), it means we never found a path.</li><li><code>return 0</code> (or -1, as the problem specifies).</li></ul></li></ol><p>below is the python implementation</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>beginWord <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hit&#34;</span>
</span></span><span style=display:flex><span>endWord <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cog&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;hot&#34;</span>,<span style=color:#e6db74>&#34;dot&#34;</span>,<span style=color:#e6db74>&#34;dog&#34;</span>,<span style=color:#e6db74>&#34;lot&#34;</span>,<span style=color:#e6db74>&#34;log&#34;</span>,<span style=color:#e6db74>&#34;cog&#34;</span>]
</span></span><span style=display:flex><span>words_set <span style=color:#f92672>=</span> set(words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_word_candidates</span>(word: str) <span style=color:#f92672>-&gt;</span> list[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Generates all possible one-letter-different words for a given word.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example: &#39;cat&#39; -&gt; [&#39;aat&#39;, &#39;bat&#39;, &#39;cat&#39;...&#39;zat&#39;, &#39;cbt&#39;, &#39;cct&#39;...&#39;czt&#39;, &#39;caa&#39;, &#39;cab&#39;...&#39;caz&#39;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    candidates <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#75715e># Outer loop: Iterate through each character position of the word</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(word)):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Inner loop: Try substituting each letter of the alphabet</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> alphabet_char <span style=color:#f92672>in</span> string<span style=color:#f92672>.</span>ascii_lowercase:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Create the new word by slicing and combining</span>
</span></span><span style=display:flex><span>            new_word <span style=color:#f92672>=</span> word[:i] <span style=color:#f92672>+</span> alphabet_char <span style=color:#f92672>+</span> word[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            candidates<span style=color:#f92672>.</span>append(new_word)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> candidates
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>word_ladder_length</span>(beginWord:str, endWord:str, word_set:list[str]) <span style=color:#f92672>-&gt;</span> int
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> endWord <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> word_set:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	visited <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>	queue <span style=color:#f92672>=</span> deque([(beginWord,<span style=color:#ae81ff>1</span>)])
</span></span><span style=display:flex><span>	visited <span style=color:#f92672>=</span> {beginWord}
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>		current_word, distance <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> current_word <span style=color:#f92672>==</span> endWord:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> distance
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			candidates <span style=color:#f92672>=</span> generate_word_candidate(current_word, words_set)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> candidate <span style=color:#f92672>in</span> candidates:
</span></span><span style=display:flex><span>				 <span style=color:#66d9ef>if</span> candidate <span style=color:#f92672>in</span> word_set <span style=color:#f92672>and</span> candidate <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>					 visited<span style=color:#f92672>.</span>add(candidate)
</span></span><span style=display:flex><span>					 queue<span style=color:#f92672>.</span>append((candidate, distance<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		
</span></span></code></pre></div><p>you can read more about python slicing in [[Python Slicing]]</p><p>ideal code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Helper function is perfect, no changes needed here.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_word_candidates</span>(word: str) <span style=color:#f92672>-&gt;</span> list[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Generates all possible one-letter-different words for a given word.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    candidates <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(word)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> alphabet_char <span style=color:#f92672>in</span> string<span style=color:#f92672>.</span>ascii_lowercase:
</span></span><span style=display:flex><span>            new_word <span style=color:#f92672>=</span> word[:i] <span style=color:#f92672>+</span> alphabet_char <span style=color:#f92672>+</span> word[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            candidates<span style=color:#f92672>.</span>append(new_word)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> candidates
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># The main function with all fixes applied.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>word_ladder_length</span>(beginWord: str, endWord: str, wordList: list[str]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#75715e># --- SETUP ---</span>
</span></span><span style=display:flex><span>    word_set <span style=color:#f92672>=</span> set(wordList)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> endWord <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> word_set:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># FIX: All variables are now local to the function.</span>
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([(beginWord, <span style=color:#ae81ff>1</span>)])
</span></span><span style=display:flex><span>    visited <span style=color:#f92672>=</span> {beginWord} <span style=color:#75715e># A set automatically handles the start word.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># --- BFS LOOP ---</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        current_word, distance <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_word <span style=color:#f92672>==</span> endWord:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> distance
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># FIX: The function call now matches the definition.</span>
</span></span><span style=display:flex><span>        candidates <span style=color:#f92672>=</span> generate_word_candidates(current_word)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> candidate <span style=color:#f92672>in</span> candidates:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> candidate <span style=color:#f92672>in</span> word_set <span style=color:#f92672>and</span> candidate <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>                <span style=color:#75715e># FIX: Use .add() for sets.</span>
</span></span><span style=display:flex><span>                visited<span style=color:#f92672>.</span>add(candidate)
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append((candidate, distance <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the loop finishes, no path was found.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- Let&#39;s run it! ---</span>
</span></span><span style=display:flex><span>beginWord <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hit&#34;</span>
</span></span><span style=display:flex><span>endWord <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cog&#34;</span>
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;hot&#34;</span>,<span style=color:#e6db74>&#34;dot&#34;</span>,<span style=color:#e6db74>&#34;dog&#34;</span>,<span style=color:#e6db74>&#34;lot&#34;</span>,<span style=color:#e6db74>&#34;log&#34;</span>,<span style=color:#e6db74>&#34;cog&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># We call the main function, passing in the word list.</span>
</span></span><span style=display:flex><span>final_length <span style=color:#f92672>=</span> word_ladder_length(beginWord, endWord, words)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;The length of the shortest transformation is: </span><span style=color:#e6db74>{</span>final_length<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>