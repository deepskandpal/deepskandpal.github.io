<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DSA Log on 404EngineerNotFound</title><link>https://deepskandpal.github.io/dsa-log/</link><description>Recent content in DSA Log on 404EngineerNotFound</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 29 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://deepskandpal.github.io/dsa-log/index.xml" rel="self" type="application/rss+xml"/><item><title>Restore Ip Addresses</title><link>https://deepskandpal.github.io/dsa-log/restore-ip-addresses/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/restore-ip-addresses/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;Given a string &lt;code&gt;s&lt;/code&gt; containing only digits, return all possible valid IP addresses that can be formed by inserting three dots into &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros (e.g., &amp;ldquo;01&amp;rdquo; is invalid, but &amp;ldquo;0&amp;rdquo; is valid).&lt;/p&gt;
&lt;p&gt;For example, given &lt;code&gt;s = &amp;quot;25525511135&amp;quot;&lt;/code&gt;, the valid IP addresses are &lt;code&gt;[&amp;quot;255.255.11.135&amp;quot;]&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Arbitrary_sum</title><link>https://deepskandpal.github.io/dsa-log/arbitrary_sum/</link><pubDate>Wed, 11 Jun 2025 20:16:53 +0530</pubDate><guid>https://deepskandpal.github.io/dsa-log/arbitrary_sum/</guid><description>&lt;h2 id="problem-description-optional-summary"&gt;Problem Description (Optional Summary)&lt;/h2&gt;
&lt;p&gt;The Problem: Write a function that takes such an array A representing integer D and updates it in-place to represent D + 1. Handle potential carries, including the case where the number of digits increases (like 99 + 1 = 100).&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;Brute-Force (and why it’s often not allowed/intended):&lt;/p&gt;
&lt;p&gt;Convert the array [1, 2, 9] into the integer 129.
Add 1: 129 + 1 = 130.
Convert 130 back into an array [1, 3, 0].
Limitation: This fails if the integer D is larger than the maximum value the language’s built-in integer type can hold (this isn’t an issue for Python’s runtime integers, but the problem setup often simulates fixed-precision constraints or asks you to avoid this conversion). It also doesn’t modify the array in-place directly.&lt;/p&gt;</description></item><item><title>Dutch National Flag</title><link>https://deepskandpal.github.io/dsa-log/dutch-national-flag/</link><pubDate>Wed, 14 May 2025 20:04:51 +0530</pubDate><guid>https://deepskandpal.github.io/dsa-log/dutch-national-flag/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;Given an array A and an index pivot_idx, rearrange A such that all elements less than &lt;code&gt;A[pivot_idx]&lt;/code&gt; (the pivot value) come first, followed by all elements equal to the pivot, and finally all elements greater than the pivot. This must be done in-place.&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Let 
A = [0, 1, 2, 0, 2, 1, 1]
pivot_idx = 1
pivot_value = A[pivot_idx] = 1
We maintain three pointers (our “fingers”):

smaller: end of the “LESS THAN pivot” zone.

Anything to its left is &amp;lt; pivot_value.

Starts at 0.

equal: the current “inspector” pointer.

Points to the element under examination.

Starts at 0.

larger: start of the “GREATER THAN pivot” zone (from the right end).

Anything at or to its right is &amp;gt; pivot_value.

Starts at len(A) (one past the end).


A[0...smaller-1] = LESS zone (empty)
A[smaller...equal-1] = EQUAL zone (empty)
A[equal...larger-1] = UNCLASSIFIED (the whole array)
A[larger...end] = GREATER zone (empty)

We loop while equal &amp;lt; larger:

while equal &amp;lt; larger:
 if A[equal] &amp;lt; pivot_value:
 swap(A[smaller], A[equal])
 smaller += 1
 equal += 1

 elif A[equal] == pivot_value:
 # Already in the EQUAL zone
 equal += 1

 else: # A[equal] &amp;gt; pivot_value
 larger -= 1
 swap(A[equal], A[larger])
 # do not increment `equal`!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Step-by-Step Walkthrough&lt;/p&gt;</description></item><item><title>Greatest common division</title><link>https://deepskandpal.github.io/dsa-log/gcd/</link><pubDate>Wed, 14 May 2025 20:04:51 +0530</pubDate><guid>https://deepskandpal.github.io/dsa-log/gcd/</guid><description/></item><item><title>DSA Study Log &amp; Progress Tracker</title><link>https://deepskandpal.github.io/dsa-log/dsa-study-log/</link><pubDate>Tue, 01 Oct 2024 10:00:00 +0530</pubDate><guid>https://deepskandpal.github.io/dsa-log/dsa-study-log/</guid><description>&lt;h1 id="dsa-study-log--progress-tracker"&gt;DSA Study Log &amp;amp; Progress Tracker&lt;/h1&gt;







&lt;div class="progress-chart"&gt;
&lt;center&gt;
&lt;h3&gt;Overall Progress&lt;/h3&gt;
Completed: 3 | Learning: 0 | To Do: 57
&lt;/center&gt;

&lt;pre&gt;&lt;code class="language-mermaid"&gt;%%{init: {'pie': {'textPosition': 0.75}, 'themeVariables': {'pieOuterStrokeWidth': '2px'}}}%%
pie showData
 title Overall GenAI Study Progress
 "⚪️ To Do" : 57
 
 "✅ Completed" : 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
 
&lt;p&gt;This document serves as a centralized dashboard to track my learning progress through the DSA master list. The goal is to master these high-ROI problems and patterns.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status Legend:&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Count And Say</title><link>https://deepskandpal.github.io/dsa-log/count-and-say/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/count-and-say/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://colab.research.google.com/drive/1udH4eyb9bToLC_ZPPaK-n3T-jPdbAANw#scrollTo=pD7bP8UR5oiP"&gt;rough nb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The count-and-say sequence is a sequence of digit strings defined by the recursive formula:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;countAndSay(1) = &amp;quot;1&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;countAndSay(n)&lt;/code&gt; is the way you would &amp;ldquo;say&amp;rdquo; the digit string from &lt;code&gt;countAndSay(n-1)&lt;/code&gt;, which is then converted into a new digit string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.&lt;/p&gt;</description></item><item><title>Letter Combinations Of A Phone Number</title><link>https://deepskandpal.github.io/dsa-log/letter-combinations-of-a-phone-number/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/letter-combinations-of-a-phone-number/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://colab.research.google.com/drive/1udH4eyb9bToLC_ZPPaK-n3T-jPdbAANw#scrollTo=pD7bP8UR5oiP"&gt;rough nb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a string containing digits from &lt;code&gt;2-9&lt;/code&gt; inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&lt;/p&gt;
&lt;p&gt;A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: digits = &amp;#34;23&amp;#34;
Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: digits = &amp;#34;&amp;#34;
Output: []
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;This problem is a classic example of a backtracking or recursion problem. We need to explore all possible combinations of letters for the given digits.&lt;/p&gt;</description></item><item><title>Zigzag Conversion</title><link>https://deepskandpal.github.io/dsa-log/zigzag-conversion/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/zigzag-conversion/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;The string &lt;code&gt;PAYPALISHIRING&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;P A H N
A P L S I I G
Y I R
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then read line by line: &lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows.&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;The problem asks us to reconstruct a string that is formed by reading a zigzag pattern row by row. We can solve this by simulating the placement of each character into its corresponding row.&lt;/p&gt;</description></item><item><title>Two Sum</title><link>https://deepskandpal.github.io/dsa-log/two-sum/</link><pubDate>Wed, 01 May 2024 10:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/two-sum/</guid><description>&lt;h2 id="problem-description-optional-summary"&gt;Problem Description (Optional Summary)&lt;/h2&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;target&lt;/code&gt;, return indices of the two numbers such that they add up to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;Use a hash map (dictionary in Python) to store numbers encountered so far and their indices. For each number, check if &lt;code&gt;target - current_number&lt;/code&gt; exists in the hash map. If it does, we found the pair. Otherwise, add the current number and its index to the map.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/3_sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/3_sum/</guid><description>&lt;p&gt;Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i, j, and k are distinct indices, and nums[i] + nums[j] + nums[k] == 0.
Important Constraint: The solution set must not contain duplicate triplets.
Example:
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [-1, -1, 2], [-1, 0, 1]
Explanation:
(-1) + 0 + 1 = 0
(-1) + 2 + (-1) = 0
Notice [0, 1, -1]
is the same triplet as [-1, 0, 1], so we only include it once.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/binary-tree---level-order-traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/binary-tree---level-order-traversal/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]] [[Binary trees and Binary search trees]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given the root of a binary tree.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Your task:&lt;/strong&gt; Write a function level_order_traversal(root) that returns a list of lists, where each inner list contains the values of the nodes at that level, from left to right.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
For a tree like this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; 3
 / \
 9 20
 / \
 15 7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function should return: &lt;code&gt;[[3], [9, 20], [15, 7]]&lt;/code&gt;&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/climbing-stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/climbing-stairs/</guid><description>&lt;p&gt;[[Dynamic Programming Primer]]&lt;/p&gt;
&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;you are climbing a staircase. It takes &lt;code&gt;n&lt;/code&gt; steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;h2 id="brainstorming"&gt;Brainstorming&lt;/h2&gt;
&lt;p&gt;The idea is to find the recurrence and overlapping problem
suppose we are at step 5&lt;/p&gt;
&lt;p&gt;at 5
if the last step is 1 then the second last step can either be 2 or 1
so it 5 - 2 or 5 -1&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/clone-graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/clone-graph/</guid><description>&lt;p&gt;[[Graphs]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given a reference of a node in a &lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph"&gt;connected&lt;/a&gt;&lt;/strong&gt; undirected graph.
Return a &lt;a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"&gt;&lt;strong&gt;deep copy&lt;/strong&gt;&lt;/a&gt; (clone) of the graph.&lt;/p&gt;
&lt;h1 id="brainstorming"&gt;Brainstorming&lt;/h1&gt;
&lt;p&gt;So the whole idea is based on one thing , If my existing node has say 2 neighbours and the all point back to some previous node , it means the my graph has cycle , if i don&amp;rsquo;t keep a track of what nodes are processed there is a high chance that my deep copy can go in finite loop&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/copy-list-with-random-pointer---deep-copy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/copy-list-with-random-pointer---deep-copy/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;The Problem:&lt;/strong&gt; You are given a linked list where each node has two pointers:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A standard next pointer.&lt;/li&gt;
&lt;li&gt;A random pointer, which can point to any node in the list (or None).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Your task:&lt;/strong&gt; Create a &lt;strong&gt;deep copy&lt;/strong&gt; of this entire list. A deep copy means you must create a brand new Node for every original node. The next and random pointers of your new nodes must point to the corresponding new nodes, not the original ones.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/evaluate---rpn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/evaluate---rpn/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given a string representing an arithmetic expression in &lt;strong&gt;Reverse Polish Notation (RPN)&lt;/strong&gt;. RPN is a way of writing expressions where the operator comes after its operands.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The expression 3 + 4 becomes 3,4,+.&lt;/li&gt;
&lt;li&gt;The expression (3 + 4) * 2 becomes 3,4,+,2,*.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Your task:&lt;/strong&gt; Write a function evaluate_rpn(expression) that takes this string, evaluates it, and returns the final integer result. You can assume the expression is always valid.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/find-median-of-a-stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/find-median-of-a-stream/</guid><description>&lt;h2 id="the-problem-find-median-from-data-stream"&gt;The Problem: Find Median from Data Stream&lt;/h2&gt;
&lt;p&gt;Imagine you&amp;rsquo;re working at Twitter, and you need to calculate the real-time median age of all users currently active. Numbers are flowing in one by one (25, 30, 22, 40, 35, &amp;hellip;). You can&amp;rsquo;t store the whole stream, and you can&amp;rsquo;t re-sort it every time a new number arrives.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Goal:&lt;/strong&gt; Design a data structure with two methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;addNum(num): Adds a new number from the stream.&lt;/li&gt;
&lt;li&gt;findMedian(): Returns the median of all numbers seen so far. This must be fast.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Median Refresher:&lt;/strong&gt;&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/generate-subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/generate-subsets/</guid><description>&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;For this problem, think about a scenario where we have a set of distinct configuration options or feature flags for a service. To do some comprehensive testing, we might need to generate every possible combination of these options being enabled.&lt;/p&gt;
&lt;p&gt;The task is to write a function that takes an array of &lt;strong&gt;unique&lt;/strong&gt; integers, nums, and returns all possible subsets (also known as the powerset). The solution set must not contain duplicate subsets, and you can return the subsets in any order.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/get-height-of-binary-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/get-height-of-binary-tree/</guid><description>&lt;p&gt;[[Binary trees and Binary search trees]] [[Recursion]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, return &lt;em&gt;its maximum depth&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A binary tree&amp;rsquo;s &lt;strong&gt;maximum depth&lt;/strong&gt; is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;
&lt;p&gt;![[binary_tree_height.png]]&lt;/p&gt;
&lt;h1 id="brain-storming"&gt;Brain storming&lt;/h1&gt;
&lt;p&gt;The height of a binary tree can be defined at each level by &amp;ldquo;the maximum height of any of my left and right child plus 1&amp;rdquo; . The core here is at each node ,&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/invert-a-binary-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/invert-a-binary-tree/</guid><description>&lt;p&gt;[[Recursion]] [[Binary trees and Binary search trees]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given the root of a binary tree. Your task is to swap the left and right child of every single node in the tree. The result is a tree that is a mirror image of the original.&lt;/p&gt;
&lt;h1 id="brainstorming"&gt;Brainstorming&lt;/h1&gt;
&lt;p&gt;The idea is , when you start to swap from the root you go down to each node and swap the left and the right leafs till the time you don&amp;rsquo;t hit a dead end. The best way to do this is through a traversal but which one?&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/kth-largest-element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/kth-largest-element/</guid><description>&lt;h2 id="problem-kth-largest-element-in-an-array"&gt;Problem: &lt;strong&gt;Kth Largest Element in an Array&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Given an integer array nums (e.g., [3, 2, 1, 5, 6, 4]) and an integer k (e.g., 2), return the kth largest element.&lt;/p&gt;
&lt;p&gt;In our example, the sorted array is [1, 2, 3, 4, 5, 6]. The largest is 6, the &lt;strong&gt;2nd largest is 5&lt;/strong&gt;. So the answer is 5.&lt;/p&gt;
&lt;h2 id="brain-storming"&gt;Brain storming&lt;/h2&gt;
&lt;p&gt;So the idea is we can maintain a min heap of size k and return its top element when we are done with the whole array&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/linked-list-cycle---test-for-cyclicity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/linked-list-cycle---test-for-cyclicity/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given the head of a singly linked list. It might be a normal list that ends in None, or it might contain a &lt;strong&gt;cycle&lt;/strong&gt;, where some node&amp;rsquo;s next pointer points back to a previous node in the list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Your task:&lt;/strong&gt; Write a function has_cycle(head) that returns the node where the cycle begins. If there is no cycle, it should return None.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/longest-common-subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/longest-common-subsequence/</guid><description>&lt;p&gt;[[Dynamic Programming Primer]]&lt;/p&gt;
&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;text1 = &amp;quot;abcde&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text2 = &amp;quot;ace&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Goal: Find the length of the longest sequence of characters that appears in both strings in the same order, but not necessarily contiguously. The answer here is &lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt;, length &lt;strong&gt;3&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="brain-storming"&gt;Brain Storming&lt;/h2&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/longest-consecutive-subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/longest-consecutive-subsequence/</guid><description>&lt;h2 id="the-problem"&gt;The Problem:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Longest Consecutive Sequence&lt;/strong&gt; (LeetCode #128)&lt;/p&gt;
&lt;p&gt;Given an unsorted array of integers &lt;code&gt;nums&lt;/code&gt;, return the length of the longest consecutive elements sequence.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in &lt;code&gt;O(n)&lt;/code&gt; time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input: &lt;code&gt;nums = [100, 4, 200, 1, 3, 2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Output: &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; The longest consecutive elements sequence is &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;. Its length is 4. Notice that these numbers are not next to each other in the input array.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/merge-two-sorted-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/merge-two-sorted-lists/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given two linked lists, L1 and L2, and you are guaranteed that each list is already sorted in ascending order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Your task:&lt;/strong&gt; Write a function merge_two_sorted_lists(L1, L2) that merges the two lists into a single, perfectly sorted linked list that contains all the nodes from L1 and L2. You should do this by rearranging the existing nodes, not creating new ones.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/number-of-islands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/number-of-islands/</guid><description>&lt;p&gt;[[Graphs]]&lt;/p&gt;
&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;An &amp;ldquo;island&amp;rdquo; is defined as a group of &amp;lsquo;1&amp;rsquo;s that are connected either horizontally or vertically (but not diagonally). You can assume that the entire grid is surrounded by water, so you don&amp;rsquo;t need to worry about islands extending beyond the edges of the grid.&lt;/p&gt;
&lt;p&gt;Let me give you an example to make it concrete. If you were given this grid:&lt;/p&gt;
&lt;p&gt;codeCode&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[
 [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],
 [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],
 [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],
 [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;]
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The expected output would be 3. The top-left cluster of &amp;lsquo;1&amp;rsquo;s forms one island, the single &amp;lsquo;1&amp;rsquo; in the middle is a second island, and the two &amp;lsquo;1&amp;rsquo;s in the bottom-right form a third.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/reverse-a-linked-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/reverse-a-linked-list/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt; &lt;strong&gt;Reverse a Linked List&lt;/strong&gt; (The whole thing).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Goal:&lt;/strong&gt; If we have 11 -&amp;gt; 3 -&amp;gt; 5 -&amp;gt; None, we want to end up with 5 -&amp;gt; 3 -&amp;gt; 11 -&amp;gt; None.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="brainstorming"&gt;Brainstorming&lt;/h1&gt;
&lt;p&gt;The idea is we cannot start changing the the linked list directly otherwise we will break the continuation by losing the information&lt;/p&gt;
&lt;p&gt;for eg in the example the current head &lt;code&gt;11&lt;/code&gt; points to &lt;code&gt;3&lt;/code&gt; but in the reversed form it points to &lt;code&gt;None&lt;/code&gt; if we make &lt;code&gt;11|next-&amp;gt; None&lt;/code&gt; then we will not know the address of the next pointer of 3&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/root-to-leaf-paths---binary-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/root-to-leaf-paths---binary-numbers/</guid><description>&lt;p&gt;[[Binary trees and Binary search trees]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given a binary tree where each node contains a binary digit (0 or 1). Each root-to-leaf path represents a binary number. Compute the sum of all these numbers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Example Path: &lt;code&gt;root(1) -&amp;gt; child(0) -&amp;gt; leaf(1)&lt;/code&gt; represents binary &lt;code&gt;101&lt;/code&gt;, which is 5.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="brainstorming"&gt;Brainstorming&lt;/h1&gt;
&lt;p&gt;The key idea is we need to calculate the partial sum at the node we are processing &lt;em&gt;before&lt;/em&gt; we pass it on to the child nodes. that way we are essentially &lt;em&gt;carrying&lt;/em&gt; down the results and adding values to it as we go down. This is a pre order traversal ( root -&amp;gt; left -&amp;gt; right) along with the node we would also need to maintain the &amp;ldquo;sum&amp;rdquo; as input to the recursive helper as &lt;em&gt;partial sum so far&lt;/em&gt;&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/top-k-frequent-words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/top-k-frequent-words/</guid><description>&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a non-empty list of words, return the k most frequent words.
&lt;strong&gt;The Twist:&lt;/strong&gt; Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, the word with the &lt;strong&gt;lower alphabetical order&lt;/strong&gt; comes first.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input: [&amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;, &amp;ldquo;leetcode&amp;rdquo;, &amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;, &amp;ldquo;coding&amp;rdquo;], k = 2&lt;/li&gt;
&lt;li&gt;Frequencies: &amp;ldquo;i&amp;rdquo; (2), &amp;ldquo;love&amp;rdquo; (2), &amp;ldquo;leetcode&amp;rdquo; (1), &amp;ldquo;coding&amp;rdquo; (1).&lt;/li&gt;
&lt;li&gt;The top 2 frequencies are &amp;ldquo;i&amp;rdquo; and &amp;ldquo;love&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Since they have the same frequency, we sort them alphabetically: &amp;ldquo;i&amp;rdquo; comes before &amp;ldquo;love&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Output: [&amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;]&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="brainstorming"&gt;Brainstorming&lt;/h2&gt;
&lt;p&gt;We need to first compute the frequency of words and then make sure that we are able to get &amp;ldquo;TOP K&amp;rdquo; frequent words&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/trapping-rain-water-dp-and-2-pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/trapping-rain-water-dp-and-2-pointers/</guid><description>&lt;p&gt;[[Dynamic Programming Primer]]&lt;/p&gt;
&lt;p&gt;You are given an array of non-negative integers representing an elevation map where the width of each bar is 1. Your job is to compute how much water it can trap after raining.
![[Pasted image 20251013180719.png]]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; height = [0,1,0,2,1,0,1,3,2,1,2,1]
&lt;strong&gt;Output:&lt;/strong&gt; 6
&lt;strong&gt;Explanation:&lt;/strong&gt; The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/tries-prefix-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/tries-prefix-tree/</guid><description>&lt;p&gt;A Trie (from re&lt;strong&gt;trie&lt;/strong&gt;val) data structure is used to mainly represent words in a sum of its prefix parts.&lt;/p&gt;
&lt;p&gt;A Trie class consists of 3 operations&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Insert ( adding a word)&lt;/li&gt;
&lt;li&gt;Search (finding if the exact word is in trie or not)&lt;/li&gt;
&lt;li&gt;Startswith(prefix) check if the prefix of the trie is present or not&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A Trie node contains 2 pieces of information&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Information of the next character example dict
&lt;ol&gt;
&lt;li&gt;{&amp;ldquo;a&amp;rdquo;: node_of_a, &amp;ldquo;b&amp;rdquo;: node_of_b}&lt;/li&gt;
&lt;li&gt;Is this node the end of a word is_end_of_word = True/False&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A Trie node would look like this&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/valid-paranthesis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/valid-paranthesis/</guid><description>&lt;p&gt;[[Linked List Stacks and Queues a Primer]]&lt;/p&gt;
&lt;h1 id="problem"&gt;Problem&lt;/h1&gt;
&lt;p&gt;You are given a string containing just the characters (, ), {, }, &lt;code&gt;[ and ].&lt;/code&gt;
&lt;strong&gt;Your task:&lt;/strong&gt; Write a function is_well_formed(s) that determines if the input string is &amp;ldquo;well-formed&amp;rdquo; (also known as &amp;ldquo;valid parentheses&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;A string is well-formed if:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Every opening bracket has a corresponding closing bracket of the same type.&lt;/li&gt;
&lt;li&gt;The brackets are closed in the correct order.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;()[]{}&amp;quot;&lt;/code&gt; -&amp;gt; True&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;([{}])&amp;quot;&lt;/code&gt; -&amp;gt; True (This shows the nesting)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;(]&amp;quot;&lt;/code&gt; -&amp;gt; False (Wrong type)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;([)]&amp;quot;&lt;/code&gt; -&amp;gt; False (Wrong order)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;[&amp;quot;&lt;/code&gt; -&amp;gt; False (Unclosed)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="brainstorm"&gt;Brainstorm&lt;/h1&gt;
&lt;p&gt;This again is a classic stack problem since we plan to keep a &lt;code&gt;track&lt;/code&gt; of what have we seen so far and what do we need &lt;code&gt;now&lt;/code&gt;&lt;/p&gt;</description></item><item><title/><link>https://deepskandpal.github.io/dsa-log/word-break/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/word-break/</guid><description>&lt;p&gt;[[Dynamic Programming Primer]]&lt;/p&gt;
&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;So, the problem is this: you are given a string s and a dictionary of strings wordDict. Your task is to write a function that returns true if s can be segmented into a space-separated sequence of one or more words from the dictionary. You can assume that the dictionary does not contain duplicate words, and you are allowed to reuse words from the dictionary.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at a few examples:&lt;/p&gt;</description></item></channel></rss>