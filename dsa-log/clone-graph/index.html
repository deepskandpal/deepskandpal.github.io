<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Graphs]]</p><h1 id=problem>Problem</h1><p>Given a reference of a node in a <strong><a href=https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph>connected</a></strong> undirected graph.
Return a <a href=https://en.wikipedia.org/wiki/Object_copying#Deep_copy><strong>deep copy</strong></a> (clone) of the graph.</p><h1 id=brainstorming>Brainstorming</h1><p>So the whole idea is based on one thing , If my existing node has say 2 neighbours and the all point back to some previous node , it means the my graph has cycle , if i don&rsquo;t keep a track of what nodes are processed there is a high chance that my deep copy can go in finite loop</p><p>To put in an example lets say you graph looks like this</p><pre tabindex=0><code>A-&gt;B-&gt;C-&gt;A
</code></pre><p>when we come at C if we are not keeping a track of visited nodes then the deep copy will get stuck <code>C' -> A' -> C'</code></p><p>To keep a track we can take use a hashmap (dict) which keeps a note of node and its clone, this will also help when we want to connect the nodes via the edges , this technique is very similar to what we did for [[Copy List With Random Pointer - Deep Copy]]</p><p>This is how the algorithm will look like</p><ol><li>initialise a que <code>queue = deque()</code></li><li>initialise a visiting_map <code>visited = {}</code></li><li>We take a node lets say <code>G</code> we check if its in visited or not<ol><li>it will not be present so we make a clone of it <code>clone_G = GraphVertex(label=G.label)</code></li><li>We add this to our queue <code>queue.append(G)</code></li><li>We add an entry for it in the dict <code>visited[G] = clone_G</code></li><li>now we loop till we have node in <code>while queue:</code></li><li>Inside the loop we get the node to be processed <code>node = queue.popleft()</code></li><li>We get all its neighbours <code>neighbours = node.edges</code></li><li>Now we will loop through all the neighbours<ol><li>For each neighbour we check if we have them in the visited or not? if not we do the same what we did for <code>G</code> , create a clone of it and store it in visited <code>clone_neighbour = Graphvertex(label=neighbour.label</code> <code>visited[neighbour] = clone_neighbour</code></li><li>Then we will add this neighbour to the queue for its processing when we are at its level <code>queue.append(clone_neighbour)</code></li><li>Now the important step , we will connect the cloned neighbour to its cloned parent node <code>cloned_node = visited[node]</code> <code>cloned_node.edges.append(cloned_neighbour)</code></li><li>Continue with the while loop</li></ol></li></ol></li><li>Once the while loop ends we will return <code>visited[G]</code> and that will be our cloned graph</li></ol><p>Below is the python implementation</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GraphVertex</span>:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, label):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>label <span style=color:#f92672>=</span> label
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>edges <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>clone_graph</span>(node:GraphVertex):
</span></span><span style=display:flex><span>	visited <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>	queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>	cloned_star_node <span style=color:#f92672>=</span> GraphVertex(label<span style=color:#f92672>=</span>node<span style=color:#f92672>.</span>label)
</span></span><span style=display:flex><span>	visited[node] <span style=color:#f92672>=</span> cloned_star_node
</span></span><span style=display:flex><span>	queue<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>		node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>		cloned_node <span style=color:#f92672>=</span> visted[node]
</span></span><span style=display:flex><span>		neighbours <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>edges
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> neighbour <span style=color:#f92672>in</span> neighbours:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> neighbour <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>				clone_neighbour <span style=color:#f92672>=</span> GraphVertex(label<span style=color:#f92672>=</span>neighbour<span style=color:#f92672>.</span>label)
</span></span><span style=display:flex><span>				visited[neighbour] <span style=color:#f92672>=</span> clone_neighbour
</span></span><span style=display:flex><span>				queue<span style=color:#f92672>.</span>append(neighbour)
</span></span><span style=display:flex><span>			<span style=color:#75715e># 3. Connect the clones. </span>
</span></span><span style=display:flex><span>			<span style=color:#75715e># We get the clone of the neighbor from the ledger. It&#39;s guaranteed # to be there now, either because we just created it or it was # already there.</span>
</span></span><span style=display:flex><span>			cloned_node<span style=color:#f92672>.</span>edges<span style=color:#f92672>.</span>append(visited[neighbour])
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> cloned_start_node
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>	
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>