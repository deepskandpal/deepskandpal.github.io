<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#problem>Problem</a></li><li><a href=#brain-storming>Brain storming</a></li><li><a href=#time-complexity>Time complexity</a></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Dynamic Programming Primer]]</p><h2 id=problem>Problem</h2><p>So, the problem is this: you are given a string s and a dictionary of strings wordDict. Your task is to write a function that returns true if s can be segmented into a space-separated sequence of one or more words from the dictionary. You can assume that the dictionary does not contain duplicate words, and you are allowed to reuse words from the dictionary.</p><p>Let&rsquo;s look at a few examples:</p><ol><li><p>If s = &ldquo;leetcode&rdquo; and wordDict = [&ldquo;leet&rdquo;, &ldquo;code&rdquo;], the output should be true, because &ldquo;leetcode&rdquo; can be segmented as &ldquo;leet code&rdquo;.</p></li><li><p>If s = &ldquo;applepenapple&rdquo; and wordDict = [&ldquo;apple&rdquo;, &ldquo;pen&rdquo;], the output should be true, because it can be segmented as &ldquo;apple pen apple&rdquo;. Notice that you can reuse dictionary words.</p></li><li><p>If s = &ldquo;catsandog&rdquo; and wordDict = [&ldquo;cats&rdquo;, &ldquo;dog&rdquo;, &ldquo;sand&rdquo;, &ldquo;and&rdquo;, &ldquo;cat&rdquo;], the output should be false. Even though parts of the string match, there&rsquo;s no way to segment the entire string using the dictionary words.</p></li></ol><h2 id=brain-storming>Brain storming</h2><p>so the idea is given a string can it be split into words in a dict or not . lets take one eg
s = &ldquo;leetcode&rdquo; wordDict = [&ldquo;leet&rdquo;, &ldquo;code&rdquo;] we know for sure that it can be done. How? by putting a | between s[:3] and s[3:] but how will we know that we should put a split there?
one thing that we can think of is what if we iterate over the whole string from 1st index and check if the split is valid or and we can store that info in a array in term of True and False
so dp[1] = False ( since &ldquo;L|eetcode&rdquo; is not a valid since &ldquo;L&rdquo;, &ldquo;eetcode&rdquo; are not in wordDict)
same for dp[2] = False ( since &ldquo;Le|etcode&rdquo; is also not in word dict)
for dp[3] = True ( since &ldquo;Leet|code&rdquo; is part of the word dict)
lets see if it works if we have more than 1 break for eg &ldquo;applepenapple&rdquo;
dp[4] = False (but its wrong since apple is part of the word dict )</p><p>we can tweak it a bit so that we make it a prefix check ie string up to s[3] if that can be split and if any word is available in wordDict and check if that prefix and the remaining string both are in wordDict or not</p><p>&ldquo;apple|penapple&rdquo; dp[4] ?
&ldquo;applepen|apple&rdquo; dp[7]?
dp[4] is not actually exactly splittable since even though apple is in WordDict but penapple is not</p><p>but in dp[7] the thing is clear as applepen is splittable and both words are available in word dict as well as apple is also available in wordDict</p><p>so we will run loops and tabulate the result
loop will give us the prefix string to check for split and the second loop for the split check on that prefix string</p><p>the core logic then be
we will essentially reuse the old results of the splits done for the prefix string and check use it so that we don&rsquo;t recalculate it (dynamic programming)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> s[i:] <span style=color:#f92672>in</span> word_dict:
</span></span><span style=display:flex><span>   dp[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;leetcode&#34;</span>
</span></span><span style=display:flex><span>word_Dict <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;leet&#34;</span>, <span style=color:#e6db74>&#34;code&#34;</span>]
</span></span><span style=display:flex><span>dp <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(len(s))]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, len(s)):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> s[i:] <span style=color:#f92672>in</span> word_Dict:
</span></span><span style=display:flex><span>       dp[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>the above logic however does not actually does a every possible check for the prefix i</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> prefix(i):
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> s[:j] <span style=color:#f92672>and</span> s[j:i] <span style=color:#f92672>in</span> word_Dict:
</span></span><span style=display:flex><span>          dp[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>This however is also not reusing the dp</p><p>We need to check it smartly , what if we actually combine these 2 ideas. we use the split point j as the pivot to use our tabulated data</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> j <span style=color:#f92672>in</span> prefix(i):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> dp[j] <span style=color:#f92672>and</span> s[j:i] <span style=color:#f92672>in</span> word_Dict:
</span></span><span style=display:flex><span>			dp[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>The idea works because any dp[j] will be pre computed
now we need a base case
dp[0] should it be True or false?
if we take &ldquo;leetcode&rdquo; at dp[3]
we will check for dp[0] and s[0:3] &ldquo;leet&rdquo; which is in the word_Dict so it should be true for it to be true we need dp[0] to be true</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;leetcode&#34;</span>
</span></span><span style=display:flex><span>word_Dict <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;leet&#34;</span>, <span style=color:#e6db74>&#34;code&#34;</span>]
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> len(s)
</span></span><span style=display:flex><span>dp <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> dp[j] <span style=color:#f92672>and</span> s[j:i] <span style=color:#f92672>in</span> word_Dict:
</span></span><span style=display:flex><span>			dp[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h2 id=time-complexity>Time complexity</h2><p>Your complexity analysis is mostly correct, but there&rsquo;s a subtle third factor in the time complexity that we need to consider.</p><p>You are right that the two nested loops give you a base of O(N^2).
You are also right that the space complexity for the <code>dp</code> array is O(N).</p><p>Now, let&rsquo;s look at the operation inside the inner loop: <code>s[j:i] in word_Dict</code>.</p><ul><li>What is the time complexity of the string slicing operation <code>s[j:i]</code>? In the worst case, how long can this slice be?</li><li>What is the time complexity of a hash set lookup? (Let&rsquo;s assume the words have a maximum length <code>M</code>).</li></ul><p>When you combine the complexity of the loops with the complexity of the operations inside, what is the overall time complexity?</p><p>Correct. The time complexity is O(N^3) due to the N*N loops and the O(N) slicing within the inner loop. The space complexity is O(N) for the dp array.</p><p>You&rsquo;ve successfully designed an optimal DP solution, implemented it correctly, and accurately analyzed its complexity. This is a complete and very strong answer to the problem.</p><p>Just one final thought: to make the dictionary lookup faster, if wordDict is given as a list, what would be the first thing you&rsquo;d do with it before starting your main DP loops?</p><p>we will make it a set</p></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>