<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#problem>Problem</a></li><li><a href=#brainstorming>Brainstorming</a></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><h2 id=problem>Problem</h2><p>For this problem, think about a scenario where we have a set of distinct configuration options or feature flags for a service. To do some comprehensive testing, we might need to generate every possible combination of these options being enabled.</p><p>The task is to write a function that takes an array of <strong>unique</strong> integers, nums, and returns all possible subsets (also known as the powerset). The solution set must not contain duplicate subsets, and you can return the subsets in any order.</p><p>For example, if the input is nums = [1, 2, 3], the expected output would be a list containing all eight possible subsets:</p><p>codeCode</p><pre tabindex=0><code>[
  [],
  [1],
  [2],
  [3],
  [1, 2],
  [1, 3],
  [2, 3],
  [1, 2, 3]
]
</code></pre><h2 id=brainstorming>Brainstorming</h2><p>This is a classic backtracking problem , Why backtracking well because we want unique subsets , Backtracking gives you to opportunity to explore each and every possible combinations without creating duplicates (i.e pruned subspace) But how does backtracking work,
Well as the name suggests we make a choice then we explore all possible results for that choice , then we undo the choice and move to the next choice</p><p>How can we implement it here ?</p><p>Well for starters we need to find the way to implement it. The best way is recursion as it gives the idea of exploration till it hits the base case , very common for tree traversals ( we can look this problem as a backtracking traversal tree as well)</p><p>the key thing we need when we write recursion is having a base case . We can think of this way; when we have exhausted all possible elements from the list while creating our subset we will exit</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span>
</span></span></code></pre></div><p>We will use the index for checking what is current element we are exploring . But how do we ensure we are not making duplicate subsets
lets take an example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>all_subsets <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>so <span style=color:#66d9ef>if</span> we start <span style=color:#66d9ef>with</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> thats nums[<span style=color:#ae81ff>0</span>] ie <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>subsets <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>current_subsets <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>add nums[<span style=color:#ae81ff>0</span>] to subset i<span style=color:#f92672>.</span>e current_subset <span style=color:#f92672>=</span> [ <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>index <span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>recursive call <span style=color:#66d9ef>with</span> current_subset ([<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>add nums[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>current_subset [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>index <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> len(nums) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>so we have subsets <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>current_subset<span style=color:#f92672>.</span>pop() <span style=color:#75715e># remove the last element</span>
</span></span><span style=display:flex><span>[[<span style=color:#ae81ff>1</span>]]
</span></span></code></pre></div><p>This gives a very important insight , during each subset we get 2 options , either we include the current element in the subset or not , this goes all the way down the backtracking tree</p><p>this is how the tree would look like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>
</span></span><span style=display:flex><span>      [1  ,          2,        3]
</span></span><span style=display:flex><span>       |
</span></span><span style=display:flex><span>       v
</span></span><span style=display:flex><span>    /     \
</span></span><span style=display:flex><span>include  exclude
</span></span><span style=display:flex><span>Current subset
</span></span><span style=display:flex><span>  [1]      [ ]   
</span></span><span style=display:flex><span>   |        |
</span></span><span style=display:flex><span>   v        v
</span></span><span style=display:flex><span>  next element (2)
</span></span><span style=display:flex><span>    /       \
</span></span><span style=display:flex><span> Include.  Exclude
</span></span><span style=display:flex><span>  [1,2]      [ ]
</span></span><span style=display:flex><span>    |         |
</span></span><span style=display:flex><span>    V         V
</span></span><span style=display:flex><span>    next element (3)
</span></span><span style=display:flex><span>    /.       \
</span></span><span style=display:flex><span> Include.   Exclude
</span></span><span style=display:flex><span> [1,2,3]     [ ] 
</span></span><span style=display:flex><span>all the elements exhausted
</span></span><span style=display:flex><span>Base case reached
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>All subsets formed
</span></span><span style=display:flex><span>[[1], [], [1,2], [1,2,3]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Since we have explored all possible
</span></span><span style=display:flex><span>subsets that can be formed from index 0
</span></span><span style=display:flex><span>element i.e 1 
</span></span><span style=display:flex><span>we remove it from current_subset 
</span></span><span style=display:flex><span>[1] 
</span></span><span style=display:flex><span>current_subset.pop()
</span></span><span style=display:flex><span>[]
</span></span><span style=display:flex><span>Now we will do the same for index 1 element
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[1,           2,               3]
</span></span><span style=display:flex><span>              |
</span></span><span style=display:flex><span>              V
</span></span><span style=display:flex><span>           /      \ 
</span></span><span style=display:flex><span>        Include  Exclude
</span></span><span style=display:flex><span>          [2]     []
</span></span><span style=display:flex><span>        /.   \
</span></span><span style=display:flex><span>           
</span></span></code></pre></div><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD
    A[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(0, [])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Decide for &lt;b&gt;1&lt;/b&gt;&#34;] --&gt;|&lt;b&gt;Exclude 1&lt;/b&gt;| B[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(1, [])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Decide for &lt;b&gt;2&lt;/b&gt;&#34;];
    A --&gt;|&lt;b&gt;Include 1&lt;/b&gt;| C[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(1, [1])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Decide for &lt;b&gt;2&lt;/b&gt;&#34;];
    
    B --&gt;|&lt;b&gt;Exclude 2&lt;/b&gt;| D[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(2, [])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Base Case!&lt;br&gt;all_subsets.append([])&lt;br&gt;&lt;b&gt;&lt;font color=red&gt;Result #1&lt;/font&gt;&lt;/b&gt;&#34;];
    B --&gt;|&lt;b&gt;Include 2&lt;/b&gt;| E[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(2, [2])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Base Case!&lt;br&gt;all_subsets.append([2])&lt;br&gt;&lt;b&gt;&lt;font color=red&gt;Result #2&lt;/font&gt;&lt;/b&gt;&#34;];
    
    C --&gt;|&lt;b&gt;Exclude 2&lt;/b&gt;| F[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(2, [1])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Base Case!&lt;br&gt;all_subsets.append([1])&lt;br&gt;&lt;b&gt;&lt;font color=red&gt;Result #3&lt;/font&gt;&lt;/b&gt;&#34;];
    C --&gt;|&lt;b&gt;Include 2&lt;/b&gt;| G[&#34;&lt;b&gt;&lt;font size=4&gt;getSubsets(2, [1, 2])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;Base Case!&lt;br&gt;all_subsets.append([1, 2])&lt;br&gt;&lt;b&gt;&lt;font color=red&gt;Result #4&lt;/font&gt;&lt;/b&gt;&#34;];

    style A fill:#BDECB6,stroke:#333,stroke-width:2px
    style B fill:#FFF2CC,stroke:#333,stroke-width:1px
    style C fill:#FFF2CC,stroke:#333,stroke-width:1px
    style D fill:#D6EAF8,stroke:#333,stroke-width:1px
    style E fill:#D6EAF8,stroke:#333,stroke-width:1px
    style F fill:#D6EAF8,stroke:#333,stroke-width:1px
    style G fill:#D6EAF8,stroke:#333,stroke-width:1px
</code></pre><p>The algorithm does NOT do this:</p><ul><li><p>// BAD LOGIC</p></li><li><p>find_all_subsets_starting_with(1)</p></li><li><p>find_all_subsets_starting_with(2)</p></li><li><p>find_all_subsets_starting_with(3)</p></li></ul><p>Instead, it does this:</p><ul><li><p>decide_about(1)</p><ul><li><p>Path A (&ldquo;Exclude 1&rdquo;): decide_about(2)</p><ul><li><p>Path A1 (&ldquo;Exclude 2&rdquo;): decide_about(3) -> finds subsets</p></li><li><p>Path A2 (&ldquo;Include 2&rdquo;): decide_about(3) -> finds subsets</p></li></ul></li><li><p>Path B (&ldquo;Include 1&rdquo;): decide_about(2)</p><ul><li><p>Path B1 (&ldquo;Exclude 2&rdquo;): decide_about(3) -> finds subsets</p></li><li><p>Path B2 (&ldquo;Include 2&rdquo;): decide_about(3) -> finds subsets</p></li></ul></li></ul></li></ul><p>The structure is a <strong>single, unified decision tree</strong>. Every leaf of this tree is a unique combination of &ldquo;include/exclude&rdquo; choices for all N elements. Since every leaf represents a unique path, every subset generated is unique. The [] subset is simply the result of the one unique path where the &ldquo;Exclude&rdquo; choice was made for every single element.
The current_subset.pop() is used to clean the current execution tree&rsquo;s partial solutions</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD
    subgraph &#34;Call 1: getSubsets(0, []) for nums[0]=1&#34;
        A[&#34;&lt;b&gt;&lt;font size=3&gt;cs = []&lt;/font&gt;&lt;/b&gt;&#34;] -- &#34;1. EXCLUDE choice for 1&#34; --&gt; B[&#34;Call getSubsets(1, []) for nums[1]=2&#34;];
        A -- &#34;3. INCLUDE choice for 1&#34; --&gt; H[&#34;&lt;b&gt;&lt;font color=blue&gt;cs.append(1)&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is now [1]&lt;/font&gt;&#34;];
    end

    subgraph &#34;Call 2: getSubsets(1, []) for nums[1]=2&#34;
        B -- &#34;1a. EXCLUDE choice for 2&#34; --&gt; D[&#34;Call getSubsets(2, [])&#34;];
        B -- &#34;1c. INCLUDE choice for 2&#34; --&gt; E[&#34;&lt;b&gt;&lt;font color=blue&gt;cs.append(2)&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is now [2]&lt;/font&gt;&#34;];
    end

    subgraph &#34;Base Case from Exclude/Exclude (call2)&#34;
      D -- &#34;Base Case: index=2&#34; --&gt; D_OUT[&#34;&lt;b&gt;&lt;font color=green&gt;all_subsets.append([])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;returns&#34;];
    end

    subgraph &#34;Explore &amp; Undo for Include 2 (call2)&#34;
      E -- &#34;1d. Explore&#34; --&gt; F[&#34;Call getSubsets(2, [2])&#34;];
      F -- &#34;Base Case: index=2&#34; --&gt; F_OUT[&#34;&lt;b&gt;&lt;font color=green&gt;all_subsets.append([2])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;returns&#34;];
      F_OUT -- &#34;1e. After return&#34; --&gt; E_UNDO[&#34;&lt;b&gt;&lt;font color=red&gt;cs.pop()&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is back to []&lt;/font&gt;&#34;];
      E_UNDO -- &#34;Call 2 finishes&#34; --&gt; A;
    end

    subgraph &#34;Call 3: getSubsets(1, [1]) for nums[1]=2&#34;
        H -- &#34;3a. EXCLUDE choice for 2&#34; --&gt; I[&#34;Call getSubsets(2, [1])&#34;];
        H -- &#34;3c. INCLUDE choice for 2&#34; --&gt; J[&#34;&lt;b&gt;&lt;font color=blue&gt;cs.append(2)&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is now [1, 2]&lt;/font&gt;&#34;];
    end

    subgraph &#34;Base Case from Include/Exclude (call3)&#34;
        I -- &#34;Base Case: index=2&#34; --&gt; I_OUT[&#34;&lt;b&gt;&lt;font color=green&gt;all_subsets.append([1])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;returns&#34;];
    end

    subgraph &#34;Explore &amp; Undo for Include 2 (call3)&#34;
        J -- &#34;3d. Explore&#34; --&gt; K[&#34;Call getSubsets(2, [1, 2])&#34;];
        K -- &#34;Base Case: index=2&#34; --&gt; K_OUT[&#34;&lt;b&gt;&lt;font color=green&gt;all_subsets.append([1, 2])&lt;/font&gt;&lt;/b&gt;&lt;br&gt;returns&#34;];
        K_OUT -- &#34;3e. After return&#34; --&gt; J_UNDO[&#34;&lt;b&gt;&lt;font color=red&gt;cs.pop()&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is back to [1]&lt;/font&gt;&#34;];
        J_UNDO -- &#34;Call 3 finishes&#34; --&gt; H_UNDO[&#34;&lt;b&gt;&lt;font color=red&gt;cs.pop()&lt;/font&gt;&lt;/b&gt;&lt;br&gt;&lt;font size=3&gt;cs is back to []&lt;/font&gt;&#34;];
    end

    H_UNDO -- &#34;Call 1 finishes&#34; --&gt; Z[&#34;&lt;b&gt;&lt;font size=4&gt;DONE&lt;/font&gt;&lt;/b&gt;&#34;];

    style A fill:#BDECB6,stroke:#333,stroke-width:2px
    style Z fill:#BDECB6,stroke:#333,stroke-width:2px
</code></pre><p>The code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>nums <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>all_subsets <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_subsets</span>(index, current_subset):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> len(nums):
</span></span><span style=display:flex><span>		all_subsets<span style=color:#f92672>.</span>append(list(current_subset))
</span></span><span style=display:flex><span>	<span style=color:#75715e># exclude index in subset generation</span>
</span></span><span style=display:flex><span>	generate_subsets(index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, current_subset)
</span></span><span style=display:flex><span>	current_subset<span style=color:#f92672>.</span>append(nums[index])
</span></span><span style=display:flex><span>	<span style=color:#75715e># include index in subset generation</span>
</span></span><span style=display:flex><span>	generate_subsets(index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, current_subset)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e># clear current subset of this stacks partial solutions</span>
</span></span><span style=display:flex><span>	current_subset<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>generate_subsets(<span style=color:#ae81ff>0</span>, [])
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>