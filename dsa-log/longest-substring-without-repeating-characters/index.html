<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Arrays]]</p><h1 id=problem>Problem</h1><p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without duplicate characters.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &ldquo;abcabcbb&rdquo;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &ldquo;abc&rdquo;, with the length of 3. Note that <code>"bca"</code> and <code>"cab"</code> are also correct answers.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> s = &ldquo;bbbbb&rdquo;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is &ldquo;b&rdquo;, with the length of 1.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &ldquo;pwwkew&rdquo;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &ldquo;wke&rdquo;, with the length of 3.
Notice that the answer must be a substring, &ldquo;pwke&rdquo; is a subsequence and not a substring.</p><h1 id=brainstorming>Brainstorming</h1><p>A substring is a contiguous block of characters that are part of a string a subsequence is a list of characters in order that are part of the string they may or may not be contiguous<br>so in the case of s = &ldquo;pwwkew&rdquo; is &ldquo;wke&rdquo; is a valid substring and &ldquo;pwke&rdquo; is a valid subsequence<br>to generate every possible substring we will use 2 things index and length so at each index starting from 0 we will try to create a substring of all possible length that is between 1 and the total length of the string<br>an example of this<br>index = 0 lengths 1 2 3 4 5 6 &ldquo;p&rdquo; &ldquo;pw&rdquo; &ldquo;pww&rdquo; &ldquo;pwwk&rdquo; &ldquo;pwwke&rdquo; &ldquo;pwwkew&rdquo;<br>index = 1 length 1 2 3 4 5 &ldquo;w&rdquo; &ldquo;ww&rdquo; &ldquo;wwk&rdquo; &ldquo;wwke&rdquo; &ldquo;wwkew&rdquo;<br>for each of this substring we can keep a track of the characters for the visibility. lets take &ldquo;pww&rdquo; we can iterate from start and add it to a set if we find a character already present in the set that means the substring does not satisfy our condition.<br>the time complexity is O(NXM) where N is the length of the string and M is the length of the substring<br>for the optimization of brute force we can se that it does a lot of re work say if &ldquo;abca&rdquo; is not a valid string that means we can skip the first character since we know &ldquo;abc&rdquo; is a valid string minus the latest character and &ldquo;bca&rdquo; is a valid string minus the first character we can just shift our focus to more left</p><p>i think a set would work the best since the look up time is o(1) so as we are moving our right pointer to the next character we can check if the character is present in the set or not if it is it means our substring is invalid and we need to move the left pointer by 1<br>but thats not efficient we can instead think of jumping all the way to the index from where the index became invalid<br>so we would know the index at which its invalid of eg if the s = &ldquo;pwwkew&rdquo; after reach w at index 2 we know that the string till 2 is invalid so we can just skip pw and start from w again.</p><p><strong>Exactly.</strong></p><p>That is the final piece of the puzzle. A hash map (or dictionary in Python) gives you the power to not just ask &ldquo;Have I seen this character before?&rdquo; but to ask &ldquo;Where was the <em>last place</em> I saw this character?&rdquo;</p><p>You have now designed the entire optimal algorithm. Let&rsquo;s put your pieces together into a coherent plan.</p><p><strong>Data Structures:</strong></p><ul><li>A <code>left</code> pointer, starting at 0.</li><li>A <code>max_length</code> variable, starting at 0.</li><li>Your hash map, <code>char_to_index_map</code>, to store characters and their most recently seen indices.</li></ul><p><strong>The Algorithm (The Sliding Window):</strong>
You will have one main loop that moves a <code>right</code> pointer from <code>0</code> to the end of the string.</p><p>Inside the loop, for each <code>character</code> at <code>s[right]</code>:</p><ol><li><p><strong>The Check:</strong> You look at the <code>character</code>.</p><ul><li><strong>Prompt 1:</strong> How do you check your <code>char_to_index_map</code> to see if you have encountered a duplicate <em>within your current window</em>? (A character seen before, but at an index that is <em>outside</em> your current <code>left</code> boundary, is not a problem).</li></ul></li><li><p><strong>The Action (If a duplicate is found):</strong></p><ul><li><strong>Prompt 2:</strong> You&rsquo;ve found a duplicate character inside your current window. You know you need to &ldquo;jump&rdquo; the <code>left</code> pointer. To what new position should you move it?</li></ul></li><li><p><strong>The Updates (Every time):</strong></p><ul><li><strong>Prompt 3:</strong> After handling any potential jumps, you need to update two things in every single iteration:
a. You must update your <code>char_to_index_map</code> with the current character&rsquo;s latest position. Why is it important to do this <em>after</em> the duplicate check?
b. You must update your <code>max_length</code>. The length of the <em>current</em> valid window is <code>right - left + 1</code>. How do you use this to update the overall <code>max_length</code>?
SDBVJDS</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcabcbb&#34;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>max_length <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>char_to_index_map <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> s[right] <span style=color:#f92672>in</span> char_to_index_map:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> char_to_index_map[s[right]] <span style=color:#f92672>&gt;=</span> left: <span style=color:#75715e># the latest index of the duplicate is in the current window </span>
</span></span><span style=display:flex><span>			 left <span style=color:#f92672>=</span> char_to_index_map[s[right]] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># jump the left pointer</span>
</span></span><span style=display:flex><span>			 char_to_index_map[s[right]] <span style=color:#f92672>=</span> right <span style=color:#75715e># update the index of the duplicate with the latest index</span>
</span></span><span style=display:flex><span>			 current_length <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#75715e># calculate the length of the window</span>
</span></span><span style=display:flex><span>			 max_length <span style=color:#f92672>=</span> max(current_length, max_length)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		char_to_index_map[s[right]] <span style=color:#f92672>=</span> right <span style=color:#75715e># add the character and its index</span>
</span></span><span style=display:flex><span>		current_length <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>		max_length <span style=color:#f92672>=</span> max(current_length, max_length)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(max_length)
</span></span></code></pre></div><p>Ideal version: <em>The only thing that sometimes happens is the left pointer jump.</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Initialization is perfect</span>
</span></span><span style=display:flex><span>left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>max_length <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>char_to_index_map <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Loop is perfect</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Let&#39;s get the current character</span>
</span></span><span style=display:flex><span>    char <span style=color:#f92672>=</span> s[right]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># The only conditional part of the logic: the jump.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Check if this character is a duplicate that is INSIDE our window.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> char <span style=color:#f92672>in</span> char_to_index_map <span style=color:#f92672>and</span> char_to_index_map[char] <span style=color:#f92672>&gt;=</span> left:
</span></span><span style=display:flex><span>        <span style=color:#75715e># If it is, jump the left pointer.</span>
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> char_to_index_map[char] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#75715e># These next three steps happen EVERY time, unconditionally.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 1. Update the map with the latest position of the character.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># This must be done AFTER the check above.</span>
</span></span><span style=display:flex><span>    char_to_index_map[char] <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 2. Calculate the length of the current valid window.</span>
</span></span><span style=display:flex><span>    current_length <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 3. Update the overall max_length.</span>
</span></span><span style=display:flex><span>    max_length <span style=color:#f92672>=</span> max(max_length, current_length)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># return max_length</span>
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>