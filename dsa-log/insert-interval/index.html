<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#dry-run-the-flaw-revealed>Dry Run: The Flaw Revealed</a></li><li><a href=#the-core-insight-delaying-the-append>The Core Insight: Delaying the Append</a></li></ul></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><h1 id=problem>Problem</h1><p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code> represent the start and the end of the <code>ith</code> interval and <code>intervals</code> is sorted in ascending order by <code>starti</code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p><p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>starti</code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p><p>Return <code>intervals</code> <em>after the insertion</em>.</p><p><strong>Note</strong> that you don&rsquo;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> intervals =<code>[[1,3],[6,9]]</code>, newInterval = <code>[2,5]</code>
<strong>Output:</strong> <code>[[1,5],[6,9]]</code></p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> intervals =<code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code>
<strong>Output:</strong> <code>[[1,2],[3,10],[12,16]]</code>
<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with<code>[3,5],[6,7],[8,10]</code></p><h1 id=brainstorming>Brainstorming</h1><p>so the problem is a clever linear scan problem of arrays. lets get the requirements clear</p><ol><li>we need to find non overlapping intervals before our new interval they should be part of our new interval range</li><li>we need to find non overlapping intervals after our new interval they also should be a part of our new interval range</li><li>for the interval that we find to overlap we need to merge them<ol><li>we will take the min of the start value and the max of the end value that becomes a new interval that needs to be added</li></ol></li></ol><p>this is how the algorithm will look like</p><ol><li>loop on the intervals array<ol><li>for each interval in intervals check the end values of the interval and new interval if the end value of the new interval is more than the existing one it means they will overlap<ol><li>now we need to form a new interval that engulfs both the new and the old intervals , we do so my finding the <code>min(star_interval, start_new_interval)</code> and <code>max(end_interval, end_new_interval)</code></li><li>with this new interval formed we further our search for more overlapping intervals</li></ol></li></ol></li><li>in order to do step 1.2 we need to make sure that we compare all the new intervals with our newly formed interval. to do so we need to add another check if the interval we are checking is either present in the result or not and then check for the overlap</li></ol><p>lets try to write it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>intervals <span style=color:#f92672>=</span>[[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>],[<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>9</span>]]
</span></span><span style=display:flex><span>newInterval <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># our results array</span>
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> interval <span style=color:#f92672>in</span> intervals:
</span></span><span style=display:flex><span>	<span style=color:#75715e># we try to check if interval is already part of our result or not </span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> interval <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> result <span style=color:#f92672>or</span> interval[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;=</span> new_interval[<span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>		merge_interval <span style=color:#f92672>=</span> [min(interval[<span style=color:#ae81ff>0</span>], new_interval[<span style=color:#ae81ff>0</span>]), max(interval[<span style=color:#ae81ff>1</span>],new_interval[<span style=color:#ae81ff>1</span>])]
</span></span><span style=display:flex><span>		result<span style=color:#f92672>.</span>append(merge_interval)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		result<span style=color:#f92672>.</span>append(interval)
</span></span><span style=display:flex><span>		
</span></span></code></pre></div><p>lets try to dry run the algo</p><p><code>intervals = [[1,3], [6,9]]</code> <code>new_interval = [2,5]</code></p><p>we iterate over intervals</p><ol><li><code>[1,3]</code> is it in our results array no , is <code>interval[1] ie 3</code> less than or equal to <code>new_interval[1] ie 6</code> yes its less<ol><li>make a new interval with <code>[1,3] and [2,5]</code> using min and max of start and end intervals of both the overlapping intervals hence <code>[1,5]</code> make this part of our new results <code>results = [[1,5]]</code></li></ol></li><li><code>[6,9]</code> we take this<ol><li>is interval part of our results array No is <code>interval[1] ie 9</code> less than or equal to <code>newInterval[1] ie 5</code> No hence we we just add it as is to the results<ol><li>result = <code>[[1,5],[6,9]]</code></li></ol></li></ol></li><li>we return the results array</li></ol><p>the problem with the above algorithm is it will not be able to merge consecutive intervals</p><p>Let&rsquo;s try a trickier example that will break the current code:<br>intervals = <code>[[1,2], [3,5], [6,7], [8,10], [12,16]]</code>
newInterval = <code>[4,8]</code></p><p>`The correct answer should be [[1,2], [3,10], [12,16]]. The newInterval [4,8] needs to merge with [3,5], then [6,7], and then [8,10] to form the final [3,10] block.</p><p>`Let&rsquo;s dry run your algorithm with this:</p><ol><li><strong>interval = <code>[1,2]</code></strong>: It doesn&rsquo;t overlap with <code>[4,8]</code>. Let&rsquo;s assume your code handles this and adds <code>[1,2]</code> to the result. result =<code>[[1,2]]</code></li><li><strong>interval = <code>[3,5]</code></strong>: It overlaps with <code>[4,8]</code>. Your code correctly merges them into <code>[min(3,4), max(5,8)]</code> which is <code>[3,8]</code>. It adds this to the result. result = <code>[[1,2], [3,8]]</code></li><li><strong>interval = <code>[6,7]</code></strong>: It overlaps with the original newInterval<code> [4,8]</code>. Your code merges them into <code>[min(6,4), max(7,8)]</code> which is <code>[4,8]</code>. It adds this. result =<code>[[1,2], [3,8], [4,8]]</code>.</li><li><strong>interval = <code>[8,10]</code></strong>: It overlaps with the original newInterval <code>[4,8]</code>. Your code merges them into <code>[min(8,4), max(10,8)]</code> which is <code>[4,10]</code>. It adds this. result =<code>[[1,2], [3,8], [4,8], [4,10]].</code></li></ol><p>You can see the problem. The result is incorrect because you&rsquo;re repeatedly merging with the original newInterval and adding intermediate results.</p><p>More robust approach Before merge After</p><p><strong>The &ldquo;BEFORE&rdquo; Loop</strong><br>First, create a loop that does one simple job: find all the intervals that are completely before the newInterval. An interval <code>[s, e]</code> is &ldquo;before&rdquo; if e &lt; newInterval.start. Just add these directly to your result list.</p><p><strong>The &ldquo;MERGE&rdquo; Loop</strong><br>Now, start a second loop from where you left off. This loop&rsquo;s job is to find all intervals that overlap. The condition for overlap is interval.start &lt;= newInterval.end.</p><ul><li><strong>Crucially:</strong> Do NOT add anything to the result list here.</li><li>Just keep updating your newInterval by taking the min of the starts and the max of the ends.</li></ul><pre tabindex=0><code># With newInterval = [4,8]
# Continue from [3,5]. Is 3 &lt;= 8? Yes.
#   newInterval becomes [min(4,3), max(8,5)] -&gt; [3,8]
# Next, [6,7]. Is 6 &lt;= 8? Yes.
#   newInterval becomes [min(3,6), max(8,7)] -&gt; [3,8]
# Next, [8,10]. Is 8 &lt;= 8? Yes.
#   newInterval becomes [min(3,8), max(8,10)] -&gt; [3,10]
# Next, [12,16]. Is 12 &lt;= 10? No. Stop this loop.
</code></pre><p><strong>The &ldquo;AFTER&rdquo; Stage</strong><br>The MERGE loop is over. What is the very next thing you must do? You have your final, fully merged newInterval <code>([3,10])</code>. Add it to the result list.</p><pre tabindex=0><code># result was [[1,2]]
# Add the final newInterval.
# result is now [[1,2], [3,10]]
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>intervals <span style=color:#f92672>=</span>[[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>5</span>],[<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>],[<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>10</span>],[<span style=color:#ae81ff>12</span>,<span style=color:#ae81ff>16</span>]]
</span></span><span style=display:flex><span>new_interval <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> interval <span style=color:#f92672>in</span> intervals:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> interval[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> new_interval[<span style=color:#ae81ff>0</span>]: <span style=color:#75715e># before</span>
</span></span><span style=display:flex><span>		result<span style=color:#f92672>.</span>append(new_interval)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>elif</span> interval[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> new_interval[<span style=color:#ae81ff>1</span>]: <span style=color:#75715e># overlapping interval</span>
</span></span><span style=display:flex><span>		new_interval <span style=color:#f92672>=</span>  [min(interval[<span style=color:#ae81ff>0</span>], new_interval[<span style=color:#ae81ff>0</span>]), max(interval[<span style=color:#ae81ff>1</span>],new_interval[<span style=color:#ae81ff>1</span>])]
</span></span><span style=display:flex><span>		result<span style=color:#f92672>.</span>append(new_interval)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>: <span style=color:#75715e># after</span>
</span></span><span style=display:flex><span>		result<span style=color:#f92672>.</span>append(interval)
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		
</span></span></code></pre></div><p>code is falling into the same subtle but critical trap: <strong>you are adding items to the result list too early.</strong></p><p>An algorithm must handle all cases, including merging with multiple intervals. Let&rsquo;s do a quick dry run with your new code to see why this is a problem.</p><h3 id=dry-run-the-flaw-revealed>Dry Run: The Flaw Revealed</h3><p>intervals =<code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>
new_interval = <code>[4,8]</code> (A good, tricky example)<br>result = []</p><ol><li><strong>interval = <code>[1,2]</code></strong>:<ul><li>interval<code>[1]</code> &lt; new_interval<code>[0]</code> (i.e., 2 &lt; 4) is <strong>TRUE</strong>.</li><li>The if block runs.</li><li>result.append(new_interval) is executed.</li><li>result is now<code>[[4,8]]</code>. <strong>(Incorrect. We should have added <code>[1,2]</code>)</strong>.</li></ul></li></ol><p>Let&rsquo;s pause. We found a bug on the very first step. The &ldquo;BEFORE&rdquo; phase should add the current interval (<code>[1,2]</code>), not the new_interval.</p><h3 id=the-core-insight-delaying-the-append>The Core Insight: Delaying the Append</h3><p>The problem is that you must <strong>finish all the merging before you add the result of the merge</strong></p><ol><li><strong>Stage 1: The &ldquo;BEFORE&rdquo; stage.</strong><ul><li>Create an empty result list.</li><li>Go through the intervals. As long as they are all completely before new_interval, add them to result.</li><li><strong>Stop</strong> as soon as you find the first interval that is NOT completely before.</li></ul></li><li><strong>Stage 2: The &ldquo;MERGE&rdquo; stage.</strong><ul><li>Now, continue from where you left off. As long as the intervals are overlapping with your (constantly updating) new_interval, <strong>do not add anything to result</strong>.</li><li>Your only job in this stage is to keep updating new_interval by merging it with the current overlapping interval.</li><li><strong>Stop</strong> as soon as you find the first interval that does not overlap.</li></ul></li><li><strong>The CRITICAL step:</strong><ul><li>The MERGE stage is over. NOW, and only now, do you <strong>add your final, fully-merged new_interval to the result list.</strong></li></ul></li><li><strong>Stage 3: The &ldquo;AFTER&rdquo; stage.</strong><ul><li>Continue from where you left off.</li><li>Add all the remaining intervals, which are guaranteed to be &ldquo;after&rdquo; intervals, directly to the result list.</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>intervals <span style=color:#f92672>=</span>[[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>5</span>],[<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>],[<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>10</span>],[<span style=color:#ae81ff>12</span>,<span style=color:#ae81ff>16</span>]]
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> len(intervals)
</span></span><span style=display:flex><span>new_interval <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># before</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> intervals[i][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> new_interval[<span style=color:#ae81ff>0</span>]:
</span></span><span style=display:flex><span>	result<span style=color:#f92672>.</span>append(interval[i])
</span></span><span style=display:flex><span>	i <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># merge</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i,n):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> intervals[j][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> new_interval[<span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>		new_interval <span style=color:#f92672>=</span>  [min(interval[<span style=color:#ae81ff>0</span>], new_interval[<span style=color:#ae81ff>0</span>]), max(interval[<span style=color:#ae81ff>1</span>],new_interval[<span style=color:#ae81ff>1</span>])]
</span></span><span style=display:flex><span>		i <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>result<span style=color:#f92672>.</span>append(new_interval)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># after</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>	result<span style=color:#f92672>.</span>append(intervals[i])
</span></span><span style=display:flex><span>	
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>