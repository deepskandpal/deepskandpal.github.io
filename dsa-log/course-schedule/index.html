<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#what-is-a-topological-sort-the-getting-dressed-analogy>What is a Topological Sort? The &ldquo;Getting Dressed&rdquo; Analogy</a></li></ul></li><li><a href=#course-schedule>Course Schedule</a></li></ul></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Graphs]]</p><h1 id=problem>Problem</h1><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><p>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</p><p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code></p><p><strong>Example 1:</strong></p><pre><code>Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</code></pre><h1 id=brainstorming>Brainstorming</h1><h3 id=what-is-a-topological-sort-the-getting-dressed-analogy>What is a Topological Sort? The &ldquo;Getting Dressed&rdquo; Analogy</h3><p>Imagine you&rsquo;re getting dressed in the morning. You have a bunch of clothes: socks, shoes, underwear, pants, shirt, and a jacket.</p><p>You know there are rules. You can&rsquo;t just put them on in any random order.</p><ul><li>You must put on <strong>socks before shoes</strong>.</li><li>You must put on <strong>underwear before pants</strong>.</li><li>You must put on a <strong>shirt before a jacket</strong>.</li></ul><p>A topological sort is simply <strong>a valid order</strong> in which you can put on your clothes.</p><p>For example, this is a valid order (a topological sort):<br>underwear -> pants -> socks -> shirt -> shoes -> jacket</p><p>This is also a valid order:<br>socks -> underwear -> shirt -> pants -> jacket -> shoes</p><p>But this is <strong>NOT</strong> a valid order:<br>shoes -> socks -> &mldr; (You broke a rule!)</p><p>So, a topological sort gives you a linear ordering of things that have dependencies.</p><p>Now, let&rsquo;s connect this to graphs.</p><ul><li>The clothes (socks, shoes, etc.) are the <strong>vertices</strong>.</li><li>The rules (&ldquo;must do A before B&rdquo;) are the <strong>directed edges</strong>. So, you&rsquo;d have an edge socks -> shoes.</li></ul><p>One last crucial question: What if you had a rule A -> B and another rule B -> A? Could you ever get dressed? No! This is a <strong>cycle</strong>. A topological sort is only possible if there are <strong>no cycles</strong>. A directed graph with no cycles is called a <strong>DAG (Directed Acyclic Graph)</strong>.</p><h2 id=course-schedule>Course Schedule</h2><p>lets look at the example
<code>[0,1]</code> it means to do course 1 we need to to do course 0 , but what about course <code>0</code> ? we don&rsquo;t need to take any course for that</p><p>in order to work with graphs we need to first store them , the best way to do so is adjacency list . in this example we can start simple</p><p><code>{0:[1]}</code> here we are representing the key as a course and the value is the the list of courses that depend on it .</p><p>what about <code>numCourses = 3 and prerequisites = [[0,1], [1,2]]</code> the adjacency list will look like <code>{0:[1], 1:[2]}</code></p><p>what about <code>numCourses = 2, prerequisites = [[1,0],[0,1]]</code> the adjacency list will be <code>{1:[0], 0:[1]}</code></p><p>but how do we know which is the course that we need to take? also how would we know if the cyclic dependency issue of example 3 ?</p><p>to answer this we would need another list where we represent the number of courses required to complete the current course . the best data structure to show this is an array where the index can represent the course for eg index 0 can be course 0 and the value at the index can be the number of courses required to complete that course we can show this for our examples</p><p><code>[0,1]</code> adjacency list <code>{0:[1]}</code> pre_req_list = <code>[0,1]</code>
<code>[[0,1], [1,2]]</code> adjacency list = <code>{0:[1], 1:[2]}</code> pre_req_list = <code>[0,1,1]</code>
<code>[[1,0], [0,1]]</code> adjacency list = <code>{1:[0], 0:[1]}</code> pre_req_list = <code>[1,1]</code></p><p>this idea of a prerequisite list is pretty powerful as it solved 2 problems</p><ol><li>how many courses do we need to finish before we can take the current course</li><li>if there are courses that depend on each other?</li></ol><p>but how does it all come together now?</p><p>the good starting point would be to put together all the courses that we can take at the start which have no pre requisite and add them to a queue for processing</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span>queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> index, i <span style=color:#f92672>in</span> enumerat(pre_req_list):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		queue<span style=color:#f92672>.</span>append(index)	
</span></span><span style=display:flex><span>		
</span></span></code></pre></div><p>now we will start processing this queue till the time its not empty using a while loop
but what does processing look like</p><ol><li>we need to take the course i.e pop it from the queue</li><li>then we need to find its dependent course we can do that with our adjacency list</li><li>now for this list of neighbours we go one by one and delete 1 course requirement from the pre requisite array</li><li>if after this course taking we find that all the pre requistes are satisfied i.e the value of the course index is 0 that means that course is ready to be taken hence we add it to the queue for processing</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>	course <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>	result<span style=color:#f92672>.</span>append(course) <span style=color:#75715e># take the course</span>
</span></span><span style=display:flex><span>	dependent_courses <span style=color:#f92672>=</span> adjacency_list[course]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> course <span style=color:#f92672>in</span> dependent_courses:
</span></span><span style=display:flex><span>		pre_req_list[course] <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> pre_req_list[course] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>			queue<span style=color:#f92672>.</span>append(course)
</span></span></code></pre></div><p>now for the cyclic dependencies if the result array is empty it will be clear that there are cycles in the graph hence topological sort is not possible. How , well if you see the first step where we try to get all the pre-requisite courses in the first pass in cyclic graphs this queue will never get formed hence the remaining algorithm will not even being so the final test we have to do is</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> result 
</span></span></code></pre></div><p>In that specific scenario, the queue never gets anything added to it, the loop never runs, and the result list is indeed empty.</p><p>But let&rsquo;s consider a slightly trickier case. What if a cycle exists, but not all courses are part of it?</p><p>Consider numCourses = 3 and prerequisites =<code>[[0,1], [1,2], [2,1]]</code></p><ul><li>Course 0 is a valid starting course.</li><li>But there is a cycle between Course 1 and Course 2.</li></ul><p>Let&rsquo;s trace your algorithm:</p><ol><li><p><strong>Setup:</strong></p><ul><li>adjacency_list = <code>{0: [1], 1: [2], 2: [1]}</code></li><li>pre_req_list = <code>[0, 2, 1]</code> (Course 1 needs 2 prereqs, Course 2 needs 1)</li></ul></li><li><p><strong>Initialization:</strong></p><ul><li>You scan pre_req_list. The only course with 0 prereqs is Course 0.</li><li>queue becomes <code>[0].</code></li></ul></li><li><p><strong>Loop starts:</strong></p><ul><li>course = 0 is popped from the queue.</li><li>result becomes <code>[0].</code></li><li>The dependent course is 1. You update its pre-req count: <code>pre_req_list[1] becomes 2 - 1 = 1.</code></li><li>Since the count for 1 is not 0, it is not added to the queue.</li></ul></li><li><p><strong>End of loop:</strong> The queue is now empty. The loop terminates.</p></li></ol><p>What is your final result list? It&rsquo;s <code>[0]</code>. <strong>It is not empty!</strong></p><p>But did we succeed? No. We only managed to take 1 out of the 3 courses. We got stuck because the remaining courses, 1 and 2, are locked in a cycle, forever waiting for each other.</p><p>So, the condition is not just about the result being empty. It&rsquo;s about whether the result contains <strong>everything</strong> it should.</p><p><strong>The real test is:</strong></p><p>Did the number of courses we were able to take (len(result)) equal the total number of courses we were supposed to take (numCourses)?</p><p>Therefore, the final line should be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>return</span> len(result) <span style=color:#f92672>==</span> numCourses
</span></span></code></pre></div><p>putting everything together</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque , defaultdict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>numCourses <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>prequisites <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>adjaency_list <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># create the adjancency list</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> course1 , course2 <span style=color:#f92672>in</span> prequisites:
</span></span><span style=display:flex><span>	adjaency_list[course1]<span style=color:#f92672>.</span>append(course2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Step 1: Start with a list of all zeros.</span>
</span></span><span style=display:flex><span>pre_req_list <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> numCourses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Step 2 &amp; 3: Read the rules and update the counts.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># For a rule like [A, B], it&#39;s Course B that has the prerequisite.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> prereq, course <span style=color:#f92672>in</span> prerequisites:
</span></span><span style=display:flex><span>    pre_req_list[course] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> index, i <span style=color:#f92672>in</span> enumerate(pre_req_list):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		queue<span style=color:#f92672>.</span>append(index)	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>	course <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>	result<span style=color:#f92672>.</span>append(course) <span style=color:#75715e># take the course</span>
</span></span><span style=display:flex><span>	dependent_courses <span style=color:#f92672>=</span> adjacency_list[course]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> course <span style=color:#f92672>in</span> dependent_courses:
</span></span><span style=display:flex><span>		pre_req_list[course] <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> pre_req_list[course] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>			queue<span style=color:#f92672>.</span>append(course)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(len(result) <span style=color:#f92672>==</span> numCourses)
</span></span></code></pre></div><p>Ideal version</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque, defaultdict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>numCourses <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>prerequisites <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- Data Structure Setup ---</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Using the corrected variable name</span>
</span></span><span style=display:flex><span>adjacency_list <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span><span style=color:#75715e># Initialize the prerequisite counter list with all zeros</span>
</span></span><span style=display:flex><span>pre_req_list <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> numCourses
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create the adjacency list AND the prerequisite list in the same loop</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> prereq, course <span style=color:#f92672>in</span> prerequisites:
</span></span><span style=display:flex><span>    adjacency_list[prereq]<span style=color:#f92672>.</span>append(course)
</span></span><span style=display:flex><span>    pre_req_list[course] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># Increment the count for the course that has the prereq</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- Kahn&#39;s Algorithm ---</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Find the starting courses (those with 0 prerequisites)</span>
</span></span><span style=display:flex><span>queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span><span style=color:#75715e># Using the corrected &#39;enumerate&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> index, count <span style=color:#f92672>in</span> enumerate(pre_req_list):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>.</span>append(index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Process the courses</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Use popleft() for First-In, First-Out behavior</span>
</span></span><span style=display:flex><span>    course <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>    result<span style=color:#f92672>.</span>append(course) <span style=color:#75715e># &#34;Take&#34; the course</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If this course was a prerequisite for other courses...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> course <span style=color:#f92672>in</span> adjacency_list:
</span></span><span style=display:flex><span>        dependent_courses <span style=color:#f92672>=</span> adjacency_list[course]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dependent <span style=color:#f92672>in</span> dependent_courses:
</span></span><span style=display:flex><span>            <span style=color:#75715e># ...decrement their prerequisite count</span>
</span></span><span style=display:flex><span>            pre_req_list[dependent] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># If a dependent course now has 0 prereqs, it&#39;s ready to be taken</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> pre_req_list[dependent] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(dependent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- Final Check ---</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Is it possible to finish all courses? </span><span style=color:#e6db74>{</span>len(result) <span style=color:#f92672>==</span> numCourses<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Let&#39;s also see the valid order:</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;A valid order to take the courses is: </span><span style=color:#e6db74>{</span>result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>