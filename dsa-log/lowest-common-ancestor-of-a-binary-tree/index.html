<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class=dsa-single><h1></h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty->N/A</span> |
<strong>Solved:</strong> January 1, 0001</p></div><div class=dsa-content><p>[[Binary trees and Binary search trees]]</p><h1 id=problem>Problem</h1><p>you are given the root of a binary tree and two nodes, <code>p</code> and <code>q</code>, that are in the tree. Find the node that is the &ldquo;lowest&rdquo; (deepest) common ancestor of both <code>p</code> and <code>q</code>. The node itself can be an ancestor.</p><p>Example 1</p><pre tabindex=0><code>  A
 / \
 B C
/ / \
D E F
</code></pre><ul><li><p><strong>LCA of D and E:</strong> The path to D is <code>A -> B -> D</code>. The path to E is <code>A -> C -> E</code>. The first (and only) common node in those paths is <strong>A</strong>.</p></li><li><p><strong>LCA of E and F:</strong> The path to E is <code>A -> C -> E</code>. The path to F is <code>A -> C -> F</code>. The lowest common ancestor is <strong>C</strong>.</p></li></ul><h1 id=brainstorming>Brainstorming</h1><p>What is an LCA? as the definition states its the lowest ( starting) from the top node which hosts our nodes <code>p</code> and <code>q</code> on the left and the right side of it. It may or may not be the node that directly hosts them. As given in the example problem. But how do we find them.</p><p>Suppose we have to trace it by hand for the below tree how would that algo look?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>   A
</span></span><span style=display:flex><span>  / \
</span></span><span style=display:flex><span> B   C
</span></span><span style=display:flex><span>/ \  / \
</span></span><span style=display:flex><span>F E  D  G
</span></span></code></pre></div><p>lets see if <code>p</code> is <code>B</code> and <code>q</code> is C
we start at root <code>A</code>
we check if <code>B</code> and <code>C</code> are on the either side of the node it is and then if they are there then we can return <code>A</code> as the common LCA . but this doesn&rsquo;t work well for cases where the current node is not directly hosting our <code>P</code> and <code>Q</code> .</p><p>So instead of doing top down lets do a bottom up approach where we traverse a tree all the way from a leaf to the top
take the case of <code>B</code> and <code>C</code> if do post order traversal then</p><ol><li>We will first go left and all the way down i.e till <code>F</code></li><li>We can check if F is B or C its not. we return Nothing</li><li>Then we go right i.e to E is E B or C , its not we return Nothing.</li><li>then we check if B is B or C it is !! we return it <code>Current_node</code></li><li>Now we are at <code>A</code> and from left we have found 1 node that is B</li><li>we go right and then left i.e <code>D</code> is C or B no we return nothing</li><li>We go right to <code>G</code> is it B or C no we return nothing</li><li>then we check for <code>C</code> is it B or C yes !! we return it <code>Current_node</code></li><li>now we have a result from right and left at <code>A</code> level so the check at the current node is simple<ol><li>if both <code>right</code> and <code>left</code> are not none that means the current node is the LCA ( since we have gone bottom to top hence the first node that satisfies this is by default the lowest)</li><li>if in case we find either <code>left</code> or <code>right</code> we just return that</li></ol></li><li>This way we are traversing a tree in reverse order and storing the result</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, val<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, left<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, right<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>val <span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lca_binary_tree</span>(node:TreeNode, p, q):
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e># Base case 2</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> node <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e># Base case 2 if the current node is a value we are trying to find</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> p <span style=color:#f92672>or</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> q:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e># traversal</span>
</span></span><span style=display:flex><span>	left <span style=color:#f92672>=</span> lca_binary_tree(node<span style=color:#f92672>.</span>left, p,q)
</span></span><span style=display:flex><span>	right <span style=color:#f92672>=</span> lca_binary_tree(node<span style=color:#f92672>.</span>right, p,q)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> left <span style=color:#f92672>and</span> right:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> node <span style=color:#75715e># we have found our LCA</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> left <span style=color:#f92672>or</span> right <span style=color:#75715e># return either of the node we find</span>
</span></span></code></pre></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>