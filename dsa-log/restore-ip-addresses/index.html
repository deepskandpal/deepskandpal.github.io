<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#problem-description>Problem Description</a></li><li><a href=#solution-approach>Solution Approach</a></li><li><a href=#complexity-analysis>Complexity Analysis</a></li><li><a href=#notes--learnings>Notes & Learnings</a></li></ul></nav></nav></aside><article class=dsa-single><h1>Restore Ip Addresses</h1><div class=dsa-meta><p><strong>Difficulty:</strong> <span class=difficulty-medium>Medium</span> |
<strong>Solved:</strong> July 29, 2025
| <a href=https://leetcode.com/problems/restore-ip-addresses/ target=_blank rel="noopener noreferrer">View on LeetCode <i class="fas fa-external-link-alt fa-xs"></i></a>
(ID: 93)</p><p><strong>Topics:</strong>
<span>Recursion and Backtracking</span>
,
<span>Strings</span></p><p><strong>Tags:</strong>
<span>Backtracking</span>
,
<span>Python</span></p></div><div class=dsa-content><h2 id=problem-description>Problem Description</h2><p>Given a string <code>s</code> containing only digits, return all possible valid IP addresses that can be formed by inserting three dots into <code>s</code>.</p><p>A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros (e.g., &ldquo;01&rdquo; is invalid, but &ldquo;0&rdquo; is valid).</p><p>For example, given <code>s = "25525511135"</code>, the valid IP addresses are <code>["255.255.11.135"]</code>.</p><h2 id=solution-approach>Solution Approach</h2><p>This problem can be solved using a backtracking approach. We need to split the string into four valid parts. A &ldquo;valid part&rdquo; is a number between 0 and 255, without any leading zeros unless the number is just &ldquo;0&rdquo;.</p><p>The core idea is to use a recursive helper function, say <code>backtrack(start_index, path)</code>, where <code>start_index</code> is the current position in the input string <code>s</code>, and <code>path</code> is a list of the IP address parts we have found so far.</p><p>The base cases for the recursion are:</p><ol><li>If we have found 4 parts (<code>len(path) == 4</code>) and we have consumed the entire string (<code>start_index == len(s)</code>), we have found a valid IP address. We join the parts with dots and add it to our results.</li><li>If we have found 4 parts but haven&rsquo;t consumed the string, or if we have consumed the string but have fewer than 4 parts, we have reached an invalid state, so we backtrack.</li></ol><p>In the recursive step, we try to form the next part of the IP address by taking a substring of length 1, 2, or 3 starting from <code>start_index</code>. For each potential part, we check if it&rsquo;s valid:</p><ol><li>The substring must not have leading zeros (unless it&rsquo;s just &ldquo;0&rdquo;).</li><li>The integer value of the substring must be between 0 and 255.</li></ol><p>If the part is valid, we add it to our current <code>path</code> and make a recursive call with an updated <code>start_index</code>. After the recursive call returns, we remove the part from the <code>path</code> to explore other possibilities (this is the &ldquo;backtracking&rdquo; step).</p><p>Since an IP address has a fixed structure (4 parts, with each part being at most 3 digits), the length of the input string <code>s</code> that can form a valid IP is limited (4 to 12 characters). This means the recursion depth and branching factor are small and constant, leading to a constant time complexity.</p><h2 id=complexity-analysis>Complexity Analysis</h2><ul><li><strong>Time:</strong> <code>O(1)</code>. The length of a valid IP address string is bounded between 4 and 12 characters. The backtracking algorithm has a fixed recursion depth (at most 4 levels) and a fixed branching factor (at most 3 branches for lengths 1, 2, 3). Therefore, the total number of explorations is constant, regardless of the input string length (within the valid range).</li><li><strong>Space:</strong> <code>O(1)</code>. The recursion stack depth is at most 4. The <code>path</code> list stores at most 4 parts. The space required for the <code>result</code> list is not typically counted for space complexity, but even if it were, the number of possible valid IP addresses is bounded.</li></ul><h2 id=notes--learnings>Notes & Learnings</h2><ul><li>This is a classic example of a backtracking problem where we need to find all valid combinations by partitioning a string.</li><li>Careful handling of constraints is key: checking for leading zeros, the 0-255 range, and the final length of the path and consumed string.</li><li>Pruning the search space is important for efficiency. For instance, we can stop early if the remaining characters are too many or too few to form the remaining parts of the IP address. My solution does this implicitly. For example, <code>if start_index + length > n:</code> stops us going out of bounds.</li></ul></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>