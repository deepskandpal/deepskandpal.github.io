<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#the-big-three-relational-vs-document-vs-graph>The Big Three: Relational vs. Document vs. Graph</a></li><li><a href=#relational-model-vs-document-model>Relational Model vs. Document Model</a></li><li><a href=#graph-like-data-models>Graph-Like Data Models</a></li><li><a href=#key-takeaways-for-system-design-interviews>Key Takeaways for System Design Interviews</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 2: Data Models and Query Languages</h1><span class=reading-time><em>6 min read</em></span><div class=book-details><div class=book-content><p>Excellent. Let&rsquo;s move on.</p><p>We&rsquo;ve established the &ldquo;what&rdquo; – we need reliable, scalable, and maintainable systems. Now we get to the first big &ldquo;how&rdquo;: <strong>how do we represent the data?</strong> This is Chapter 2: <strong>Data Models and Query Languages</strong>.</p><p>This is probably the most important decision you&rsquo;ll make. It profoundly affects not only how you write the software, but how you even <em>think</em> about the problem you&rsquo;re solving. Get this wrong, and you&rsquo;ll be fighting your database for years.</p><p><strong>What are we ultimately trying to achieve here?</strong> We&rsquo;re trying to choose a structure for our data that fits the access patterns of our application. We want to make common operations easy and fast, without making uncommon (but necessary) operations impossible.</p><p>Think of it like building with LEGOs. You have different types of bricks. If you&rsquo;re building a car, you&rsquo;ll want wheels and axles. If you&rsquo;re building a house, you&rsquo;ll want rectangular bricks and roof pieces. Using the wrong bricks makes the job awkward and the result fragile. Data models are your different types of LEGO bricks.</p><h3 id=the-big-three-relational-vs-document-vs-graph>The Big Three: Relational vs. Document vs. Graph</h3><p>For the last 30 years, one model dominated: the <strong>Relational Model</strong> (SQL). Data is in tables (relations), made of rows (tuples). It&rsquo;s fantastic for structured data and was a huge leap forward because it hid the messy implementation details from developers.</p><p>But in the last 15 years, two other models have become major players, driven by the needs of big web companies.</p><ol><li><strong>Document Model (NoSQL):</strong> Data is stored in self-contained &ldquo;documents,&rdquo; usually JSON.</li><li><strong>Graph Model:</strong> Data is represented as vertices (nodes) and edges (relationships).</li></ol><p>Let&rsquo;s compare them.</p><hr><h3 id=relational-model-vs-document-model>Relational Model vs. Document Model</h3><p>This is the most common battleground. Imagine we&rsquo;re building a LinkedIn-style resume.</p><p><strong>In a Relational (SQL) model</strong>, you&rsquo;d normalize the data. You&rsquo;d have a <code>users</code> table, a <code>positions</code> table, an <code>education</code> table, etc. The <code>positions</code> table would have a <code>user_id</code> foreign key pointing back to the <code>users</code> table.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>erDiagram
    users {
        int user_id PK
        varchar first_name
        varchar last_name
    }
    positions {
        int position_id PK
        int user_id FK
        varchar job_title
        varchar organization
    }
    education {
        int education_id PK
        int user_id FK
        varchar school_name
    }
    users ||--o{ positions : &#34;has&#34;
    users ||--o{ education : &#34;has&#34;
</code></pre><ul><li><strong>To get a full resume:</strong> You need to perform multiple queries or a complex <code>JOIN</code> across several tables.</li><li><strong>Relationships:</strong> Handles many-to-one and many-to-many relationships beautifully (<code>user_id</code> is a many-to-one link).</li></ul><p><strong>In a Document model</strong>, you&rsquo;d likely store the entire resume as a single JSON document. This is similar to the hierarchical model of IBM&rsquo;s IMS database from the 1960s – history repeats itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;user_id&#34;</span>: <span style=color:#ae81ff>251</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;first_name&#34;</span>: <span style=color:#e6db74>&#34;Bill&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;last_name&#34;</span>: <span style=color:#e6db74>&#34;Gates&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;positions&#34;</span>: [
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;job_title&#34;</span>: <span style=color:#e6db74>&#34;Co-chair&#34;</span>, <span style=color:#f92672>&#34;organization&#34;</span>: <span style=color:#e6db74>&#34;Gates Foundation&#34;</span>},
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;job_title&#34;</span>: <span style=color:#e6db74>&#34;Co-founder&#34;</span>, <span style=color:#f92672>&#34;organization&#34;</span>: <span style=color:#e6db74>&#34;Microsoft&#34;</span>}
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;education&#34;</span>: [
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;school_name&#34;</span>: <span style=color:#e6db74>&#34;Harvard University&#34;</span>},
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;school_name&#34;</span>: <span style=color:#e6db74>&#34;Lakeside School&#34;</span>}
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>To get a full resume:</strong> You fetch one document. That&rsquo;s it. This is a huge win for <strong>locality</strong>.</li><li><strong>The &ldquo;Impedance Mismatch&rdquo;:</strong> This JSON structure maps very cleanly to the objects in your application code. You don&rsquo;t need an awkward translation layer (like an ORM) that SQL databases often require.</li></ul><p><strong>So, which is better? The classic &ldquo;it depends.&rdquo;</strong></p><ul><li>If your data has a <strong>document-like structure</strong> (a central object with nested one-to-many relationships, like a resume or a blog post with comments), the document model is a natural fit. Fetching the whole thing at once is efficient.</li><li>If your data is <strong>highly interconnected</strong>, with complex many-to-many relationships, the relational model is superior. Joins are its superpower.</li></ul><p><strong>Case Study: Interconnected Data</strong>
What if we want to make &ldquo;Microsoft&rdquo; and &ldquo;Harvard University&rdquo; in our resume clickable entities with their own pages, logos, etc.? Now we have a many-to-many relationship. Many people worked at Microsoft; many people went to Harvard.</p><p>In the document model, this gets awkward.</p><ul><li>You could store the organization&rsquo;s name as a string, but then if &ldquo;Microsoft&rdquo; rebrands, you have to update millions of resume documents (denormalization).</li><li>Or, you can store just an <code>organization_id</code> and then emulate a join in your application code: <code>fetch resume -> for each position, fetch organization details</code>. This is slow and shifts complexity from the database to your code.</li></ul><p><strong>The trend (Post-2024 Era):</strong> The lines are blurring.</p><ul><li><strong>Timeless:</strong> Pick the model that fits your primary access patterns.</li><li><strong>Post-2024:</strong> Relational databases like PostgreSQL have excellent JSON support. Document databases like MongoDB are adding better join-like capabilities. This is a good thing. It&rsquo;s not &ldquo;SQL vs NoSQL&rdquo; anymore, it&rsquo;s about using the right tool for the job, and increasingly, databases are becoming multi-model.</li></ul><hr><h3 id=graph-like-data-models>Graph-Like Data Models</h3><p>What if <em>everything</em> is potentially related to <em>everything else</em>?</p><ul><li>Social networks (who is friends with whom)</li><li>Web graphs (which pages link to which)</li><li>Knowledge graphs (connecting entities like people, organizations, products)</li></ul><p>This is where graph models shine. The model is simple:</p><ul><li><strong>Vertices</strong> (or nodes): The entities (e.g., people, companies).</li><li><strong>Edges</strong> (or relationships): The connections between them (e.g., <code>(Lucy)-[:MARRIED_TO]->(Alain)</code>, <code>(Alain)-[:WORKS_AT]->(BigTech)</code>).</li></ul><p>You <em>can</em> model this in SQL, but it&rsquo;s painful. A query like &ldquo;Find all of my friends&rsquo; friends who live in London&rdquo; requires a variable number of joins, which SQL handles awkwardly with recursive common table expressions (CTEs).</p><p><strong>Declarative Graph Query Languages</strong> like <strong>Cypher</strong> (Neo4j) or <strong>SPARQL</strong> (RDF triple stores) are designed for this. A query looks like you&rsquo;re drawing the pattern you want to find.</p><p><strong>Cypher example:</strong> Find people who emigrated from the US to Europe.</p><pre tabindex=0><code class=language-cypher data-lang=cypher>MATCH
  (person:Person)-[:BORN_IN]-&gt;(:Location)-[:WITHIN*]-&gt;(us:Location {name:&#39;United States&#39;}),
  (person)-[:LIVES_IN]-&gt;(:Location)-[:WITHIN*]-&gt;(eu:Location {name:&#39;Europe&#39;})
RETURN person.name
</code></pre><p>The query optimizer figures out the most efficient way to traverse the graph to find this pattern. This is a powerful, declarative way to handle highly connected data.</p><hr><h3 id=key-takeaways-for-system-design-interviews>Key Takeaways for System Design Interviews</h3><p>When designing a system, your choice of data model is a primary decision. Justify it based on the data&rsquo;s structure and your application&rsquo;s access patterns.</p><ol><li><p><strong>Identify the main entities and their relationships.</strong></p><ul><li>Is it structured, like user profiles? <strong>Relational</strong> is a good default.</li><li>Is it self-contained documents with nested data? <strong>Document</strong> model might be simpler and faster.</li><li>Is it a web of complex relationships? Think <strong>Graph</strong>.</li></ul></li><li><p><strong>Analyze the access patterns.</strong></p><ul><li>Do you need powerful joins? <strong>Relational/SQL</strong>.</li><li>Do you primarily fetch an entire object by its ID? <strong>Document</strong>.</li><li>Do you need to traverse relationships (e.g., find friends of friends)? <strong>Graph</strong>.</li></ul></li><li><p><strong>Consider evolvability.</strong></p><ul><li>How will the data change? Schemas are not a bad thing; they enforce structure. <em>Schema-on-read</em> (Document DBs) gives flexibility but can lead to a mess if you&rsquo;re not careful. <em>Schema-on-write</em> (SQL) is more rigid but provides guarantees. Modern binary formats like Avro and Protobuf offer a middle ground.</li></ul></li></ol><p>Don&rsquo;t just say &ldquo;I&rsquo;ll use MongoDB.&rdquo; Say, &ldquo;The primary data entity is a user profile, which includes their list of recent posts. Since this is a self-contained, document-like structure and our main read pattern is fetching the full profile, a document model is a natural fit. It offers good locality and avoids complex joins for this common operation.&rdquo;</p><p>Now, we&rsquo;ve talked about how to model the data. Next, we need to talk about how a database actually stores and retrieves it. That&rsquo;s Chapter 3. Any questions on data models?</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>