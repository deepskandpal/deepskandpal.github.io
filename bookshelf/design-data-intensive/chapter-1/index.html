<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#1-reliability-it-works-even-when-things-go-wrong>1. Reliability: It Works, Even When Things Go Wrong</a></li><li><a href=#2-scalability-having-a-plan-for-growth>2. Scalability: Having a Plan for Growth</a></li><li><a href=#3-maintainability-avoiding-a-future-mess>3. Maintainability: Avoiding a Future Mess</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 1: Reliable, Scalable, and Maintainable Applications</h1><span class=reading-time><em>6 min read</em></span><div class=book-details><div class=book-content><p>This isn&rsquo;t fluff. These three words—<strong>Reliability, Scalability, and Maintainability</strong>—are the pillars of any serious system. In a system design interview, these are the top-level concerns you must address. Everything else is an implementation detail that serves these goals.</p><p>What are we ultimately trying to achieve here? We&rsquo;re trying to build systems that work, can grow, and don&rsquo;t become a nightmare to manage. Let&rsquo;s break that down.</p><hr><h3 id=1-reliability-it-works-even-when-things-go-wrong>1. Reliability: It Works, Even When Things Go Wrong</h3><p>Reliability means the system continues to work correctly, performing its function at the desired level of performance, even in the face of adversity.</p><p>The key idea is <strong>Faults vs. Failures</strong>.</p><ul><li>A <strong>fault</strong> is when one component of the system deviates from its spec (e.g., a server crashes, a network link is slow).</li><li>A <strong>failure</strong> is when the system as a whole stops providing the required service to the user.</li></ul><p>You cannot build a system with zero faults. It&rsquo;s impossible. Your job is to design a <strong>fault-tolerant</strong> system that prevents faults from causing failures.</p><p><strong>Types of Faults:</strong></p><ul><li><p><strong>Hardware Faults:</strong> Disks crash, RAM goes bad, someone unplugs the wrong cable.</p><ul><li><strong>Timeless:</strong> Redundancy. RAID for disks, dual power supplies.</li><li><strong>Post-2024 Era:</strong> We now live in the cloud. We don&rsquo;t just plan for a disk to fail; we plan for the entire virtual machine to disappear without warning. We build resilience at the software layer, not just the hardware layer. This is a fundamental shift from the old on-premise world. Think of Netflix&rsquo;s famous <strong>Chaos Monkey</strong>—it deliberately introduces faults to ensure the system is resilient. That&rsquo;s the mindset.</li></ul></li><li><p><strong>Software Errors:</strong> Bugs that cause a system-wide issue. A bad input crashes every server instance. These are often harder to deal with than random hardware faults.</p></li><li><p><strong>Human Errors:</strong> Operators make mistakes. Configuration errors are a leading cause of outages.</p></li></ul><p><strong>In a system design interview, when you say &ldquo;reliability,&rdquo; you should be thinking about specific fault scenarios and your plan to mitigate them.</strong> How do you handle a node going down? A network partition between data centers?</p><hr><h3 id=2-scalability-having-a-plan-for-growth>2. Scalability: Having a Plan for Growth</h3><p>Scalability isn&rsquo;t a magic label you slap on a system. Saying &ldquo;my system is scalable&rdquo; is meaningless. Scalability is about answering the question: <em>&ldquo;As the system grows in a particular way, what&rsquo;s our plan for coping with that growth?&rdquo;</em></p><p>First, you have to <strong>Describe Load</strong>. You can&rsquo;t talk about scaling if you don&rsquo;t know what you&rsquo;re scaling for. Use specific <strong>load parameters</strong>.</p><ul><li>Requests per second?</li><li>Read-to-write ratio?</li><li>Simultaneously active users?</li><li>Cache hit rate?</li></ul><p><strong>Case Study: Twitter Timeline (DDIA Figure 1-2, 1-3)</strong>
This is a classic. The problem isn&rsquo;t just &ldquo;lots of tweets.&rdquo; It&rsquo;s the <strong>fan-out</strong>. A celebrity with 30 million followers tweets once. How do you deliver that tweet to all 30 million timelines?</p><p>There are two naive approaches:</p><ol><li><strong>Read-time Fan-out (Pull):</strong> A user requests their timeline. The system looks up everyone they follow, gets the recent tweets for each, and merges them.</li><li><strong>Write-time Fan-out (Push):</strong> A user posts a tweet. The system looks up everyone who follows them and inserts the new tweet into each of their timeline &ldquo;inboxes&rdquo; (caches).</li></ol><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD
    subgraph &#34;Approach 1: Read-time Fan-out (Slow Reads)&#34;
        User[User Requests Timeline] --&gt; A{Find all followed users}
        A --&gt; B[For each followed user...]
        B --&gt; C[Fetch their recent tweets]
        C --&gt; D{Merge all tweets}
        D --&gt; Result[Show Timeline]
    end
    subgraph &#34;Approach 2: Write-time Fan-out (Slow Writes)&#34;
        Tweet[User Posts Tweet] --&gt; E{Find all followers}
        E --&gt; F[For each follower...]
        F --&gt; G[Insert tweet into their timeline cache]
        G --&gt; H[Done]
    end
</code></pre><p>Twitter started with Approach 1, but timeline reads were too slow. They switched to Approach 2. This is a perfect example of a scalability trade-off: they made writes more expensive to make reads cheaper. The real system is a hybrid: most users are &ldquo;push,&rdquo; but for celebrities, it&rsquo;s &ldquo;pull&rdquo; to avoid a single tweet overwhelming the system.</p><p><strong>Next, you Describe Performance.</strong></p><p>Don&rsquo;t talk about &ldquo;average response time.&rdquo; It&rsquo;s a mostly useless metric. <strong>Talk about percentiles.</strong></p><ul><li><strong>Median (p50):</strong> Half your users get this response time or faster. The other half are getting a worse experience.</li><li><strong>95th, 99th, 99.9th percentiles (p95, p99, p999):</strong> These are your <strong>tail latencies</strong>. They represent the experience of your unluckiest users.</li></ul><p>Why do tail latencies matter? Amazon found that the customers with the slowest requests were often their most valuable—the ones with long purchase histories. Making the p999 fast makes your best customers happy.</p><p>In modern systems (microservices, ML inference pipelines), you get <strong>tail latency amplification</strong>.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR
    UserRequest --&gt; API_Gateway
    subgraph Backend Services
        API_Gateway --&gt; ServiceA
        API_Gateway --&gt; ServiceB
        API_Gateway --&gt; ServiceC
        API_Gateway --&gt; ServiceD
    end
    ServiceA --&gt; API_Gateway
    ServiceB --&gt; API_Gateway
    ServiceC --&gt; API_Gateway
    ServiceD --&gt; API_Gateway
    API_Gateway --&gt; UserResponse

    style ServiceC fill:#f9f,stroke:#333,stroke-width:2px
</code></pre><p>If a user request requires calling 5 backend services in parallel, and each service has a 1% chance of being slow (p99), the chance that the user sees a slow response is much higher than 1%. It only takes <em>one</em> slow service to delay the entire request. This is why focusing on p99 and p999 is critical.</p><hr><h3 id=3-maintainability-avoiding-a-future-mess>3. Maintainability: Avoiding a Future Mess</h3><p>This is the most overlooked aspect by junior engineers, but it&rsquo;s where most of the cost of software lies. The goal is to design a system that future engineers (including you in 6 months) can work on productively.</p><p>It boils down to three principles:</p><ol><li><strong>Operability:</strong> Make it easy for operations teams to keep the system running smoothly. This means good monitoring, good automation, standard tools, and predictable behavior. No magic.</li><li><strong>Simplicity:</strong> Manage complexity. This isn&rsquo;t about dumbing things down. It&rsquo;s about finding the right <strong>abstractions</strong> that hide a great deal of implementation detail behind a clean interface. A well-designed database is a great abstraction.</li><li><strong>Evolvability (or Plasticity):</strong> Make it easy to change the system in the future. Business needs change. You&rsquo;ll need to add features. How easy is it to &ldquo;refactor&rdquo; your architecture, like Twitter did with its timeline?</li></ol><hr><p><strong>Summary for System Design Interviews</strong></p><p>When you get a design question, these three concepts are your high-level checklist. For any component you propose, ask:</p><ul><li><strong>Reliability:</strong> What are its failure modes? How will we make it fault-tolerant?</li><li><strong>Scalability:</strong> What are the load parameters? Where are the bottlenecks? What is our strategy for handling 10x or 100x the load? How will we measure performance?</li><li><strong>Maintainability:</strong> Is this design easy to understand? Can a new engineer get up to speed quickly? How will we evolve it when requirements change?</li></ul><p>This chapter gives us the vocabulary and the framework. In the next chapter, we&rsquo;ll dive into the first major design choice that impacts all three of these: the Data Model.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>