<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#key-binary-tree-concepts>Key Binary Tree Concepts:</a><ul><li><a href=#tree-traversal>Tree Traversal:</a></li></ul></li><li><a href=#section-91-test-if-a-binary-tree-is-height-balanced>Section 9.1: Test if a Binary Tree is Height-Balanced</a></li><li><a href=#section-92-test-if-a-binary-tree-is-a-binary-search-tree-bst>Section 9.2: Test if a Binary Tree is a Binary Search Tree (BST)</a></li><li><a href=#section-94-find-the-lowest-common-ancestor-lca-in-a-bst>Section 9.4: Find the Lowest Common Ancestor (LCA) in a BST</a></li><li><a href=#section-97-implement-an-in-order-traversal-without-recursion>Section 9.7: Implement an In-order Traversal without Recursion</a></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 9: Binary Trees</h1><span class=reading-time><em>6 min read</em></span><div class=book-details><div class=book-content><h1 id=chapter-9-overview-binary-trees>Chapter 9 Overview: Binary Trees</h1><p>Binary trees are fundamental hierarchical data structures. Each node has at most two children, referred to as the left child and the right child. They are essential for representing data with a branching structure, such as file systems, expression evaluation, and search trees.</p><h2 id=key-binary-tree-concepts>Key Binary Tree Concepts:</h2><ul><li><strong>Node</strong>: The basic unit of a tree, containing data and pointers to its children.</li><li><strong>Root</strong>: The topmost node in a tree.</li><li><strong>Leaf</strong>: A node with no children.</li><li><strong>Depth</strong>: The length of the path from the root to a node. The root&rsquo;s depth is 0.</li><li><strong>Height</strong>: The length of the longest path from a node to a leaf. The height of a leaf is 0. The height of a tree is the height of its root.</li><li><strong>Full Binary Tree</strong>: A tree where every node has either 0 or 2 children.</li><li><strong>Complete Binary Tree</strong>: A tree where all levels are completely filled except possibly the last, and the last level has all keys as left as possible.</li><li><strong>Perfect Binary Tree</strong>: A tree where all interior nodes have two children and all leaves are at the same level.</li></ul><h3 id=tree-traversal>Tree Traversal:</h3><p>The three primary ways to visit all nodes in a tree are:</p><ol><li><strong>In-order Traversal</strong>: Left subtree -> Visit Root -> Right subtree. For a Binary Search Tree (BST), this yields the nodes in sorted order.</li><li><strong>Pre-order Traversal</strong>: Visit Root -> Left subtree -> Right subtree. Often used to create a copy of the tree.</li><li><strong>Post-order Traversal</strong>: Left subtree -> Right subtree -> Visit Root. Often used to delete nodes from the tree.</li></ol><hr><h2 id=section-91-test-if-a-binary-tree-is-height-balanced>Section 9.1: Test if a Binary Tree is Height-Balanced</h2><p><strong>The Problem</strong>: A binary tree is height-balanced if, for every node, the difference in height between its left and right subtrees is at most 1. Write a function to determine if a given binary tree is height-balanced.</p><p><strong>Algorithm (Recursive Post-order Traversal)</strong>:
A brute-force approach would be to compute the height of the left and right subtrees for every node, which is inefficient (O(n^2)). A better approach integrates the height calculation with the balance check.</p><ol><li><p>Create a recursive helper function, say <code>check_balance(node)</code>. This function will return two pieces of information: whether the subtree at <code>node</code> is balanced, and what its height is. A common way to do this is to return a special value (like -1) to signal imbalance.</p></li><li><p><strong><code>check_balance(node)</code> logic</strong>:</p><ul><li><strong>Base Case</strong>: If <code>node</code> is <code>None</code>, it&rsquo;s a balanced subtree of height -1 (or 0, depending on convention). Return <code>(True, -1)</code>.</li><li><strong>Recursive Step</strong>:<ul><li>Recursively call <code>check_balance</code> on the left child. Get <code>is_left_balanced</code> and <code>left_height</code>.</li><li>If <code>is_left_balanced</code> is <code>False</code>, this subtree is not balanced. Propagate the failure up: return <code>(False, 0)</code>.</li><li>Recursively call <code>check_balance</code> on the right child. Get <code>is_right_balanced</code> and <code>right_height</code>.</li><li>If <code>is_right_balanced</code> is <code>False</code>, propagate the failure up: return <code>(False, 0)</code>.</li></ul></li><li><strong>Check Current Node</strong>:<ul><li>Check if the current node is balanced: <code>abs(left_height - right_height) &lt;= 1</code>.</li><li>If it is, the height of the current node&rsquo;s subtree is <code>1 + max(left_height, right_height)</code>. Return <code>(True, height)</code>.</li><li>If it&rsquo;s not, return <code>(False, 0)</code>.</li></ul></li></ul></li></ol><p><strong>Complexity</strong>:</p><ul><li><strong>Time</strong>: O(n), as each node is visited once.</li><li><strong>Space</strong>: O(h), where h is the height of the tree, for the recursion stack. O(log n) for a balanced tree, O(n) for a skewed tree.</li></ul><hr><h2 id=section-92-test-if-a-binary-tree-is-a-binary-search-tree-bst>Section 9.2: Test if a Binary Tree is a Binary Search Tree (BST)</h2><p><strong>The Problem</strong>: Write a function to check if a given binary tree is a valid Binary Search Tree (BST).</p><p><strong>BST Property</strong>: For any given node <code>N</code>:</p><ol><li>All values in <code>N</code>&rsquo;s left subtree must be less than <code>N</code>&rsquo;s value.</li><li>All values in <code>N</code>&rsquo;s right subtree must be greater than <code>N</code>&rsquo;s value.</li><li>Both the left and right subtrees must also be binary search trees.</li></ol><p><strong>Pitfall</strong>: A common mistake is to only check if <code>node.left.data &lt; node.data</code> and <code>node.right.data > node.data</code>. This is not sufficient. The property must hold for <em>all</em> nodes in the subtree, not just the immediate children.</p><p><strong>Algorithm (Recursive with Min/Max Range)</strong>:
The most robust method is to perform a recursive traversal, passing down the valid range of values (<code>min_val</code>, <code>max_val</code>) that a node&rsquo;s value is allowed to have.</p><ol><li><p>Create a recursive helper function <code>is_bst_helper(node, min_val, max_val)</code>.</p></li><li><p><strong><code>is_bst_helper</code> logic</strong>:</p><ul><li><strong>Base Case</strong>: If <code>node</code> is <code>None</code>, it&rsquo;s a valid BST. Return <code>True</code>.</li><li><strong>Check Current Node</strong>:<ul><li>If <code>node.data &lt;= min_val</code> or <code>node.data >= max_val</code>, the BST property is violated. Return <code>False</code>.</li></ul></li><li><strong>Recursive Step</strong>:<ul><li>Recursively check the left subtree. The new <code>max_val</code> for the left subtree is the current node&rsquo;s value: <code>is_bst_helper(node.left, min_val, node.data)</code>.</li><li>Recursively check the right subtree. The new <code>min_val</code> for the right subtree is the current node&rsquo;s value: <code>is_bst_helper(node.right, node.data, max_val)</code>.</li><li>The tree is a BST if both recursive calls return <code>True</code>.</li></ul></li></ul></li><li><p>Initial call: <code>is_bst_helper(root, -infinity, +infinity)</code>.</p></li></ol><hr><h2 id=section-94-find-the-lowest-common-ancestor-lca-in-a-bst>Section 9.4: Find the Lowest Common Ancestor (LCA) in a BST</h2><p><strong>The Problem</strong>: Given a BST and two nodes <code>s</code> and <code>b</code> (smaller and bigger value), find their Lowest Common Ancestor (LCA). The LCA is the deepest node in the tree that has both <code>s</code> and <code>b</code> as descendants.</p><p><strong>Algorithm (Exploiting BST Properties)</strong>:
The search for the LCA in a BST is much simpler than in a generic binary tree. We can use the BST property to guide our search from the root.</p><ol><li>Start with <code>current = root</code>.</li><li>Loop as long as <code>current</code> is not <code>None</code>:<ul><li>If <code>current.data</code> is <strong>greater than</strong> both <code>s.data</code> and <code>b.data</code>, it means both nodes are in the left subtree. The LCA must also be in the left subtree. So, move left: <code>current = current.left</code>.</li><li>If <code>current.data</code> is <strong>less than</strong> both <code>s.data</code> and <code>b.data</code>, it means both nodes are in the right subtree. The LCA must also be in the right subtree. So, move right: <code>current = current.right</code>.</li><li>Otherwise, <code>current.data</code> is between <code>s.data</code> and <code>b.data</code> (or equal to one of them). This means the path to <code>s</code> and <code>b</code> diverges at <code>current</code>. Therefore, <code>current</code> is the LCA. Return <code>current</code>.</li></ul></li></ol><p><strong>Complexity</strong>:</p><ul><li><strong>Time</strong>: O(h), where h is the height of the tree. In the worst case (a skewed tree), this is O(n). For a balanced tree, it&rsquo;s O(log n).</li><li><strong>Space</strong>: O(1) for the iterative approach.</li></ul><hr><h2 id=section-97-implement-an-in-order-traversal-without-recursion>Section 9.7: Implement an In-order Traversal without Recursion</h2><p><strong>The Problem</strong>: Perform an in-order traversal of a binary tree without using recursion, which implicitly uses the call stack. You must use an explicit stack data structure.</p><p><strong>Algorithm (Iterative with a Stack)</strong>:
This approach mimics what the recursion call stack does.</p><ol><li>Initialize an empty <code>stack</code> and set <code>current = root</code>.</li><li>Loop as long as <code>current</code> is not <code>None</code> or the <code>stack</code> is not empty.<ul><li><strong>Go Left</strong>: If <code>current</code> is not <code>None</code>:<ul><li>Push <code>current</code> onto the <code>stack</code>.</li><li>Move to the left child: <code>current = current.left</code>.</li></ul></li><li><strong>Visit and Go Right</strong>: If <code>current</code> is <code>None</code> (meaning we&rsquo;ve gone as far left as possible):<ul><li>Pop a node from the <code>stack</code>. This is the node we need to &ldquo;visit&rdquo;. Process its data (e.g., add to a result list).</li><li>Now, move to the right subtree of the popped node: <code>current = popped_node.right</code>.</li></ul></li></ul></li><li>The loop terminates when both the stack is empty and the current node is <code>None</code>.</li></ol></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>