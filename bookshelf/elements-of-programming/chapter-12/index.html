<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#chapter-12-overview-hash-tables>Chapter 12 Overview: Hash Tables</a><ul><li><a href=#key-hash-table-concepts>Key Hash Table Concepts:</a></li><li><a href=#section-121-test-for-palindromic-permutations>Section 12.1: Test for Palindromic Permutations</a></li><li><a href=#section-122-is-an-anonymous-letter-constructible>Section 12.2: Is an Anonymous Letter Constructible?</a></li><li><a href=#section-124-implement-an-lru-cache>Section 12.4: Implement an LRU Cache</a></li><li><a href=#section-128-find-the-smallest-subarray-covering-a-set-of-keywords>Section 12.8: Find the Smallest Subarray Covering a Set of Keywords</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 12: Hash Tables</h1><span class=reading-time><em>8 min read</em></span><div class=book-details><div class=book-content><h1 id=chapter-12-overview-hash-tables>Chapter 12 Overview: Hash Tables</h1><p>Hash tables (or hash maps) are one of the most useful and versatile data structures in computer science. They provide a mechanism to store key-value pairs and allow for extremely fast average-case lookups, insertions, and deletions. In Python, the <code>dict</code> and <code>set</code> types are implemented using hash tables.</p><h2 id=key-hash-table-concepts>Key Hash Table Concepts:</h2><ul><li><strong>Hash Function</strong>: A function that maps a key to an integer, which is then used as an index (or &ldquo;hash code&rdquo;) in an underlying array (often called buckets or slots). A good hash function should distribute keys uniformly across the array to minimize collisions.</li><li><strong>Key Properties</strong>: Keys must be &ldquo;hashable,&rdquo; which generally means they must be immutable. An object is hashable if it has a hash value that never changes during its lifetime.</li><li><strong>Buckets/Slots</strong>: The underlying array that stores the data. The hash code determines which bucket a key-value pair belongs to.</li><li><strong>Collision</strong>: When two different keys map to the same bucket index. This is inevitable unless the hash table is very large and the hash function is perfect.</li><li><strong>Collision Resolution</strong>: The strategy for handling collisions.<ol><li><strong>Separate Chaining (or Chaining)</strong>: Each bucket is a pointer to a linked list (or another data structure) that holds all the key-value pairs that hashed to that index. This is a very common method.</li><li><strong>Open Addressing</strong>: If a collision occurs, the algorithm probes for the next empty slot in the array according to a fixed sequence. Examples include Linear Probing (checking the next slot, then the next, etc.), Quadratic Probing, and Double Hashing.</li></ol></li></ul><p><strong>Performance</strong>:</p><ul><li><strong>Average Case</strong>: O(1) for lookups, insertions, and deletions.</li><li><strong>Worst Case</strong>: O(n) for lookups, insertions, and deletions. This happens when all keys hash to the same bucket, effectively turning the hash table into a single linked list.</li></ul><hr><h2 id=section-121-test-for-palindromic-permutations>Section 12.1: Test for Palindromic Permutations</h2><p><strong>The Problem</strong>: Given a string, determine if any permutation of its characters can form a palindrome.</p><p><strong>Example</strong>:</p><ul><li>&ldquo;edified&rdquo; -> <code>True</code> (a permutation is &ldquo;deified&rdquo;)</li><li>&ldquo;level&rdquo; -> <code>True</code> (it&rsquo;s already a palindrome)</li><li>&ldquo;aabbc&rdquo; -> <code>True</code> (a permutation is &ldquo;abcba&rdquo;)</li><li>&ldquo;abc&rdquo; -> <code>False</code></li></ul><p><strong>Key Insight</strong>:
A string can be permuted into a palindrome if and only if <strong>at most one</strong> of its characters appears an odd number of times. All other characters must appear an even number of times.</p><ul><li>If the string length is even, all character counts must be even.</li><li>If the string length is odd, exactly one character count must be odd (the one that will be the center of the palindrome).</li></ul><p><strong>Algorithm (Using a Hash Table/Set)</strong>:</p><ol><li>Initialize a hash table (or hash set) to track the counts of characters that have appeared an odd number of times so far. Let&rsquo;s call it <code>odd_chars</code>.</li><li>Iterate through each character <code>c</code> in the input string:<ul><li>If <code>c</code> is already in <code>odd_chars</code>, it means we&rsquo;ve now seen this character an even number of times. Remove it from <code>odd_chars</code>.</li><li>If <code>c</code> is not in <code>odd_chars</code>, it means we&rsquo;ve now seen it an odd number of times. Add it to <code>odd_chars</code>.</li></ul></li><li>After iterating through the whole string, check the size of <code>odd_chars</code>.<ul><li>If <code>len(odd_chars) &lt;= 1</code>, then a palindromic permutation is possible. Return <code>True</code>.</li><li>Otherwise, return <code>False</code>.</li></ul></li></ol><p><strong>Complexity</strong>:</p><ul><li><strong>Time</strong>: O(n), where n is the number of characters in the string, because we iterate through it once.</li><li><strong>Space</strong>: O(c), where c is the number of unique characters in the character set (e.g., 26 for lowercase English letters, 128 for ASCII). This is effectively O(1) if the character set is fixed and finite.</li></ul><hr><h2 id=section-122-is-an-anonymous-letter-constructible>Section 12.2: Is an Anonymous Letter Constructible?</h2><p><strong>The Problem</strong>: You are given two strings, the <code>letter_text</code> and the <code>magazine_text</code>. Write a function to determine if the letter can be written using characters from the magazine. Each character in the magazine can only be used once.</p><p><strong>Algorithm (Using a Hash Table for Character Counts)</strong>:</p><ol><li>Create a hash table (e.g., a <code>collections.Counter</code> in Python or a simple <code>dict</code>) to store the counts of all characters available in the <code>magazine_text</code>.</li><li>Iterate through <code>magazine_text</code> and populate the hash table.</li><li>Iterate through each character <code>c</code> in the <code>letter_text</code>:<ul><li>Check if <code>c</code> is in the hash table and if its count is greater than 0.</li><li>If <code>c</code> is not in the table or its count is 0, it means we don&rsquo;t have this character available in the magazine. Return <code>False</code>.</li><li>If the character is available, decrement its count in the hash table to &ldquo;use it up&rdquo;.</li></ul></li><li>If the loop completes, it means all characters required for the letter were found in the magazine. Return <code>True</code>.</li></ol><p><strong>Complexity</strong>:</p><ul><li><strong>Time</strong>: O(m + n), where m is the length of the magazine text and n is the length of the letter text.</li><li><strong>Space</strong>: O(c), where c is the number of unique characters in the magazine&rsquo;s character set.</li></ul><hr><h2 id=section-124-implement-an-lru-cache>Section 12.4: Implement an LRU Cache</h2><p><strong>The Problem</strong>: Design and implement a Least Recently Used (LRU) cache. It should support two operations: <code>insert</code> and <code>lookup</code>. The cache has a fixed <code>capacity</code>. When a new item is inserted and the cache is full, the least recently used item must be evicted.</p><p><strong>Key Requirements</strong>:</p><ul><li><code>lookup(key)</code>: If the key exists, return its value and mark it as recently used.</li><li><code>insert(key, value)</code>: Insert or update the key-value pair. Mark it as recently used. If insertion causes the cache to exceed capacity, evict the LRU item.</li><li>Both operations should be as fast as possible, ideally O(1).</li></ul><p><strong>Algorithm (Hash Table + Doubly Linked List)</strong>:
This is the classic solution that combines the strengths of two data structures to achieve O(1) performance.</p><ol><li><strong>Hash Table (<code>dict</code> in Python)</strong>: Stores <code>key -> Node</code> mappings. This provides O(1) average time complexity for lookups. The <code>Node</code> it points to is a node in our doubly linked list.</li><li><strong>Doubly Linked List</strong>: Stores the items in order of use. The most recently used item is at the head (or tail), and the least recently used item is at the other end.<ul><li>A doubly linked list is crucial because it allows for O(1) removal of any node <em>if we have a direct pointer to it</em>. The hash table gives us this pointer.</li></ul></li></ol><p><strong>Operations</strong>:</p><ul><li><strong><code>lookup(key)</code></strong>:<ol><li>Check if <code>key</code> is in the hash table. If not, return <code>None</code> (cache miss).</li><li>If it exists, get the <code>Node</code> from the hash table.</li><li>Move this <code>Node</code> to the head of the linked list to mark it as most recently used.</li><li>Return the <code>Node</code>&rsquo;s value.</li></ol></li><li><strong><code>insert(key, value)</code></strong>:<ol><li>Check if <code>key</code> is already in the hash table.<ul><li>If yes, update the value in its corresponding <code>Node</code> and move that <code>Node</code> to the head of the list.</li></ul></li><li>If <code>key</code> is not in the hash table (a new insertion):<ul><li>If the cache is full (<code>len(hash_table) == capacity</code>):<ul><li>Get the <code>lru_node</code> from the tail of the linked list.</li><li>Remove <code>lru_node.key</code> from the hash table.</li><li>Remove the <code>lru_node</code> from the linked list.</li></ul></li><li>Create a new <code>Node</code> with the given <code>key</code> and <code>value</code>.</li><li>Add the new <code>Node</code> to the head of the linked list.</li><li>Add the <code>key -> new_Node</code> mapping to the hash table.</li></ul></li></ol></li></ul><hr><h2 id=section-128-find-the-smallest-subarray-covering-a-set-of-keywords>Section 12.8: Find the Smallest Subarray Covering a Set of Keywords</h2><p><strong>The Problem</strong>: Given a long text (an array of words) and a set of keywords, find the smallest subarray of the text that contains all the keywords.</p><p><strong>Example</strong>:</p><ul><li>Text: <code>["apple", "banana", "apple", "apple", "dog", "cat", "apple", "dog", "banana", "apple", "cat", "dog"]</code></li><li>Keywords: <code>{"banana", "cat"}</code></li><li>Result: <code>["cat", "apple", "dog", "banana"]</code> (length 4, from index 6 to 9)</li></ul><p><strong>Algorithm (Sliding Window with Hash Table)</strong>:
This is a classic sliding window problem. We expand a window from the right and shrink it from the left.</p><ol><li>Create a hash table <code>keyword_counts</code> to store the count of each keyword we need to find. Initialize it from the input set of keywords.</li><li>Initialize <code>left = 0</code>, <code>result = (-1, -1)</code> (to store the start/end of the best subarray), and <code>remaining_to_find = len(keywords)</code>.</li><li>Use a hash table <code>window_counts</code> to track counts of keywords within the current window <code>[left, right]</code>.</li><li>Iterate with a <code>right</code> pointer from <code>0</code> to <code>len(text) - 1</code>:<ul><li>Let <code>word = text[right]</code>.</li><li>If <code>word</code> is one of the keywords:<ul><li>Increment its count in <code>window_counts</code>.</li><li>If <code>window_counts[word]</code> is now equal to <code>keyword_counts[word]</code>, it means we have found enough of this specific keyword. Decrement <code>remaining_to_find</code>.</li></ul></li><li><strong>Shrink the window from the left</strong>: While <code>remaining_to_find == 0</code>:<ul><li>We have a valid window <code>[left, right]</code>. Check if it&rsquo;s smaller than the best <code>result</code> found so far. If so, update <code>result</code>.</li><li>Let <code>left_word = text[left]</code>.</li><li>If <code>left_word</code> is a keyword:<ul><li>Decrement its count in <code>window_counts</code>.</li><li>If its <code>window_counts</code> is now less than its <code>keyword_counts</code>, we no longer have all required keywords in the window. Increment <code>remaining_to_find</code>.</li></ul></li><li>Move the left boundary: <code>left += 1</code>.</li></ul></li></ul></li><li>Return the subarray corresponding to the final <code>result</code> indices.</li></ol></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>