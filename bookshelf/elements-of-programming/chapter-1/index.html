<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul></nav></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#chapter-5-overview>Chapter 5 Overview:</a><ul><li><a href=#think-of-arrays-like-this>Think of arrays like this:</a></li><li><a href=#why-arrays-are-important-especially-for-interviews>Why Arrays Are Important (Especially for Interviews):</a></li><li><a href=#array-boot-camp-reordering-array-entries-page-1>Array Boot Camp: Reordering Array Entries (Page 1)</a><ul><li><a href=#the-problem>The Problem:</a></li></ul></li><li><a href=#the-boot-camp-code-explained-even_odd>The Boot Camp Code Explained (even_odd):</a><ul><li><a href=#intuition-partitioning>Intuition (Partitioning):</a></li><li><a href=#complexity>Complexity:</a></li></ul></li><li><a href=#top-tips-for-arrays-page-2>Top Tips for Arrays (Page 2)</a></li><li><a href=#know-your-array-libraries-python-list-page-2-3>Know Your Array Libraries (Python <code>list</code>) (Page 2-3)</a><ul><li><a href=#instantiation>Instantiation:</a></li><li><a href=#basic-ops>Basic Ops:</a></li><li><a href=#2d-arrays>2D Arrays:</a></li><li><a href=#copying>Copying:</a></li><li><a href=#key-methods>Key Methods:</a></li><li><a href=#slicing-astartstopstep-super-powerful>Slicing (<code>A[start:stop:step]</code>): Super powerful!</a></li><li><a href=#list-comprehensions-expression-for-item-in-iterable-if-condition>List Comprehensions: <code>[expression for item in iterable if condition]</code></a></li></ul></li><li><a href=#section-51-the-dutch-national-flag-problem-pages-3-6>Section 5.1: The Dutch National Flag Problem (Pages 3-6)</a><ul><li><a href=#approach-1-two-passes-less-efficient-conceptually-simpler>Approach 1: Two Passes (Less efficient, conceptually simpler)</a></li><li><a href=#approach-2-single-pass-the-standard-efficient-solution>Approach 2: Single Pass (The Standard, Efficient Solution)</a></li></ul></li><li><a href=#section-52-increment-an-arbitrary-precision-integer-page-7--pdf-page-43>Section 5.2: Increment an Arbitrary-Precision Integer (Page 7 / PDF Page 43)</a></li><li><a href=#section-53-multiply-two-arbitrary-precision-integers-page-7-8--pdf-pages-43-44>Section 5.3: Multiply Two Arbitrary-Precision Integers (Page 7-8 / PDF Pages 43-44)</a><ul><li><a href=#complexity-1>Complexity:</a></li></ul></li><li><a href=#section-54-advancing-through-an-array-page-8--pdf-page-44>Section 5.4: Advancing Through an Array (Page 8 / PDF Page 44)</a><ul><li><a href=#intuition-walkthrough-example-1-a--3-3-1-0-2-0-1>Intuition Walkthrough (Example 1: <code>A = [3, 3, 1, 0, 2, 0, 1]</code>)</a></li><li><a href=#intuition-walkthrough-example-2-a--3-2-0-0-2-0-1>Intuition Walkthrough (Example 2: <code>A = [3, 2, 0, 0, 2, 0, 1]</code>)</a></li><li><a href=#analogy-hopping-stones-across-a-river>Analogy: Hopping Stones Across a River</a></li><li><a href=#the-max_reach-idea-tracking-your-potential>The <code>max_reach</code> Idea: Tracking Your Potential</a></li><li><a href=#complexity-2>Complexity:</a></li><li><a href=#variant-minimum-steps>Variant: Minimum Steps</a></li></ul></li><li><a href=#section-55-delete-duplicates-from-a-sorted-array-page-9--pdf-page-45>Section 5.5: Delete Duplicates from a Sorted Array (Page 9 / PDF Page 45)</a></li><li><a href=#section-56-buy-and-sell-a-stock-once-page-10--pdf-page-46>Section 5.6: Buy and Sell a Stock Once (Page 10 / PDF Page 46)</a><ul><li><a href=#intuition-walkthrough-prices--310-315-275-295-260-270-290-230-255-250>Intuition Walkthrough (<code>prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]</code>):</a></li><li><a href=#complexity-3>Complexity:</a></li><li><a href=#variant-longest-equal-subarray>Variant: Longest Equal Subarray</a></li><li><a href=#intuition-walkthrough-prices--310-315-275-295-260-270-290-230-255-250-1>Intuition Walkthrough (<code>prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]</code>):</a></li><li><a href=#complexity-4>Complexity:</a></li><li><a href=#variant-longest-equal-subarray-1>Variant: Longest Equal Subarray</a></li></ul></li><li><a href=#section-57-buy-and-sell-a-stock-twice-page-11--pdf-page-47>Section 5.7: Buy and Sell a Stock Twice (Page 11 / PDF Page 47)</a><ul><li><a href=#the-key-insight-decomposition>The Key Insight (Decomposition):</a></li><li><a href=#how-to-calculate-efficiently>How to Calculate Efficiently?</a></li><li><a href=#the-books-space-optimization>The Book&rsquo;s Space Optimization:</a></li><li><a href=#lets-retry-the-intuition-walkthrough-prices--12-11-13-9-12-8-14-13-15>Let&rsquo;s retry the Intuition Walkthrough (<code>prices = [12, 11, 13, 9, 12, 8, 14, 13, 15]</code>):</a></li></ul></li><li><a href=#section-58-computing-an-alternation-page-12--pdf-page-48>Section 5.8: Computing an Alternation (Page 12 / PDF Page 48)</a><ul><li><a href=#approach-1-sorting-simple-but-suboptimal>Approach 1: Sorting (Simple but Suboptimal)</a></li><li><a href=#approach-2-median-finding-mentioned-but-not-fully-explored>Approach 2: Median Finding (Mentioned, but not fully explored)</a></li><li><a href=#approach-3-the-clever-local-swap-efficient-and-simple>Approach 3: The Clever Local Swap (Efficient and Simple)</a></li><li><a href=#the-local-swap-algorithm>The Local Swap Algorithm:</a></li><li><a href=#why-doesnt-enforcing-the-rule-at-step-i-break-the-rule-we-just-fixed-at-step-i-1>Why Doesn&rsquo;t Enforcing the Rule at Step <code>i</code> Break the Rule We Just Fixed at Step <code>i-1</code>?</a></li><li><a href=#analogy-smoothing-out-bumps>Analogy: Smoothing Out Bumps</a></li></ul></li><li><a href=#section-59-enumerate-all-primes-to-n-page-13--pdf-page-49>Section 5.9: Enumerate All Primes to n (Page 13 / PDF Page 49)</a><ul><li><a href=#approach-1-trial-division-brute-force>Approach 1: Trial Division (Brute-Force)</a></li><li><a href=#approach-2-sieve-of-eratosthenes-much-more-efficient>Approach 2: Sieve of Eratosthenes (Much More Efficient)</a></li><li><a href=#the-old-way-trial-division>The Old Way (Trial Division):</a></li><li><a href=#the-sieve-idea-be-proactive>The Sieve Idea: Be Proactive!</a></li></ul></li><li><a href=#section-510-permute-the-elements-of-an-array-page-14--pdf-page-50>Section 5.10: Permute the Elements of an Array (Page 14 / PDF Page 50)</a><ul><li><a href=#approach-1-using-extra-space-simple-but-not-in-place>Approach 1: Using Extra Space (Simple but Not In-Place)</a></li><li><a href=#approach-2-in-place-permutation-using-cycles>Approach 2: In-Place Permutation using Cycles</a></li><li><a href=#the-cycle-idea-follow-one-element-all-the-way>The Cycle Idea: Follow One Element All the Way</a></li><li><a href=#putting-it-together--the-marking-trick>Putting it Together & The &ldquo;Marking&rdquo; Trick:</a></li></ul></li><li><a href=#section-511-compute-the-next-permutation-page-16--pdf-page-52>Section 5.11: Compute the Next Permutation (Page 16 / PDF Page 52)</a><ul><li><a href=#the-key-insight-minimizing-the-change>The Key Insight: Minimizing the Change</a></li></ul></li><li><a href=#sampling-algorithms-and-their-implementation>Sampling Algorithms and their implementation</a><ul><li><a href=#analogy-picking-players-for-a-team>Analogy: Picking Players for a Team</a></li><li><a href=#the-algorithm-step-by-step>The Algorithm Step-by-Step:</a></li><li><a href=#why-is-this-like-drawing-from-a-hat>Why is this like drawing from a hat?</a></li></ul></li><li><a href=#section-512-sample-offline-data-page-18--pdf-page-54>Section 5.12: Sample Offline Data (Page 18 / PDF Page 54)</a><ul><li><a href=#the-efficient-in-place-algorithm-fisher-yates-shuffle-adaptation>The Efficient In-Place Algorithm (Fisher-Yates Shuffle Adaptation):</a></li></ul></li><li><a href=#section-513-sample-online-data-page-19--pdf-page-55>Section 5.13: Sample Online Data (Page 19 / PDF Page 55)</a><ul><li><a href=#the-algorithm-reservoir-sampling>The Algorithm: Reservoir Sampling</a></li></ul></li><li><a href=#sampling-algorithms-recap>sampling Algorithms Recap</a><ul><li><a href=#recall-the-offline-sampling-fisher-yates-logic>Recall the Offline Sampling (Fisher-Yates) Logic:</a></li><li><a href=#now-the-onlinereservoir-sampling-challenge>Now, the Online/Reservoir Sampling Challenge:</a></li><li><a href=#the-connection>The Connection:</a></li></ul></li><li><a href=#section-515-compute-a-random-subset-page-21--pdf-page-57>Section 5.15: Compute a Random Subset (Page 21 / PDF Page 57)</a><ul><li><a href=#solution-approach-1-mimic-offline-sampling-fisher-yates>Solution Approach 1: Mimic Offline Sampling (Fisher-Yates)</a></li><li><a href=#solution-approach-2-using-a-hash-table-for-k--n>Solution Approach 2: Using a Hash Table (for k &#171; n)</a></li></ul></li><li><a href=#section-516-generate-nonuniform-random-numbers-page-22--pdf-page-58>Section 5.16: Generate Nonuniform Random Numbers (Page 22 / PDF Page 58)</a><ul><li><a href=#the-core-idea-mapping-the-01-interval>The Core Idea: Mapping the [0,1) Interval</a></li><li><a href=#analogy-a-dartboard-with-unequal-slices>Analogy: A Dartboard with Unequal Slices</a></li><li><a href=#connecting-to-randomrandom-which-gives-a-number-in-00-10>Connecting to <code>random.random()</code> which gives a number in <code>[0.0, 1.0)</code></a></li><li><a href=#the-algorithm-using-this-ruler>The Algorithm using this &ldquo;Ruler&rdquo;:</a></li><li><a href=#the-binary-search-part-eg-bisect_left>The &ldquo;Binary Search&rdquo; Part (e.g., <code>bisect_left</code>)</a></li><li><a href=#summary-in-simple-terms>Summary in Simple Terms:</a></li></ul></li><li><a href=#section-517-the-sudoku-checker-problem-page-24--pdf-page-60>Section 5.17: The Sudoku Checker Problem (Page 24 / PDF Page 60)</a><ul><li><a href=#core-implementation-idea-directly-testing-constraints>Core Implementation Idea (Directly Testing Constraints):</a></li></ul></li><li><a href=#section-518-compute-the-spiral-ordering-of-a-2d-array-page-25--pdf-page-61>Section 5.18: Compute the Spiral Ordering of a 2D Array (Page 25 / PDF Page 61)</a><ul><li><a href=#simplified-implementation-intuition-simulation-approach---robot-walk>Simplified Implementation Intuition (Simulation Approach - &ldquo;Robot Walk&rdquo;):</a></li><li><a href=#managing-direction>Managing Direction:</a></li></ul></li><li><a href=#section-519-rotate-a-2d-array-page-28--pdf-page-64>Section 5.19: Rotate a 2D Array (Page 28 / PDF Page 64)</a><ul><li><a href=#approach-1-using-extra-space-not-in-place-for-understanding>Approach 1: Using Extra Space (Not In-Place, for understanding)</a></li><li><a href=#approach-2-in-place-rotation-by-layers>Approach 2: In-Place Rotation by Layers</a></li></ul></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 5: Arrays</h1><span class=reading-time><em>1 hour 41 min read</em></span><div class=book-details><div class=book-content><h1 id=chapter-5-overview>Chapter 5 Overview:</h1><p>This chapter covers the basic properties of arrays (specifically Python lists), common manipulation techniques, and classic array-based problems. It heavily emphasizes thinking about space complexity and optimizing operations.</p><h2 id=think-of-arrays-like-this>Think of arrays like this:</h2><p>Imagine a row of numbered boxes, right next to each other in memory.</p><ul><li><strong>Contiguous</strong>: The boxes are physically adjacent. This is crucial for performance.</li><li><strong>Indexed</strong>: You can instantly jump to any box if you know its number (index). This is O(1) access.</li><li><strong>Homogeneous (usually)</strong>: Typically, all boxes hold the same type of item (like all integers or all strings), though Python lists offer more flexibility.</li></ul><hr><h2 id=why-arrays-are-important-especially-for-interviews>Why Arrays Are Important (Especially for Interviews):</h2><ol><li><strong>Efficiency</strong>: Direct access by index is super fast (O(1)).</li><li><strong>Memory Locality</strong>: Because elements are stored together, accessing sequential elements is often cache-friendly, leading to good practical performance.</li><li><strong>Building Blocks</strong>: Many other data structures (like hash maps, heaps, stacks, queues) are often <em>implemented</em> using arrays underneath.</li><li><strong>In-Place Operations</strong>: Interviewers love problems where you modify the array directly without using significant extra memory (O(1) space). This often involves clever use of pointers or swapping elements.</li></ol><hr><h2 id=array-boot-camp-reordering-array-entries-page-1>Array Boot Camp: Reordering Array Entries (Page 1)</h2><p>The boot camp problem is a fantastic introduction to <strong>in-place array manipulation using multiple pointers</strong>.</p><h3 id=the-problem>The Problem:</h3><p>Given an array of integers, rearrange it so that all the even numbers appear <strong>before</strong> all the odd numbers.<br>The order within the evens or odds doesn&rsquo;t matter.<br>Crucially, do this <strong>in-place</strong>, meaning using only <strong>O(1)</strong> extra space (you can&rsquo;t just create two new lists and combine them).</p><p>Example: Input [3, 1, 2, 4, 5, 6] could become [2, 4, 6, 1, 5, 3] or [6, 2, 4, 3, 1, 5], etc.</p><h2 id=the-boot-camp-code-explained-even_odd>The Boot Camp Code Explained (even_odd):</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>even_odd</span>(A):
</span></span><span style=display:flex><span>  next_even, next_odd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(A) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># Pointers start at opposite ends</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> next_even <span style=color:#f92672>&lt;</span> next_odd: <span style=color:#75715e># Stop when pointers meet or cross</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> A[next_even] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>      <span style=color:#75715e># A[next_even] is even. It&#39;s in the correct partition.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># Leave it there and advance the &#39;even&#39; boundary.</span>
</span></span><span style=display:flex><span>      next_even <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>      <span style=color:#75715e># A[next_even] is odd. It needs to go to the &#39;odd&#39; section.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># Swap it with the element at A[next_odd].</span>
</span></span><span style=display:flex><span>      A[next_even], A[next_odd] <span style=color:#f92672>=</span> A[next_odd], A[next_even]
</span></span><span style=display:flex><span>      <span style=color:#75715e># The element now at A[next_odd] is confirmed odd (or hasn&#39;t been checked),</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># so shrink the &#39;odd&#39; boundary.</span>
</span></span><span style=display:flex><span>      next_odd <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># No return needed as A is modified in-place</span>
</span></span></code></pre></div><h3 id=intuition-partitioning>Intuition (Partitioning):</h3><p>Think of the array being divided into three sections as you process it:</p><ul><li><code>A[0 ... next_even - 1]</code>: <strong>Even Numbers</strong> (Correctly placed)</li><li><code>A[next_even ... next_odd]</code>: <strong>Unclassified Numbers</strong> (Yet to be examined)</li><li><code>A[next_odd + 1 ... len(A) - 1]</code>: <strong>Odd Numbers</strong> (Correctly placed)</li></ul><p>The <code>while</code> loop processes the <strong>Unclassified</strong> section.</p><ul><li>The <code>next_even</code> pointer expands the <strong>Even</strong> section.</li><li>The <code>next_odd</code> pointer shrinks the <strong>Unclassified</strong> section from the right (effectively expanding the <strong>Odd</strong> section).</li></ul><p>When <code>next_even</code> finds an odd number, it swaps it with <code>A[next_odd]</code>, placing the odd number in the correct final partition, and then shrinks the <code>next_odd</code> boundary. The element that gets swapped into <code>A[next_even]</code> still needs to be checked in the next iteration of the loop, which is why <code>next_even</code> doesn&rsquo;t advance in the <code>else</code> block.</p><h3 id=complexity>Complexity:</h3><ul><li><strong>Time</strong>: O(n). Each element is examined at most once by <code>next_even</code>, and involved in at most one swap.</li><li><strong>Space</strong>: O(1). We only use a couple of pointer variables and potentially one temporary variable for the swap (though Python handles the tuple swap elegantly without explicit temp).</li></ul><p><strong>Key Takeaway</strong>: This boot camp demonstrates a powerful pattern: using two (or sometimes more) pointers to partition an array in-place based on some property.</p><h2 id=top-tips-for-arrays-page-2>Top Tips for Arrays (Page 2)</h2><p>This section lists crucial strategies for array problems:</p><ol><li><strong>Use the array itself for space</strong>: Cleverly reuse parts of the array or use indices/values to store information, avoiding extra lists/dicts.</li><li><strong>Fill from the back</strong>: When merging or writing results, starting from the end of the allocated space can avoid overwriting needed data and reduce shifting (e.g., merging two sorted arrays into one).</li><li><strong>Overwrite, don&rsquo;t delete</strong>: If you need to remove elements and order doesn&rsquo;t matter for the &ldquo;removed&rdquo; part, just overwrite them with elements you want to keep. Much faster than shifting everything left.</li><li><strong>Process integer digits</strong>: For arrays representing large numbers, process from the LSB (rightmost/last element) for arithmetic. Or reverse the array first if processing LSB-first simplifies logic.</li><li><strong>Subarrays</strong>: Be comfortable working with slices or pointer ranges (<code>A[start:end]</code>).</li><li><strong>Off-by-one errors</strong>: Double-check loop conditions (<code>&lt;</code> vs <code>&lt;=</code>), index calculations (<code>i+1</code>, <code>i-1</code>), and empty array edge cases.</li><li><strong>Don&rsquo;t preserve properties prematurely</strong>: It&rsquo;s often fine to temporarily violate sortedness or other properties during intermediate steps if you restore them by the end.</li><li><strong>Arrays as direct maps</strong>: If values are in a known, limited range (like 0-99 or ASCII), use a boolean or count array indexed by the value itself (e.g., <code>seen[value] = True</code>).</li><li><strong>Parallel logic for 2D arrays</strong>: Often, the logic for rows (iterating <code>i</code>) and columns (iterating <code>j</code>) is very similar; exploit this symmetry.</li><li><strong>Simulation vs. Formula</strong>: For generating sequences (like spiral order), sometimes writing code that directly simulates the generation process step-by-step is easier and less error-prone than deriving a complex mathematical formula for the k-th element.</li></ol><h2 id=know-your-array-libraries-python-list-page-2-3>Know Your Array Libraries (Python <code>list</code>) (Page 2-3)</h2><p>Python&rsquo;s <code>list</code> is your go-to array. It&rsquo;s dynamic (grows/shrinks) and versatile.</p><h3 id=instantiation>Instantiation:</h3><ul><li><code>my_list = []</code></li><li><code>nums = [1, 6, 3]</code></li><li><code>zeros = [0] * 10</code></li><li><code>copy_list = list(original_list)</code></li><li>List comprehensions are powerful: <code>squares = [x*x for x in range(10)]</code></li></ul><h3 id=basic-ops>Basic Ops:</h3><ul><li><code>len(A)</code></li><li><code>A.append(val)</code></li><li><code>A.insert(idx, val)</code></li><li><code>A.remove(val)</code> (removes first occurrence)</li><li><code>val in A</code> (O(n) search)</li></ul><h3 id=2d-arrays>2D Arrays:</h3><ul><li><code>matrix = [[0] * cols for _ in range(rows)]</code></li><li><strong>BEWARE</strong>: <code>matrix = [[0] * cols] * rows</code> creates shallow copies of the inner list - modifying one row modifies all!</li></ul><h3 id=copying>Copying:</h3><ul><li><code>B = A</code>: <code>B</code> is just another reference to <code>A</code>. Changes to <code>B</code> affect <code>A</code>.</li><li><code>B = list(A)</code> or <code>B = A[:]</code> or <code>B = copy.copy(A)</code>: <strong>Shallow copy</strong>. Creates a new list <code>B</code>, but elements inside <code>B</code> are still references to the same objects as in <code>A</code>. If <code>A</code> contains mutable objects (like other lists), changing them via <code>A</code> will reflect in <code>B</code>, and vice-versa.</li><li><code>B = copy.deepcopy(A)</code>: <strong>Deep copy</strong>. Creates a fully independent copy, including copies of any nested objects. Use this when you need total separation.</li></ul><h3 id=key-methods>Key Methods:</h3><ul><li><code>min(A)</code>, <code>max(A)</code></li><li><strong><code>bisect</code> module</strong> (<code>bisect_left</code>, <code>bisect_right</code>, <code>insort</code>): For efficient searching/insertion in sorted lists (O(log n) search, O(n) insertion).</li><li><code>A.reverse()</code>: Reverses in-place.</li><li><code>reversed(A)</code>: Returns an iterator for reverse order (doesn&rsquo;t modify <code>A</code>, doesn&rsquo;t create a full new list immediately).</li><li><code>A.sort()</code>: Sorts in-place.</li><li><code>sorted(A)</code>: Returns a new sorted list (doesn&rsquo;t modify <code>A</code>).</li><li><code>del A[i]</code>: Deletes element at index <code>i</code>.</li><li><code>del A[i:j]</code>: Deletes slice from <code>i</code> up to (not including) <code>j</code>.</li></ul><h3 id=slicing-astartstopstep-super-powerful>Slicing (<code>A[start:stop:step]</code>): Super powerful!</h3><ul><li><code>A[i:j]</code> gives subarray.</li><li><code>A[:j]</code> from start up to <code>j</code>.</li><li><code>A[i:]</code> from <code>i</code> to end.</li><li><code>A[:]</code> shallow copy.</li><li><code>A[::-1]</code> reverses the list (returns a new reversed list).</li><li><code>A[k:] + A[:k]</code> rotates left by <code>k</code>.</li></ul><h3 id=list-comprehensions-expression-for-item-in-iterable-if-condition>List Comprehensions: <code>[expression for item in iterable if condition]</code></h3><ul><li>Concise way to build lists.</li><li>Often clearer than <code>map</code>/<code>filter</code>.</li><li>Can nest: <code>[val for row in matrix for val in row]</code> flattens 2D list.</li><li>Avoid excessive nesting (more than 2 levels often becomes hard to read).</li></ul><h2 id=section-51-the-dutch-national-flag-problem-pages-3-6>Section 5.1: The Dutch National Flag Problem (Pages 3-6)</h2><p>This is a classic partitioning problem, essential for understanding quicksort and in-place array manipulation.</p><p><strong>The Problem</strong>: Given an array <code>A</code> and an index <code>i</code> (whose value <code>A[i]</code> is the &ldquo;pivot&rdquo;), rearrange <code>A</code> such that:</p><ol><li>All elements less than the pivot come first.</li><li>Then, all elements equal to the pivot.</li><li>Finally, all elements greater than the pivot.</li></ol><p>Do this in-place (O(1) space). The relative order within the <code>&lt;</code>, <code>==</code>, <code>></code> groups doesn&rsquo;t matter.</p><p><strong>Example</strong>: <code>A = [0, 1, 2, 0, 2, 1, 1]</code>, <code>pivot_index = 3</code> (pivot value = 0).
A valid result: <code>[0, 0, 1, 2, 2, 1, 1]</code> or <code>[0, 0, 1, 1, 1, 2, 2]</code> (after sorting groups). But the simplest valid result might be <code>[0, 0, 1, 2, 2, 1, 1]</code>.</p><h3 id=approach-1-two-passes-less-efficient-conceptually-simpler>Approach 1: Two Passes (Less efficient, conceptually simpler)</h3><ol><li><strong>First Pass (Less Than)</strong>: Iterate through <code>A</code>. Keep a pointer <code>smaller</code> (initially 0). If <code>A[current_index] &lt; pivot</code>, swap <code>A[current_index]</code> with <code>A[smaller]</code> and increment <code>smaller</code>. This brings all smaller elements to the front.</li><li><strong>Second Pass (Greater Than)</strong>: Iterate backwards through <code>A</code>. Keep a pointer <code>larger</code> (initially <code>n-1</code>). If <code>A[current_index] > pivot</code>, swap <code>A[current_index]</code> with <code>A[larger]</code> and decrement <code>larger</code>. This pushes all larger elements to the end.</li></ol><p>After these two passes, elements equal to the pivot will naturally be left in the middle.</p><ul><li><strong>Time</strong>: O(n) + O(n) = O(n).</li><li><strong>Space</strong>: O(1).</li></ul><h3 id=approach-2-single-pass-the-standard-efficient-solution>Approach 2: Single Pass (The Standard, Efficient Solution)</h3><p>This is the implementation shown in the book, often preferred in interviews.</p><p><strong>Intuition</strong>: Divide the array into four regions using three pointers:</p><ul><li><code>A[0 ... smaller - 1]</code>: <strong>Bottom</strong> (Known to be <code>&lt; pivot</code>)</li><li><code>A[smaller ... equal - 1]</code>: <strong>Middle</strong> (Known to be <code>== pivot</code>)</li><li><code>A[equal ... larger - 1]</code>: <strong>Unclassified</strong> (Elements we haven&rsquo;t processed yet)</li><li><code>A[larger ... n - 1]</code>: <strong>Top</strong> (Known to be <code>> pivot</code>)</li></ul><p><strong>Pointers</strong>:</p><ul><li><code>smaller</code>: Boundary between Bottom and Middle.</li><li><code>equal</code>: Boundary between Middle and Unclassified (the current element being processed).</li><li><code>larger</code>: Boundary between Unclassified and Top.</li></ul><p><strong>Algorithm</strong>:</p><ol><li>Initialize <code>smaller = 0</code>, <code>equal = 0</code>, <code>larger = len(A)</code>.</li><li>Get <code>pivot = A[pivot_index]</code>.</li><li>Loop <code>while equal &lt; larger</code>: (While there are unclassified elements)<ul><li>Examine <code>A[equal]</code>.</li><li><strong>Case 1: <code>A[equal] &lt; pivot</code></strong><ul><li>Swap <code>A[equal]</code> with <code>A[smaller]</code>.</li><li>Increment <code>smaller</code>.</li><li>Increment <code>equal</code>.</li></ul></li><li><strong>Case 2: <code>A[equal] == pivot</code></strong><ul><li>Increment <code>equal</code>. (Element is in the right place relative to <code>smaller</code>).</li></ul></li><li><strong>Case 3: <code>A[equal] > pivot</code></strong><ul><li>Decrement <code>larger</code>. (Shrink unclassified region from the right).</li><li>Swap <code>A[equal]</code> with <code>A[larger]</code>.</li><li><strong>Crucially</strong>: Do NOT increment <code>equal</code> here. The element just swapped into <code>A[equal]</code> came from the unprocessed <code>larger</code> region and still needs to be classified in the next loop iteration.</li></ul></li></ul></li></ol><p>Let&rsquo;s revisit the requirements:</p><ul><li><strong>Input</strong>: An array <code>A</code> (e.g., <code>[0, 1, 2, 0, 2, 1, 1]</code>) and an index <code>i</code> (e.g., <code>pivot_index = 3</code>).</li><li><strong>Pivot Value</strong>: The value at that index, <code>pivot = A[pivot_index]</code> (so <code>pivot = 0</code> in our example).</li><li><strong>Goal</strong>: Rearrange <code>A</code> so it looks like this:
<code>[ &lt;pivot | ==pivot | >pivot ]</code>
Specifically:<ul><li><code>[ All elements LESS THAN pivot ]</code> - These come first.</li><li><code>[ All elements EQUAL TO pivot ]</code> - These come next.</li><li><code>[ All elements GREATER THAN pivot ]</code> - These come last.</li></ul></li></ul><p><strong>Why three categories?</strong> This is extremely useful as a subroutine in Quicksort. If an array has many duplicate elements equal to the pivot, standard Quicksort (which partitions into just <code>&lt; pivot</code> and <code>>= pivot</code>) can perform poorly (O(n^2)). By putting all elements equal to the pivot into their own group in the middle, you exclude them from the recursive calls on the <code>&lt; pivot</code> and <code>> pivot</code> subarrays. This makes Quicksort much more efficient (O(n log n) on average, O(n) if all elements are equal) when duplicates are present.</p><p><strong>&ldquo;Do this in-place (O(1) space)&rdquo;</strong>: This means you cannot create new helper arrays to store the <code>&lt;</code>, <code>==</code>, and <code>></code> elements temporarily. You must achieve the final arrangement by only swapping elements within the original array <code>A</code>, using only a constant amount of extra memory (like variables for the pivot value and your pointers <code>smaller</code>, <code>equal</code>, <code>larger</code>). This is the main challenge and why the pointer techniques are important.</p><p><strong>&ldquo;The relative order within the <code>&lt;</code>, <code>==</code>, <code>></code> groups doesn&rsquo;t matter&rdquo;</strong>: This is a relaxation that makes the problem easier. Look at the example <code>A = [0, 1, 2, 0, 2, 1, 1]</code> with <code>pivot = 0</code>.</p><ul><li>The <code>&lt; pivot</code> group is empty.</li><li>The <code>== pivot</code> group contains <code>[0, 0]</code>.</li><li>The <code>> pivot</code> group contains <code>[1, 2, 2, 1, 1]</code>.</li></ul><p>A valid final arrangement could be <code>[0, 0, | 1, 2, 2, 1, 1]</code>. Another could be <code>[0, 0, | 2, 1, 1, 2, 1]</code>. As long as all the 0s come first, followed by all the numbers greater than 0, it&rsquo;s correct. We don&rsquo;t need to keep the original relative order of the 1s and 2s within the <code>> pivot</code> group. This freedom allows us to perform swaps more easily. If we had to maintain relative order (a &ldquo;stable partition&rdquo;), the O(1) space solution would be much harder.</p><p><strong>In essence</strong>: The Dutch Flag problem is just a more detailed partitioning than <code>even_odd</code>. Instead of two bins, you have three (<code>&lt;</code>, <code>==</code>, <code>></code>). The challenge lies in achieving this three-way split efficiently using only the existing array.</p><hr><h2 id=section-52-increment-an-arbitrary-precision-integer-page-7--pdf-page-43>Section 5.2: Increment an Arbitrary-Precision Integer (Page 7 / PDF Page 43)</h2><p><strong>The Concept</strong>: Standard integer types in many languages (like <code>int</code> in C++ or Java) have a fixed size (e.g., 32 or 64 bits) and thus a maximum value. Python handles this automatically with its arbitrary-precision integers, but interview problems often ask you to simulate this behavior, typically by storing the digits of a very large number in an array (or list in Python).</p><p><strong>Representation</strong>: An array <code>A</code> represents a non-negative integer <code>D</code>. Each element <code>A[i]</code> holds a single digit. The most significant digit is usually at <code>A[0]</code>.</p><ul><li><strong>Example</strong>: <code>D = 129</code> is represented as <code>A = [1, 2, 9]</code>.</li><li><strong>Example</strong>: <code>D = 99</code> is represented as <code>A = [9, 9]</code>.</li></ul><p><strong>The Problem</strong>: Write a function that takes such an array <code>A</code> representing integer <code>D</code> and updates it in-place to represent <code>D + 1</code>. Handle potential carries, including the case where the number of digits increases (like 99 + 1 = 100).</p><p><strong>Brute-Force (and why it&rsquo;s often not allowed/intended)</strong>:</p><ol><li>Convert the array <code>[1, 2, 9]</code> into the integer <code>129</code>.</li><li>Add 1: <code>129 + 1 = 130</code>.</li><li>Convert <code>130</code> back into an array <code>[1, 3, 0]</code>.</li></ol><p><em>Limitation</em>: This fails if the integer <code>D</code> is larger than the maximum value the language&rsquo;s built-in integer type can hold (this isn&rsquo;t an issue for Python&rsquo;s runtime integers, but the problem setup often simulates fixed-precision constraints or asks you to avoid this conversion). It also doesn&rsquo;t modify the array in-place directly.</p><p><strong>The Grade-School Algorithm Approach</strong>:
Think about how you add 1 to a number on paper, like 129 + 1:</p><ol><li>Start from the rightmost digit (Least Significant Digit - LSB).</li><li>Add 1 to the last digit: 9 + 1 = 10.</li><li>Write down the 0, carry-over the 1.</li><li>Move to the next digit to the left (2). Add the carry: 2 + 1 = 3.</li><li>Write down the 3. No carry-over this time (carry is 0).</li><li>Move to the next digit to the left (1). Add the carry: 1 + 0 = 1.</li><li>Write down the 1. No carry-over.</li><li>No more digits, result is 130.</li></ol><p>Now consider 99 + 1:</p><ol><li>Start rightmost: 9 + 1 = 10. Write 0, carry 1.</li><li>Next digit: 9 + 1 (carry) = 10. Write 0, carry 1.</li><li>No more digits, but we still have a carry. This means the result needs an extra digit. The result is 100.</li></ol><p><strong>Simulating on the Array</strong>:</p><ol><li>We operate directly on the array <code>A</code>.</li><li>Increment the last element: <code>A[n-1] += 1</code>.</li><li>Iterate from right-to-left (from <code>n-1</code> down to <code>1</code>).<ul><li>If <code>A[i] == 10</code> (meaning we had a carry into this position):<ul><li>Set <code>A[i] = 0</code>.</li><li>Increment the digit to the left: <code>A[i-1] += 1</code>.</li></ul></li><li>If <code>A[i]</code> is not <code>10</code> after adding the potential carry, then the carry propagation stops, and we can break the loop early.</li></ul></li><li><strong>Special Case</strong>: After the loop, check if the first digit <code>A[0]</code> became <code>10</code>. If it did, it means we had a carry out of the most significant digit.<ul><li>Set <code>A[0] = 1</code>.</li><li>Append a <code>0</code> to the end of the array to accommodate the new least significant digit. (The book uses a slightly different but equivalent way: set <code>A[0]=1</code>, <code>A.append(0)</code>).</li></ul></li></ol><hr><h2 id=section-53-multiply-two-arbitrary-precision-integers-page-7-8--pdf-pages-43-44>Section 5.3: Multiply Two Arbitrary-Precision Integers (Page 7-8 / PDF Pages 43-44)</h2><p><strong>The Problem</strong>: Now, instead of adding 1, multiply two non-negative integers <code>num1</code> and <code>num2</code>, represented as arrays of digits. Return their product, also as an array of digits. Handle potential negative numbers indicated by a negative sign in the first element (e.g., <code>[-7, 6, 1]</code> represents -761).</p><p><strong>Example</strong>: <code>[1, 2, 3]</code> (123) * <code>[9, 8, 7]</code> (987) = <code>[1, 2, 1, 4, 0, 1]</code> (121401)</p><p><strong>Again, Brute-Force Conversion Fails</strong>: Converting to built-in integers and multiplying won&rsquo;t work for numbers exceeding the language&rsquo;s fixed precision limits.</p><p><strong>Grade-School Multiplication Algorithm</strong>:
Think about 123 * 987:</p><pre tabindex=0><code>123
x 987
------
861   (= 7 * 123)
984   (= 8 * 123, shifted left 1 place)
1107  (= 9 * 123, shifted left 2 places)
------
121401 (Sum of the above)
</code></pre><p><strong>Simulating on Arrays</strong>:</p><ol><li><p><strong>Handle Sign</strong>:</p><ul><li>Determine the sign of the result (-1 if one input is negative, 1 otherwise).</li><li>Make both input arrays positive for the multiplication step (e.g., using <code>abs()</code> on the first element).</li></ul></li><li><p><strong>Result Array Size</strong>:</p><ul><li>The product of an n-digit number and an m-digit number can have at most <code>n + m</code> digits.</li><li>Create a <code>result</code> array of size <code>n + m</code>, initialized to zeros.</li></ul></li><li><p><strong>Core Multiplication Loop</strong>: Iterate through <code>num1</code> from right-to-left (index <code>i</code>) and <code>num2</code> from right-to-left (index <code>j</code>).</p><ul><li>For each pair <code>num1[i]</code> and <code>num2[j]</code>, calculate the product <code>num1[i] * num2[j]</code>.</li><li>This product contributes to the position <code>result[i + j + 1]</code> (think about the place values: 10a * 10b = 10(a+b)).</li><li>Add this product to <code>result[i + j + 1]</code>.</li><li>Handle the carry: The carry from this addition goes into <code>result[i + j]</code>.<ul><li><code>result[i + j] += result[i + j + 1] // 10</code>.</li></ul></li><li>Keep the digit:<ul><li><code>result[i + j + 1] %= 10</code>.</li></ul></li><li>This directly adds the partial products into the correct positions in the <code>result</code> array, simulating the addition step of grade-school multiplication implicitly.</li></ul></li><li><p><strong>Remove Leading Zeros</strong>:</p><ul><li>The <code>result</code> array might have leading zeros (e.g., if multiplying small numbers like <code>[1]*[1]</code>).</li><li>Find the first non-zero digit and return the slice from that point onwards.</li><li>Handle the case where the result is 0 (return <code>[0]</code>).</li></ul></li><li><p><strong>Apply Sign</strong>:</p><ul><li>If the overall sign calculated in step 1 was negative, negate the first element of the final <code>result</code> array.</li></ul></li></ol><h3 id=complexity-1>Complexity:</h3><ul><li><strong>Time</strong>: O(n * m), where n and m are the number of digits in the two input numbers. This comes from the nested loops iterating through all pairs of digits.</li><li><strong>Space</strong>: O(n + m) for the result array.</li></ul><hr><h2 id=section-54-advancing-through-an-array-page-8--pdf-page-44>Section 5.4: Advancing Through an Array (Page 8 / PDF Page 44)</h2><p><strong>The Problem</strong>: Imagine a board game where you&rsquo;re on a sequence of positions represented by an array <code>A</code>. Each <code>A[i]</code> contains a non-negative integer telling you the maximum number of steps you can take forward from position <code>i</code>. You start at index 0. Can you reach the last index of the array?</p><p><strong>Example 1</strong>: <code>A = [3, 3, 1, 0, 2, 0, 1]</code></p><ul><li>Start at index 0 (<code>A[0]=3</code>). Can move 1, 2, or 3 steps.</li><li>Option 1: Move 1 step to index 1 (<code>A[1]=3</code>). From index 1, can move 1, 2, or 3 steps.</li><li>Let&rsquo;s move 3 steps to index 4 (<code>A[4]=2</code>). From index 4, can move 1 or 2 steps.</li><li>Let&rsquo;s move 2 steps to index 6 (<code>A[6]=1</code>). Index 6 is the last index.</li><li><strong>Yes, we can reach the end.</strong></li></ul><p><strong>Example 2</strong>: <code>A = [3, 2, 0, 0, 2, 0, 1]</code></p><ul><li>Start at index 0 (<code>A[0]=3</code>). Can move 1, 2, or 3 steps.<ul><li>If we move 1 step -> index 1 (<code>A[1]=2</code>). Can reach index 2 or 3.</li><li>If we move 2 steps -> index 2 (<code>A[2]=0</code>). Stuck.</li><li>If we move 3 steps -> index 3 (<code>A[3]=0</code>). Stuck.</li></ul></li><li>From index 1, max reach is 1+2=3. Both indices 2 and 3 have 0s. We cannot get past index 3.</li><li><strong>No, we cannot reach the end.</strong></li></ul><p><strong>Initial Thoughts & Why Simple Greedy Fails</strong>:
You might think: &ldquo;Always take the maximum jump possible from the current position.&rdquo; This doesn&rsquo;t work.
Consider <code>A = [2, 4, 1, 1, 0, 2, 3]</code>. Max jump from index 0 takes you to index 2 (<code>A[2]=1</code>). From there you get stuck. But taking just 1 step from index 0 to index 1 (<code>A[1]=4</code>) lets you jump much further and potentially reach the end.</p><p><strong>The Efficient Approach: Track Maximum Reach</strong>
The key idea is to iterate through the array and keep track of the furthest index we know we can possibly reach so far.</p><p><strong>Algorithm</strong>:</p><ol><li>Initialize <code>max_reach = 0</code>. This variable will store the furthest index reachable from the positions we&rsquo;ve visited.</li><li>Iterate through the array with an index <code>i</code> from <code>0</code> up to <code>len(A) - 1</code>.</li><li><strong>Crucial Check</strong>: In each iteration <code>i</code>, first check if <code>i > max_reach</code>.<ul><li>If <code>i</code> is greater than <code>max_reach</code>, it means we could never have reached the current index <code>i</code> from any previous position. Therefore, we definitely cannot reach the end. Return <code>False</code>.</li></ul></li><li><strong>Update the maximum reach</strong>: Calculate the furthest we could jump from the current position <code>i</code>. This is <code>i + A[i]</code>.<ul><li>Update <code>max_reach = max(max_reach, i + A[i])</code>.</li></ul></li><li><strong>Check for early success</strong>: If at any point <code>max_reach</code> becomes greater than or equal to the last index (<code>len(A) - 1</code>), we know we can reach the end. Return <code>True</code>.</li><li>If the loop completes without returning <code>False</code> (meaning we could always reach the current <code>i</code>) and without having reached the end yet (which implies <code>max_reach</code> might have landed exactly on the last index in the final iteration), we still need a final check after the loop, but the logic shown below incorporates this cleanly.</li></ol><p><em>Note: The book&rsquo;s code slightly reformulates the loop condition and final check, but the core logic of tracking <code>max_reach</code> is the same.</em></p><h3 id=intuition-walkthrough-example-1-a--3-3-1-0-2-0-1>Intuition Walkthrough (Example 1: <code>A = [3, 3, 1, 0, 2, 0, 1]</code>)</h3><ul><li><code>i=0</code>: <code>max_reach=0</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(0, 0+3) = 3</code>. <code>i</code> becomes 1.</li><li><code>i=1</code>: <code>max_reach=3</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(3, 1+3) = 4</code>. <code>i</code> becomes 2.</li><li><code>i=2</code>: <code>max_reach=4</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(4, 2+1) = 4</code>. <code>i</code> becomes 3.</li><li><code>i=3</code>: <code>max_reach=4</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(4, 3+0) = 4</code>. <code>i</code> becomes 4.</li><li><code>i=4</code>: <code>max_reach=4</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(4, 4+2) = 6</code>. <code>i</code> becomes 5.</li><li>Loop condition: <code>i &lt;= max_reach</code> (5 &lt;= 6) is true, but <code>max_reach &lt; last_index</code> (6 &lt; 6) is false. Loop terminates.</li><li>Return <code>max_reach >= last_index</code> (6 >= 6) -> <strong>True</strong>.</li></ul><h3 id=intuition-walkthrough-example-2-a--3-2-0-0-2-0-1>Intuition Walkthrough (Example 2: <code>A = [3, 2, 0, 0, 2, 0, 1]</code>)</h3><ul><li><code>i=0</code>: <code>max_reach=0</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(0, 0+3) = 3</code>. <code>i</code> becomes 1.</li><li><code>i=1</code>: <code>max_reach=3</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(3, 1+2) = 3</code>. <code>i</code> becomes 2.</li><li><code>i=2</code>: <code>max_reach=3</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(3, 2+0) = 3</code>. <code>i</code> becomes 3.</li><li><code>i=3</code>: <code>max_reach=3</code>. <code>i &lt;= max_reach</code> is true. <code>max_reach = max(3, 3+0) = 3</code>. <code>i</code> becomes 4.</li><li><code>i=4</code>: <code>max_reach=3</code>. <code>i &lt;= max_reach</code> (4 &lt;= 3) is false. Loop terminates earlier.</li><li>Return <code>max_reach >= last_index</code> (3 >= 6) -> <strong>False</strong>.</li></ul><h3 id=analogy-hopping-stones-across-a-river>Analogy: Hopping Stones Across a River</h3><p>Imagine the array indices <code>0, 1, 2, ... n-1</code> are stones lined up across a river.</p><ul><li>You start at stone <code>0</code>.</li><li>The number <code>A[i]</code> on each stone tells you the maximum length of a single jump you can take from that stone. So, from stone <code>i</code>, you can land on any stone <code>j</code> where <code>i &lt; j &lt;= i + A[i]</code>.</li><li><strong>Goal</strong>: Can you reach the last stone (stone <code>n-1</code>)?</li></ul><p><strong>Why simple jumping doesn&rsquo;t work</strong>: If you just stand on stone <code>i</code> and decide which jump to take next, you might make a bad choice. A shorter jump might land you on a stone with a much bigger <code>A[j]</code> value that lets you cross the river, while the longest jump from <code>i</code> might land you somewhere useless.</p><h3 id=the-max_reach-idea-tracking-your-potential>The <code>max_reach</code> Idea: Tracking Your Potential</h3><p><strong>Why this &ldquo;tracking the potential&rdquo; works</strong>:</p><ul><li><strong>It&rsquo;s safe</strong>: We only advance our current position <code>i</code> if it&rsquo;s within the known <code>max_reach</code>. If we ever encounter an <code>i</code> that&rsquo;s beyond <code>max_reach</code>, it means no combination of previous jumps could have gotten us there.</li><li><strong>It&rsquo;s sufficient</strong>: We don&rsquo;t need to know the exact path. We only need to know if the <em>potential</em> to reach the end exists. By always updating <code>max_reach</code> to the maximum possible distance (<code>max(current_max_reach, i + A[i])</code>), we are essentially keeping track of the &ldquo;frontier&rdquo; of reachable stones. If that frontier ever touches or crosses the last stone, we know a path must exist.</li></ul><p>Think of it like this: <code>max_reach</code> is your &ldquo;optimistic outlook&rdquo;. At each step <code>i</code> you can actually reach, you check if the jump from <code>i</code> gives you a more optimistic outlook than you already had. If your current position <code>i</code> ever falls behind your optimistic outlook (<code>i > max_reach</code>), then your optimism was unfounded, and you&rsquo;re stuck.</p><p>Instead of deciding which <em>specific</em> jump to take, we focus on a simpler question: &ldquo;What is the absolute furthest stone I could possibly reach, given the stones I&rsquo;ve visited so far?&rdquo;</p><h3 id=complexity-2>Complexity:</h3><ul><li><strong>Time</strong>: O(n). We iterate through the array at most once.</li><li><strong>Space</strong>: O(1). We only use a few variables (<code>max_reach</code>, <code>i</code>, <code>last_index</code>).</li></ul><h3 id=variant-minimum-steps>Variant: Minimum Steps</h3><p>The variant asks for the <strong>minimum number of steps</strong> to reach the end. This smells like a <strong>Breadth-First Search (BFS)</strong>.</p><p>Think of array indices as nodes in a graph. There&rsquo;s an edge from <code>i</code> to <code>j</code> if <code>j</code> is reachable from <code>i</code> (i.e., <code>i &lt; j &lt;= i + A[i]</code>). You want the shortest path from node 0 to node <code>n-1</code>.</p><p>A standard BFS exploring reachable indices level by level will find the minimum number of jumps. You&rsquo;d need a way to keep track of visited indices to avoid cycles/redundant work and a queue to manage the BFS levels. The state in the queue could be <code>(index, num_jumps)</code>. This would likely take O(n) time and O(n) space (for the queue and visited set/array).</p><hr><h2 id=section-55-delete-duplicates-from-a-sorted-array-page-9--pdf-page-45>Section 5.5: Delete Duplicates from a Sorted Array (Page 9 / PDF Page 45)</h2><p><strong>The Problem</strong>: You are given a sorted array <code>A</code>. Your task is to remove duplicate elements so that each unique element appears only once. You should do this <strong>in-place</strong>, modifying the original array <code>A</code>. The elements that are kept should be shifted to the beginning of the array. You need to return the <strong>number of valid, unique elements</strong> remaining in the array. What&rsquo;s stored in the array beyond the last valid element doesn&rsquo;t matter.</p><p><strong>Example</strong>:</p><ul><li><strong>Input</strong>: <code>A = [2, 3, 5, 5, 7, 11, 11, 11, 13]</code></li><li><strong>Output</strong>: The function should return <code>6</code>.</li><li>After the function runs, the array <code>A</code> should be modified so its beginning looks like: <code>[2, 3, 5, 7, 11, 13, ... ]</code>. The values in the positions after index 5 are irrelevant (e.g., <code>[2, 3, 5, 7, 11, 13, 11, 11, 13]</code> would be a valid state for <code>A</code>).</li></ul><p><strong>Why &ldquo;Sorted&rdquo; is Key</strong>: Because the array is sorted, all duplicate elements are guaranteed to be grouped together consecutively. This makes identifying them much easier than if the array were unsorted.</p><p><strong>Common Pitfalls</strong>:</p><ul><li><strong>Using O(n) space</strong>: It&rsquo;s easy to iterate through <code>A</code>, store unique elements in a set or a new list, and then copy them back. But the problem often requires O(1) extra space (in-place modification).</li><li><strong>Shifting elements repeatedly</strong>: You could find a duplicate <code>A[i] == A[i-1]</code>, and then shift all elements from <code>A[i+1]</code> onwards one step to the left. This works, but if you have many duplicates (e.g., <code>[2, 2, 2, 2, 3]</code>), you end up doing a lot of shifting, leading to O(n^2) time complexity in the worst case.</li></ul><p><strong>The Efficient In-Place Approach: Two Pointers (Read & Write)</strong>
This is a very common and useful pattern for modifying arrays in-place when you want to keep only certain elements.</p><p><strong>The Strategy</strong>:</p><ol><li>Use one pointer (<code>read_index</code> or just the loop index <code>i</code> in the code below) to iterate through the original array from the second element onwards.</li><li>Use a second pointer (<code>write_index</code>) to keep track of the next position in the array where a unique element should be written. Initialize <code>write_index = 1</code> (since the very first element <code>A[0]</code> is always unique by definition, assuming the array isn&rsquo;t empty).</li><li>Compare the element being read (<code>A[i]</code>) with the last unique element written (<code>A[write_index - 1]</code>).<ul><li>If <code>A[i]</code> is <strong>different</strong> from <code>A[write_index - 1]</code>, it means we&rsquo;ve found a new unique element.<ul><li>Copy this unique element <code>A[i]</code> to the next available write position: <code>A[write_index] = A[i]</code>.</li><li>Advance the write pointer: <code>write_index += 1</code>.</li></ul></li><li>If <code>A[i]</code> is the <strong>same</strong> as <code>A[write_index - 1]</code>, it&rsquo;s a duplicate. We simply ignore it and move the read pointer (<code>i</code>) forward, without advancing <code>write_index</code>. This effectively overwrites duplicates later when a new unique element is found.</li></ul></li><li>After iterating through the entire array, <code>write_index</code> will hold the count of unique elements, and the subarray <code>A[0 ... write_index - 1]</code> will contain those unique elements.</li></ol><hr><h2 id=section-56-buy-and-sell-a-stock-once-page-10--pdf-page-46>Section 5.6: Buy and Sell a Stock Once (Page 10 / PDF Page 46)</h2><p><strong>The Problem</strong>: You&rsquo;re given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on day <code>i</code>. You want to find the maximum profit you can achieve by buying the stock on one day and selling it on a later day. If no profit can be made (prices always decrease), the maximum profit is 0. You must buy before you sell.</p><p><strong>Example</strong>: <code>prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]</code></p><ul><li>Buy at 260 (day 4, index 4), Sell at 290 (day 6, index 6). Profit = 290 - 260 = 30.</li><li>This is the maximum possible profit. Note: minimum price is 230, max is 315, but 315 occurs before 230, so you can&rsquo;t buy at 230 and sell at 315.</li></ul><p><strong>Brute-Force</strong>: Try every possible pair of (<code>buy_day</code>, <code>sell_day</code>) where <code>sell_day > buy_day</code>. Calculate the profit for each pair and keep track of the maximum.</p><ul><li>Use nested loops: outer loop for <code>buy_day</code> from 0 to <code>n-2</code>, inner loop for <code>sell_day</code> from <code>buy_day + 1</code> to <code>n-1</code>.</li><li><strong>Time Complexity</strong>: O(n^2).</li><li><strong>Space Complexity</strong>: O(1).</li><li>(Too slow for large inputs).</li></ul><p><strong>Divide and Conquer (Mentioned in Book Introduction, not here)</strong>: Split the array in half, find the max profit in the left half, find the max profit in the right half, and find the max profit that crosses the midpoint (buy in left, sell in right). The crossing part requires finding the min price in the left and max price in the right. This leads to O(n log n) time. Better, but we can do even better.</p><p><strong>The Efficient Linear Scan Approach</strong>:</p><p><strong>Key Idea</strong>: As you iterate through the prices day by day, what information do you need to know from the past to decide the best potential profit if you sell today? You need to know the <strong>minimum price encountered before today</strong>.</p><p><strong>Algorithm</strong>:</p><ol><li>Initialize <code>min_price_so_far</code> to a very large value (or <code>prices[0]</code> if the array is not empty).</li><li>Initialize <code>max_profit</code> to <code>0.0</code>.</li><li>Iterate through the <code>prices</code> array, starting from the first price. Let the current price be <code>price</code>.<ul><li>Calculate potential profit if selling today: <code>potential_profit = price - min_price_so_far</code>.</li><li>Update maximum profit: <code>max_profit = max(max_profit, potential_profit)</code>.</li><li>Update minimum price seen: <code>min_price_so_far = min(min_price_so_far, price)</code>.</li></ul></li><li>After iterating through all prices, <code>max_profit</code> will hold the maximum profit achievable.</li></ol><h3 id=intuition-walkthrough-prices--310-315-275-295-260-270-290-230-255-250>Intuition Walkthrough (<code>prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]</code>):</h3><table><thead><tr><th style=text-align:left><code>price</code></th><th style=text-align:left><code>min_price_so_far (Before Update)</code></th><th style=text-align:left><code>profit_sell_today</code></th><th style=text-align:left><code>max_profit (After Update)</code></th><th style=text-align:left><code>min_price_so_far (After Update)</code></th></tr></thead><tbody><tr><td style=text-align:left>310</td><td style=text-align:left>inf</td><td style=text-align:left>-inf</td><td style=text-align:left>0</td><td style=text-align:left>310</td></tr><tr><td style=text-align:left>315</td><td style=text-align:left>310</td><td style=text-align:left>5</td><td style=text-align:left>5</td><td style=text-align:left>310</td></tr><tr><td style=text-align:left>275</td><td style=text-align:left>310</td><td style=text-align:left>-35</td><td style=text-align:left>5</td><td style=text-align:left>275</td></tr><tr><td style=text-align:left>295</td><td style=text-align:left>275</td><td style=text-align:left>20</td><td style=text-align:left>20</td><td style=text-align:left>275</td></tr><tr><td style=text-align:left>260</td><td style=text-align:left>275</td><td style=text-align:left>-15</td><td style=text-align:left>20</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>270</td><td style=text-align:left>260</td><td style=text-align:left>10</td><td style=text-align:left>20</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>290</td><td style=text-align:left>260</td><td style=text-align:left>30</td><td style=text-align:left>30</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>230</td><td style=text-align:left>260</td><td style=text-align:left>-30</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr><tr><td style=text-align:left>255</td><td style=text-align:left>230</td><td style=text-align:left>25</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr><tr><td style=text-align:left>250</td><td style=text-align:left>230</td><td style=text-align:left>20</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr></tbody></table><p>Final <code>max_profit</code> = 30.</p><h3 id=complexity-3>Complexity:</h3><ul><li><strong>Time</strong>: O(n). We iterate through the array exactly once.</li><li><strong>Space</strong>: O(1). We only use two variables (<code>min_price_so_far</code>, <code>max_profit</code>).</li></ul><h3 id=variant-longest-equal-subarray>Variant: Longest Equal Subarray</h3><p>Find the length of the longest contiguous subarray where all entries are equal.</p><p>Iterate through the array, keeping track of the <code>current_length</code> of the equal sequence and the <code>max_length</code> found so far.</p><ul><li>If <code>A[i] == A[i-1]</code>, increment <code>current_length</code>.</li><li>If <code>A[i] != A[i-1]</code>, reset <code>current_length</code> to 1.</li><li>Update <code>max_length = max(max_length, current_length)</code> in each iteration.</li></ul><p>O(n) time, O(1) space.</p><h3 id=intuition-walkthrough-prices--310-315-275-295-260-270-290-230-255-250-1>Intuition Walkthrough (<code>prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]</code>):</h3><table><thead><tr><th style=text-align:left>price</th><th style=text-align:left>min_price_so_far (Before Update)</th><th style=text-align:left>profit_sell_today</th><th style=text-align:left>max_profit (After Update)</th><th style=text-align:left>min_price_so_far (After Update)</th></tr></thead><tbody><tr><td style=text-align:left>310</td><td style=text-align:left>inf</td><td style=text-align:left>-inf</td><td style=text-align:left>0</td><td style=text-align:left>310</td></tr><tr><td style=text-align:left>315</td><td style=text-align:left>310</td><td style=text-align:left>5</td><td style=text-align:left>5</td><td style=text-align:left>310</td></tr><tr><td style=text-align:left>275</td><td style=text-align:left>310</td><td style=text-align:left>-35</td><td style=text-align:left>5</td><td style=text-align:left>275</td></tr><tr><td style=text-align:left>295</td><td style=text-align:left>275</td><td style=text-align:left>20</td><td style=text-align:left>20</td><td style=text-align:left>275</td></tr><tr><td style=text-align:left>260</td><td style=text-align:left>275</td><td style=text-align:left>-15</td><td style=text-align:left>20</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>270</td><td style=text-align:left>260</td><td style=text-align:left>10</td><td style=text-align:left>20</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>290</td><td style=text-align:left>260</td><td style=text-align:left>30</td><td style=text-align:left>30</td><td style=text-align:left>260</td></tr><tr><td style=text-align:left>230</td><td style=text-align:left>260</td><td style=text-align:left>-30</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr><tr><td style=text-align:left>255</td><td style=text-align:left>230</td><td style=text-align:left>25</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr><tr><td style=text-align:left>250</td><td style=text-align:left>230</td><td style=text-align:left>20</td><td style=text-align:left>30</td><td style=text-align:left>230</td></tr></tbody></table><p>Final <code>max_profit</code> = 30.</p><h3 id=complexity-4>Complexity:</h3><ul><li><strong>Time</strong>: O(n). We iterate through the array exactly once.</li><li><strong>Space</strong>: O(1). We only use two variables (<code>min_price_so_far</code>, <code>max_profit</code>).</li></ul><h3 id=variant-longest-equal-subarray-1>Variant: Longest Equal Subarray</h3><p>Find the length of the longest contiguous subarray where all entries are equal.</p><p>Iterate through the array, keeping track of the <code>current_length</code> of the equal sequence and the <code>max_length</code> found so far.</p><ul><li>If <code>A[i] == A[i-1]</code>, increment <code>current_length</code>.</li><li>If <code>A[i] != A[i-1]</code>, reset <code>current_length</code> to 1.</li><li>Update <code>max_length = max(max_length, current_length)</code> in each iteration.</li></ul><p>O(n) time, O(1) space.</p><hr><h2 id=section-57-buy-and-sell-a-stock-twice-page-11--pdf-page-47>Section 5.7: Buy and Sell a Stock Twice (Page 11 / PDF Page 47)</h2><p><strong>The Problem</strong>: Same setup as before, but now you can buy and sell <strong>at most twice</strong>. The second buy must happen after the first sell. Find the maximum profit.</p><p><strong>Example</strong>: <code>prices = [12, 11, 13, 9, 12, 8, 14, 13, 15]</code></p><ul><li>First Tx: Buy at 9, Sell at 12 (Profit 3)</li><li>Second Tx: Buy at 8, Sell at 15 (Profit 7)</li><li>Total Profit = 3 + 7 = 10. This is the maximum.</li></ul><p><strong>Brute-Force</strong>: Try all combinations of two disjoint buy-sell intervals. O(n4) (choose 4 days). Too slow.</p><p><strong>Improved Brute-Force</strong>: Iterate through all possible split points <code>i</code> (day the first sale happens or second buy happens). Find the max profit for one transaction in <code>prices[0...i]</code> and the max profit for one transaction in <code>prices[i...n-1]</code>. Add them up. Keep track of the maximum sum.</p><ul><li>Using the O(n) algorithm from Section 5.6 for each subarray takes O(n) time. Doing this for <code>n</code> possible split points gives O(n2) total time. Space is O(1). Better, but still not optimal.</li></ul><p><strong>The Efficient Dynamic Programming Approach</strong>:</p><p>The Core Difficulty: How do you decide the four days (<code>buy1</code>, <code>sell1</code>, <code>buy2</code>, <code>sell2</code>) optimally? Trying all combinations is too slow (O(n4)).</p><h3 id=the-key-insight-decomposition>The Key Insight (Decomposition):</h3><p>Imagine you complete your first transaction by selling on day <code>i</code>.</p><ul><li>This means you bought on some day <code>b1 &lt;= i</code> and sold on day <code>i</code>.</li><li>The best you could have done for this first transaction ending on day <code>i</code> is <code>MaxProfit(prices[0...i])</code>. Let&rsquo;s call this <code>Profit1_ending_at_i</code>.</li></ul><p>Now, you need to make your second transaction using only the days <em>after</em> day <code>i</code>.</p><ul><li>This means you buy on some day <code>b2 > i</code> and sell on some day <code>s2 >= b2</code>.</li><li>The best you could do for this second transaction happening after day <code>i</code> is <code>MaxProfit(prices[i+1...n-1])</code>. Let&rsquo;s call this <code>Profit2_starting_after_i</code>.</li></ul><p>If we split the entire process at day <code>i</code> (meaning the first transaction finishes by day <code>i</code>, and the second starts after day <code>i</code>), the total profit for this specific split point <code>i</code> would be:
<code>TotalProfit(split at i) = Profit1_ending_at_i + Profit2_starting_after_i</code></p><p>The Problem: We don&rsquo;t know the best day <code>i</code> to split the timeline. So, we need to calculate this <code>TotalProfit(split at i)</code> for every possible split day <code>i</code> (from <code>i=0</code> to <code>i=n-1</code>) and take the maximum among them.</p><h3 id=how-to-calculate-efficiently>How to Calculate Efficiently?</h3><p>Calculating <code>Profit1_ending_at_i</code> and <code>Profit2_starting_after_i</code> from scratch for every <code>i</code> is slow (O(n2)). We need to precompute or compute iteratively.</p><p><strong>Step 1: Calculate all <code>Profit1_ending_at_i</code> values.</strong></p><ul><li>Notice that <code>Profit1_ending_at_i</code> is exactly the maximum profit you can make with a single transaction within the range <code>prices[0...i]</code>.</li><li>We already know how to calculate this efficiently! It&rsquo;s the logic from the &ldquo;Buy and Sell Once&rdquo; problem (Section 5.6). We can run that algorithm once, and as we iterate through the <code>prices</code> array, we store the maximum profit found up to that point in a new array. Let&rsquo;s call this array <code>F</code> (for Forward).</li><li><code>F[i]</code> = Maximum profit from one transaction using prices from day 0 to day <code>i</code>.</li><li>This takes one pass, O(n) time, and O(n) space for the <code>F</code> array.</li></ul><p><strong>Step 2: Calculate all <code>Profit2_starting_after_i</code> values.</strong></p><ul><li>This is the maximum profit from one transaction using only prices from day <code>i+1</code> to day <code>n-1</code>.</li><li>How can we calculate this efficiently for all <code>i</code>? We can run the &ldquo;Buy and Sell Once&rdquo; logic <em>backwards</em>!</li><li>Imagine iterating from the end of the <code>prices</code> array (<code>n-1</code>) down to <code>0</code>. Keep track of the <code>max_price_seen_so_far</code> (during the backward scan). The best profit if you buy on day <code>j</code> (during this backward scan) is <code>max_price_seen_so_far - prices[j]</code>.</li><li>Let <code>B[j]</code> be the maximum profit from one transaction using prices from day <code>j</code> to day <code>n-1</code>. We can compute all <code>B[j]</code> values in a single backward pass (O(n) time). We could store this in another array <code>B</code>.</li></ul><p><strong>Step 3: Combine the Results.</strong></p><ul><li>Now we have <code>F[i]</code> (best profit ending by day <code>i</code>) and <code>B[j]</code> (best profit starting from day <code>j</code>).</li><li>The total profit for a split right after day <code>i</code> is <code>F[i] + B[i+1]</code>.</li><li>We need to calculate <code>F[i] + B[i+1]</code> for all <code>i</code> from 0 to <code>n-2</code>.</li><li>The final answer is the maximum value found in these sums.</li><li>We also need to consider the possibility that the best profit comes from only one transaction (e.g., if prices always go down after the first transaction). The best single-transaction profit over the whole period is simply <code>F[n-1]</code>. So the overall maximum is <code>max(F[n-1], max(F[i] + B[i+1] for i in 0..n-2))</code>.</li></ul><h3 id=the-books-space-optimization>The Book&rsquo;s Space Optimization:</h3><p>The book realizes we don&rsquo;t actually need to store the entire <code>B</code> array from Step 2. We can combine Step 2 and Step 3.</p><ol><li>Calculate and store the <code>F</code> array (forward pass) as described in Step 1.</li><li>Perform the backward pass (like Step 2). As you iterate backwards with index <code>i</code> (from <code>n-1</code> down to <code>1</code>):<ul><li>Calculate the maximum profit for a single transaction starting at or after day <code>i</code>. Let&rsquo;s call this <code>profit_second_tx</code>. (This is conceptually <code>B[i]</code>). You do this by keeping track of <code>max_price_so_far</code> encountered during the backward scan. <code>profit_second_tx = max(profit_if_buy_at_i, profit_if_buy_later)</code>.</li><li><strong>Immediately combine</strong>: Now that you know the best profit starting after day <code>i-1</code> (which is <code>profit_second_tx</code> you just calculated for index <code>i</code>), you can add it to the best profit ending before day <code>i</code> (which is <code>F[i-1]</code>, already calculated in the forward pass).</li><li><code>total_profit_for_split_at_i-1 = F[i-1] + profit_second_tx</code>.</li><li>Keep track of the overall maximum total profit seen across all split points considered so far.</li></ul></li></ol><h3 id=lets-retry-the-intuition-walkthrough-prices--12-11-13-9-12-8-14-13-15>Let&rsquo;s retry the Intuition Walkthrough (<code>prices = [12, 11, 13, 9, 12, 8, 14, 13, 15]</code>):</h3><ul><li><p><strong>Forward Pass</strong>: Compute <code>F = [0, 0, 2, 2, 3, 3, 6, 6, 7]</code>.</p><ul><li><code>max_total_profit</code> initially is the best single transaction profit, so <code>max_total_profit = F[8] = 7</code>.</li></ul></li><li><p><strong>Backward Pass & Combine</strong>:</p><ul><li><code>i = 8</code> (price <code>prices[8]=15</code>):<ul><li><code>max_price</code> (for range <code>[8..8]</code>) = 15.</li><li><code>profit_second_tx</code> (for range <code>[8..8]</code>) is <code>max(0, 15-15) = 0</code>.</li><li><code>total = F[7](6) + 0 = 6</code>.</li><li><code>max_total_profit = max(7, 6) = 7</code>.</li></ul></li><li><code>i = 7</code> (price <code>prices[7]=13</code>):<ul><li><code>max_price</code> (for range <code>[7..8]</code>) = <code>max(15, 13) = 15</code>.</li><li><code>profit_second_tx</code> (for range <code>[7..8]</code>) is <code>max(profit_starting_at_8=0, profit_buy_at_7=15-13=2) = 2</code>.</li><li><code>total = F[6](6) + 2 = 8</code>.</li><li><code>max_total_profit = max(7, 8) = 8</code>.</li></ul></li><li><code>i = 6</code> (price <code>prices[6]=14</code>):<ul><li><code>max_price</code> (for range <code>[6..8]</code>) = <code>max(15, 14) = 15</code>.</li><li><code>profit_second_tx</code> (for range <code>[6..8]</code>) is <code>max(profit_starting_at_7=2, profit_buy_at_6=15-14=1) = 2</code>.</li><li><code>total = F[5](3) + 2 = 5</code>.</li><li><code>max_total_profit = max(8, 5) = 8</code>.</li></ul></li><li><code>i = 5</code> (price <code>prices[5]=8</code>):<ul><li><code>max_price</code> (for range <code>[5..8]</code>) = <code>max(15, 8) = 15</code>.</li><li><code>profit_second_tx</code> (for range <code>[5..8]</code>) is <code>max(profit_starting_at_6=2, profit_buy_at_5=15-8=7) = 7</code>.</li><li><code>total = F[4](3) + 7 = 10</code>.</li><li><code>max_total_profit = max(8, 10) = 10</code>.</li></ul></li><li>&mldr; and so on.</li></ul></li></ul><p>The backward pass calculates the best profit for the second transaction on the fly and immediately combines it with the pre-calculated best profit for the first transaction ending just before it.</p><p>Think of the backward loop index <code>i</code> as defining the start day for the potential second transaction. <code>profit_second_tx</code> calculated at step <code>i</code> represents the best possible profit if your second transaction happens entirely within <code>prices[i...n-1]</code>. We add this to <code>F[i-1]</code> (best profit from first transaction ending before day <code>i</code>) to get the total profit for that specific way of splitting the two transactions. We do this for all possible start days <code>i</code> for the second transaction and find the overall maximum.</p><hr><h2 id=section-58-computing-an-alternation-page-12--pdf-page-48>Section 5.8: Computing an Alternation (Page 12 / PDF Page 48)</h2><p><strong>The Problem</strong>: You are given an array <code>A</code> of numbers. Rearrange its elements in-place to create a new array (or modify <code>A</code> directly) such that it follows an alternating pattern:
<code>A[0] &lt;= A[1] >= A[2] &lt;= A[3] >= A[4] &lt;= A[5] ...</code>
(Less-than-or-equal followed by greater-than-or-equal, repeating).</p><p><strong>Example</strong>:</p><ul><li>Input: <code>A = [3, 1, 4, 1, 5, 9, 2, 6]</code></li><li>A valid output: <code>[1, 4, 1, 5, 2, 9, 3, 6]</code> (Check: 1&lt;=4>=1&lt;=5>=2&lt;=9>=3&lt;=6) - <em>Note: 3&lt;=6 is satisfied at the end.</em></li><li>Another valid output: <code>[1, 3, 1, 4, 2, 6, 5, 9]</code></li></ul><h3 id=approach-1-sorting-simple-but-suboptimal>Approach 1: Sorting (Simple but Suboptimal)</h3><ol><li>Sort the array <code>A</code>. Example: <code>[1, 1, 2, 3, 4, 5, 6, 9]</code></li><li>Swap adjacent pairs starting from the second element. Swap <code>A[1]</code> and <code>A[2]</code>, then <code>A[3]</code> and <code>A[4]</code>, then <code>A[5]</code> and <code>A[6]</code>, etc.<ul><li>Swap <code>A[1](1)</code> and <code>A[2](2)</code> -> <code>[1, 2, 1, 3, 4, 5, 6, 9]</code></li><li>Swap <code>A[3](3)</code> and <code>A[4](4)</code> -> <code>[1, 2, 1, 4, 3, 5, 6, 9]</code></li><li>Swap <code>A[5](5)</code> and <code>A[6](6)</code> -> <code>[1, 2, 1, 4, 3, 6, 5, 9]</code></li></ul></li><li>Check the result: <code>1&lt;=2>=1&lt;=4>=3&lt;=6>=5&lt;=9</code>. It works!</li></ol><ul><li><strong>Complexity</strong>: Dominated by the sort step.<ul><li>Time: O(n log n).</li><li>Space: O(1) if using an in-place sort, or O(n) otherwise.</li></ul></li></ul><h3 id=approach-2-median-finding-mentioned-but-not-fully-explored>Approach 2: Median Finding (Mentioned, but not fully explored)</h3><ol><li>Find the median element of the array <code>A</code> (using an O(n) median-of-medians algorithm, like in Problem 11.8).</li><li>Partition the array around the median (like one step of Quicksort or using Dutch Flag) so elements smaller than the median are first, then elements equal to the median, then elements larger. This takes O(n) time.</li><li>Interleave elements from the lower half and the upper half, similar to the swapping pattern in Approach 1.</li></ol><ul><li><strong>Complexity</strong>: Dominated by median finding and partitioning.<ul><li>Time: O(n).</li><li>Space: O(1).</li></ul></li><li>This is theoretically optimal time, but the median-of-medians algorithm is complex to implement.</li></ul><h3 id=approach-3-the-clever-local-swap-efficient-and-simple>Approach 3: The Clever Local Swap (Efficient and Simple)</h3><p><strong>Key Insight</strong>: The required property (<code>A[i-1] &lt;= A[i] >= A[i+1]</code> or <code>A[i-1] >= A[i] &lt;= A[i+1]</code>) is very local. It only involves adjacent elements. We don&rsquo;t necessarily need the global order provided by sorting or median finding.</p><p>The Goal: Arrange the array so it goes &ldquo;up, down, up, down&mldr;&rdquo; like this:
<code>Small &lt;= Big >= Small &lt;= Big >= Small ...</code></p><p>The Rule We Need:</p><ul><li>At every <strong>even</strong> index <code>i</code>, we need <code>A[i] &lt;= A[i+1]</code>.</li><li>At every <strong>odd</strong> index <code>i</code>, we need <code>A[i] >= A[i+1]</code>.</li></ul><h3 id=the-local-swap-algorithm>The Local Swap Algorithm:</h3><p>We walk through the array, looking at pairs <code>(A[i], A[i+1])</code>. We force the local rule to be true for that pair.</p><ol><li><p><strong>Look at <code>(A[0], A[1])</code> (<code>i=0</code>, which is even):</strong></p><ul><li>Rule: We need <code>A[0] &lt;= A[1]</code>.</li><li>If it&rsquo;s already true, great, do nothing.</li><li>If <code>A[0] > A[1]</code>, swap them. Now <code>A[0] &lt;= A[1]</code> is true for this pair.</li></ul></li><li><p><strong>Look at <code>(A[1], A[2])</code> (<code>i=1</code>, which is odd):</strong></p><ul><li>Rule: We need <code>A[1] >= A[2]</code>.</li><li>If it&rsquo;s true, do nothing.</li><li>If <code>A[1] &lt; A[2]</code>, swap them. Now <code>A[1] >= A[2]</code> is true for this pair.</li></ul></li><li><p><strong>Look at <code>(A[2], A[3])</code> (<code>i=2</code>, which is even):</strong></p><ul><li>Rule: We need <code>A[2] &lt;= A[3]</code>.</li><li>If <code>A[2] > A[3]</code>, swap them. Now <code>A[2] &lt;= A[3]</code> is true.
&mldr;and so on.</li></ul></li></ol><h3 id=why-doesnt-enforcing-the-rule-at-step-i-break-the-rule-we-just-fixed-at-step-i-1>Why Doesn&rsquo;t Enforcing the Rule at Step <code>i</code> Break the Rule We Just Fixed at Step <code>i-1</code>?</h3><p>This is the core confusion. Let&rsquo;s trace carefully. We need to check the condition involving <code>A[i]</code> in both the step <code>i-1</code> comparison and the step <code>i</code> comparison.</p><p>Consider index <code>i</code>. It&rsquo;s involved in two checks:</p><ul><li>Check at step <code>i-1</code>: Compares <code>(A[i-1], A[i])</code>.</li><li>Check at step <code>i</code>: Compares <code>(A[i], A[i+1])</code>.</li></ul><p>Let&rsquo;s analyze the transition at index <code>i</code> when we process step <code>i</code>.</p><p><strong>Case 1: <code>i</code> is EVEN.</strong></p><ul><li>The rule we enforce at step <code>i</code>: We ensure <code>A[i] &lt;= A[i+1]</code> (by swapping if needed).</li><li>What about the rule from step <code>i-1</code>? Step <code>i-1</code> was ODD. The rule enforced there was <code>A[i-1] >= A[i]</code>.</li><li>Does enforcing <code>A[i] &lt;= A[i+1]</code> break <code>A[i-1] >= A[i]</code>?<ul><li><strong>If we didn&rsquo;t swap at step <code>i</code></strong> (because <code>A[i] &lt;= A[i+1]</code> was already true): No problem, the previous condition <code>A[i-1] >= A[i]</code> still holds (we didn&rsquo;t change <code>A[i]</code> or <code>A[i-1]</code>).</li><li><strong>If we did swap at step <code>i</code></strong> (because <code>A[i] > A[i+1]</code> initially): Let the original values be <code>Old_A[i]</code> and <code>Old_A[i+1]</code>. We know <code>Old_A[i] > Old_A[i+1]</code>. The new value at <code>A[i]</code> is <code>New_A[i] = Old_A[i+1]</code>. The condition from step <code>i-1</code> was <code>A[i-1] >= Old_A[i]</code>. Since <code>Old_A[i] > Old_A[i+1] = New_A[i]</code>, it follows that <code>A[i-1] > New_A[i]</code>. So, the required condition <code>A[i-1] >= New_A[i]</code> <strong>still holds</strong>! Swapping in a smaller value at <code>A[i]</code> cannot break the previous <code>A[i-1] >= A[i]</code> condition.</li></ul></li></ul><p><strong>Case 2: <code>i</code> is ODD.</strong></p><ul><li>The rule we enforce at step <code>i</code>: We ensure <code>A[i] >= A[i+1]</code> (by swapping if needed).</li><li>What about the rule from step <code>i-1</code>? Step <code>i-1</code> was EVEN. The rule enforced there was <code>A[i-1] &lt;= A[i]</code>.</li><li>Does enforcing <code>A[i] >= A[i+1]</code> break <code>A[i-1] &lt;= A[i]</code>?<ul><li><strong>If we didn&rsquo;t swap at step <code>i</code></strong> (because <code>A[i] >= A[i+1]</code> was already true): No problem.</li><li><strong>If we did swap at step <code>i</code></strong> (because <code>A[i] &lt; A[i+1]</code> initially): Let the original values be <code>Old_A[i]</code> and <code>Old_A[i+1]</code>. We know <code>Old_A[i] &lt; Old_A[i+1]</code>. The new value at <code>A[i]</code> is <code>New_A[i] = Old_A[i+1]</code>. The condition from step <code>i-1</code> was <code>A[i-1] &lt;= Old_A[i]</code>. Since <code>Old_A[i] &lt; Old_A[i+1] = New_A[i]</code>, it follows that <code>A[i-1] &lt; New_A[i]</code>. So, the required condition <code>A[i-1] &lt;= New_A[i]</code> <strong>still holds</strong>! Swapping in a larger value at <code>A[i]</code> cannot break the previous <code>A[i-1] &lt;= A[i]</code> condition.</li></ul></li></ul><p><strong>Conclusion</strong>: Enforcing the rule for the pair <code>(A[i], A[i+1])</code> <strong>preserves</strong> the rule that was already established for the pair <code>(A[i-1], A[i])</code> in the previous step. Since we process the array from left to right, by the time we reach the end, all adjacent pairs satisfy their respective conditions (<code>&lt;=</code> for even <code>i</code>, <code>>=</code> for odd <code>i</code>), fulfilling the overall alternation requirement.</p><h3 id=analogy-smoothing-out-bumps>Analogy: Smoothing Out Bumps</h3><p>Imagine the numbers are heights. You want a profile like <code>low &lt;= high >= low &lt;= high ...</code></p><p>You walk along the profile, looking at two adjacent points <code>i</code> and <code>i+1</code>.</p><ul><li>If <code>i</code> should be a &ldquo;low&rdquo; point (<code>i</code> is even), but <code>A[i]</code> is higher than <code>A[i+1]</code>, you swap them to push the high point to <code>i+1</code>. This makes <code>A[i]</code> lower, which doesn&rsquo;t violate any preceding &ldquo;high >= low&rdquo; condition.</li><li>If <code>i</code> should be a &ldquo;high&rdquo; point (<code>i</code> is odd), but <code>A[i]</code> is lower than <code>A[i+1]</code>, you swap them to pull the high point to <code>i</code>. This makes <code>A[i]</code> higher, which doesn&rsquo;t violate any preceding &ldquo;low &lt;= high&rdquo; condition.</li></ul><hr><h2 id=section-59-enumerate-all-primes-to-n-page-13--pdf-page-49>Section 5.9: Enumerate All Primes to n (Page 13 / PDF Page 49)</h2><p><strong>The Problem</strong>: Given an integer <code>n</code>, return a list of all prime numbers between 1 and <code>n</code> (inclusive).</p><p><strong>Prime Number Definition</strong>: A natural number <code>p</code> is prime if it is greater than 1 and has no divisors other than 1 and itself. (2, 3, 5, 7, 11, 13, 17, 19&mldr; are primes). 1 is not prime.</p><p><strong>Example</strong>:</p><ul><li>Input: <code>n = 18</code></li><li>Output: <code>[2, 3, 5, 7, 11, 13, 17]</code></li></ul><h3 id=approach-1-trial-division-brute-force>Approach 1: Trial Division (Brute-Force)</h3><ol><li>Iterate through each number <code>i</code> from 2 up to <code>n</code>.</li><li>For each <code>i</code>, check if it&rsquo;s prime.<ul><li><strong>How to check if <code>i</code> is prime?</strong> Try dividing <code>i</code> by every number <code>d</code> from 2 up to <code>sqrt(i)</code>.<ul><li>If you find any <code>d</code> that divides <code>i</code> evenly (<code>i % d == 0</code>), then <code>i</code> is not prime. Stop checking for this <code>i</code> and move to the next <code>i</code>.</li><li>If you check all <code>d</code> up to <code>sqrt(i)</code> and find no divisors, then <code>i</code> is prime.</li></ul></li></ul></li><li>If <code>i</code> is found to be prime, add it to your results list.</li></ol><ul><li><p><strong>Why only check up to <code>sqrt(i)</code>?</strong> If <code>i</code> has a divisor <code>d</code> larger than <code>sqrt(i)</code>, then <code>i = d * k</code>. For this equation to hold, <code>k</code> must be smaller than <code>sqrt(i)</code>. So, if <code>i</code> has any divisor other than 1 and itself, it must have at least one divisor less than or equal to its square root.</p></li><li><p><strong>Complexity</strong>: Checking if a single number <code>i</code> is prime takes roughly O(sqrt(i)) time. Doing this for all numbers from 2 to <code>n</code> gives a total time complexity around O(n * sqrt(n)) or O(n1.5). Space is O(p) where <code>p</code> is the number of primes found, roughly O(n/log n).</p></li></ul><h3 id=approach-2-sieve-of-eratosthenes-much-more-efficient>Approach 2: Sieve of Eratosthenes (Much More Efficient)</h3><p>This is the classic algorithm for finding all primes up to <code>n</code>. It avoids redundant checks by eliminating multiples.</p><p><strong>The Idea</strong>:</p><ol><li>Start with a list (or boolean array) representing all numbers from 0 up to <code>n</code>. Initially, mark all numbers from 2 to <code>n</code> as potentially prime (e.g., <code>True</code>). Mark 0 and 1 as not prime (<code>False</code>).</li><li>Find the first number <code>p</code> in the list (starting from 2) that is still marked as potentially prime.</li><li>This number <code>p</code> <strong>must be prime</strong> (because if it had a smaller divisor, that divisor would have been found earlier, and <code>p</code> would have already been marked as not prime). Add <code>p</code> to your list of primes.</li><li><strong>Sieve</strong>: Mark all multiples of <code>p</code> (i.e., <code>2*p</code>, <code>3*p</code>, <code>4*p</code>, &mldr;) up to <code>n</code> as not prime (<code>False</code>) in your boolean array. They cannot be prime because they have <code>p</code> as a divisor.</li><li>Repeat from step 2: Find the next number in the list greater than <code>p</code> that is still marked as potentially prime, and repeat the sieving process.</li><li>Continue until you have checked numbers up to <code>n</code>.</li></ol><p><strong>Sieve Optimization 1</strong>: When sieving multiples of prime <code>p</code>, you can start marking from <code>p*p</code> (p2). Why? Any smaller multiple <code>k*p</code> where <code>k &lt; p</code> would have already been marked as not prime when you processed the prime factors of <code>k</code>.</p><p><strong>Sieve Optimization 2</strong>: You only need to find primes <code>p</code> up to <code>sqrt(n)</code> to perform the sieving. Any composite number <code>c &lt;= n</code> must have a prime factor less than or equal to <code>sqrt(n)</code>. If <code>c</code> hasn&rsquo;t been marked off by the time you reach <code>sqrt(n)</code>, it must be prime itself.</p><h3 id=the-old-way-trial-division>The Old Way (Trial Division):</h3><ul><li>Is 2 prime? Yes.</li><li>Is 3 prime? Yes.</li><li>Is 4 prime? No (divisible by 2).</li><li>Is 5 prime? Yes.</li><li>Is 6 prime? No (divisible by 2).</li><li>Is 7 prime? Yes.</li><li>Is 8 prime? No (divisible by 2).</li><li>Is 9 prime? No (divisible by 3).
&mldr; This is slow because we check 9 for divisibility by 3 even though we already knew 3 was prime and could have somehow used that information.</li></ul><h3 id=the-sieve-idea-be-proactive>The Sieve Idea: Be Proactive!</h3><p>Instead of checking each number individually, when we find a prime number, let&rsquo;s immediately cross out all of its multiples because we know they cannot be prime.</p><p><strong>Steps for n = 20:</strong></p><ol><li><p><strong>List all numbers</strong>: Write down all numbers from 2 up to 20. Imagine we have little flags (or boolean values) next to them, initially all set to &ldquo;potentially prime&rdquo; (True).
<code>[ (2,T), (3,T), (4,T), (5,T), (6,T), (7,T), (8,T), (9,T), (10,T), (11,T), (12,T), (13,T), (14,T), (15,T), (16,T), (17,T), (18,T), (19,T), (20,T) ]</code></p></li><li><p><strong>Find the first number <code>p</code> that is marked True</strong>: Start from the beginning. The first number marked True is <code>p = 2</code>.</p><ul><li><strong>Action</strong>: We know 2 is prime (it&rsquo;s the first one we found). Add 2 to our prime list: <code>Primes = [2]</code>.</li><li><strong>Sieve Action</strong>: Now, cross out (mark as False) all multiples of 2 in our list (4, 6, 8, 10, 12, 14, 16, 18, 20).</li><li>List becomes: <code>[ (2,T), (3,T), (4,F), (5,T), (6,F), (7,T), (8,F), (9,T), (10,F), (11,T), (12,F), (13,T), (14,F), (15,T), (16,F), (17,T), (18,F), (19,T), (20,F) ]</code></li></ul></li><li><p><strong>Find the next number <code>p</code> (after the previous <code>p=2</code>) that is marked True</strong>: Looking through the list, the next True is at <code>p = 3</code>.</p><ul><li><strong>Action</strong>: We know 3 must be prime (because if it had a smaller prime factor, it would have been crossed out in a previous step - the only smaller prime was 2, and 3 isn&rsquo;t a multiple of 2). Add 3 to our prime list: <code>Primes = [2, 3]</code>.</li><li><strong>Sieve Action</strong>: Cross out all multiples of 3 (starting from 3*2=6, though 6 is already False. Next is 3*3=9, then 3*4=12(F), 3*5=15, 3*6=18(F)).</li><li>List becomes: <code>[ (2,T), (3,T), (4,F), (5,T), (6,F), (7,T), (8,F), (9,F), (10,F), (11,T), (12,F), (13,T), (14,F), (15,F), (16,F), (17,T), (18,F), (19,T), (20,F) ]</code></li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=3</code>) that is marked True</strong>: The next True is at <code>p = 5</code>.</p><ul><li><strong>Action</strong>: 5 must be prime. Add 5 to list: <code>Primes = [2, 3, 5]</code>.</li><li><strong>Sieve Action</strong>: Cross out multiples of 5 (5*2=10(F), 5*3=15(F), 5*4=20(F)). No changes needed as they were already False.</li><li>List remains the same.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=5</code>) that is marked True</strong>: The next True is at <code>p = 7</code>.</p><ul><li><strong>Action</strong>: 7 must be prime. Add 7 to list: <code>Primes = [2, 3, 5, 7]</code>.</li><li><strong>Sieve Action</strong>: Cross out multiples of 7 (7*2=14(F)). No changes.</li><li>List remains the same.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=7</code>) that is marked True</strong>: The next True is at <code>p = 11</code>.</p><ul><li><strong>Action</strong>: 11 must be prime. Add 11 to list: <code>Primes = [2, 3, 5, 7, 11]</code>.</li><li><strong>Sieve Action</strong>: Cross out multiples of 11 (11*2=22, which is > 20). No changes.</li><li>List remains the same.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=11</code>) that is marked True</strong>: The next True is at <code>p = 13</code>.</p><ul><li><strong>Action</strong>: 13 must be prime. Add 13: <code>Primes = [2, 3, 5, 7, 11, 13]</code>.</li><li><strong>Sieve Action</strong>: Multiples are > 20.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=13</code>) that is marked True</strong>: The next True is at <code>p = 17</code>.</p><ul><li><strong>Action</strong>: 17 must be prime. Add 17: <code>Primes = [2, 3, 5, 7, 11, 13, 17]</code>.</li><li><strong>Sieve Action</strong>: Multiples are > 20.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=17</code>) that is marked True</strong>: The next True is at <code>p = 19</code>.</p><ul><li><strong>Action</strong>: 19 must be prime. Add 19: <code>Primes = [2, 3, 5, 7, 11, 13, 17, 19]</code>.</li><li><strong>Sieve Action</strong>: Multiples are > 20.</li></ul></li><li><p><strong>Find the next number <code>p</code> (after <code>p=19</code>) that is marked True</strong>: There are none left up to <code>n=20</code>. We are done.</p></li></ol><p>The Final Prime List: <code>[2, 3, 5, 7, 11, 13, 17, 19]</code>.</p><p><strong>Why is this efficient?</strong></p><ul><li>We only &ldquo;process&rdquo; (find multiples of) the actual prime numbers (2, 3, 5, 7, etc.).</li><li>We touch each composite number (like 4, 6, 8, 9, 10, 12&mldr;) only when we cross it out as a multiple of one of its prime factors. We don&rsquo;t waste time trying to see if 12 is divisible by 4, 5, 6, etc., because it was already crossed out when we processed prime 2 (and again for prime 3).</li></ul><p><strong>The Optimization (Sieving from <code>p*p</code>)</strong>
Let&rsquo;s look at step 3 again, when <code>p=3</code>. We crossed out 6, 9, 12, 15, 18.
Notice that 6 was already crossed out when we processed <code>p=2</code>. Why? Because 6 = 2 * 3. The factor <code>k=2</code> is less than <code>p=3</code>.
In general, when processing prime <code>p</code>, any multiple <code>k * p</code> where <code>k &lt; p</code> has already been crossed out by the prime factors of <code>k</code> (which are all smaller than <code>p</code>).
So, the first multiple of <code>p</code> that we really need to worry about crossing out is <code>p * p</code>.</p><ul><li>For <code>p=3</code>, we start crossing out from <code>3*3 = 9</code>.</li><li>For <code>p=5</code>, we start crossing out from <code>5*5 = 25</code> (which is > 20, so we do nothing).</li><li>For <code>p=7</code>, we start from <code>7*7=49</code> (> 20).
This optimization saves some redundant work.</li></ul><p><strong>The Boolean Array (<code>is_prime</code>)</strong>
In the code, instead of a list of pairs like <code>(2, T)</code>, we use a simple boolean array (a list of <code>True</code>/<code>False</code> values). The index of the array represents the number.
<code>is_prime = [False, False, True, True, True, ... True]</code> (up to index <code>n</code>)</p><ul><li>When we process <code>p=2</code>, we loop <code>for i in range(p*p, n+1, p): is_prime[i] = False</code>.</li><li>When we process <code>p=3</code>, we loop <code>for i in range(p*p, n+1, p): is_prime[i] = False</code>.
And so on.</li></ul><hr><h2 id=section-510-permute-the-elements-of-an-array-page-14--pdf-page-50>Section 5.10: Permute the Elements of an Array (Page 14 / PDF Page 50)</h2><p><strong>The Problem</strong>: You are given an array <code>A</code> of <code>n</code> elements, and a permutation array <code>P</code> of length <code>n</code>. The permutation array <code>P</code> describes how to rearrange <code>A</code>: for each index <code>i</code>, the element currently at <code>A[i]</code> should be moved to position <code>P[i]</code>. You need to apply this permutation to array <code>A</code> <strong>in-place</strong> (O(1) extra space).</p><p><strong>Example</strong>:</p><ul><li><code>A = [a, b, c, d]</code></li><li><code>P = [2, 0, 1, 3]</code></li></ul><p><strong>Interpretation of P</strong>:</p><ul><li>Element at index 0 (<code>a</code>) moves to index <code>P[0]=2</code>.</li><li>Element at index 1 (<code>b</code>) moves to index <code>P[1]=0</code>.</li><li>Element at index 2 (<code>c</code>) moves to index <code>P[2]=1</code>.</li><li>Element at index 3 (<code>d</code>) moves to index <code>P[3]=3</code>.</li></ul><p><strong>Desired Result</strong>: <code>A</code> should become <code>[b, c, a, d]</code>.</p><h3 id=approach-1-using-extra-space-simple-but-not-in-place>Approach 1: Using Extra Space (Simple but Not In-Place)</h3><ol><li>Create a new array <code>B</code> of the same size as <code>A</code>.</li><li>Iterate through <code>A</code> from <code>i = 0</code> to <code>n-1</code>.</li><li>For each element <code>A[i]</code>, place it in its target position in <code>B</code>: <code>B[P[i]] = A[i]</code>.</li><li>Copy the contents of <code>B</code> back into <code>A</code>.</li></ol><ul><li><strong>Complexity</strong>:<ul><li>Time: O(n) (for the iteration and copy).</li><li>Space: O(n) (for the auxiliary array <code>B</code>).</li></ul></li><li><strong>Issue</strong>: Doesn&rsquo;t meet the O(1) space requirement.</li></ul><h3 id=approach-2-in-place-permutation-using-cycles>Approach 2: In-Place Permutation using Cycles</h3><p><strong>Key Insight</strong>: Any permutation can be broken down into one or more disjoint cycles.</p><ul><li>A cycle means that element at index <code>i0</code> moves to <code>i1</code>, element at <code>i1</code> moves to <code>i2</code>, &mldr;, element at <code>ik-1</code> moves to <code>ik</code>, and element at <code>ik</code> moves back to <code>i0</code>.</li></ul><p>In our example <code>P = [2, 0, 1, 3]</code>:</p><ul><li>Start at index 0: Element <code>a</code> moves to index 2 (<code>P[0]=2</code>).</li><li>Look at index 2: Element <code>c</code> moves to index 1 (<code>P[2]=1</code>).</li><li>Look at index 1: Element <code>b</code> moves to index 0 (<code>P[1]=0</code>).</li><li>We&rsquo;re back at index 0. This forms the cycle <code>0 -> 2 -> 1 -> 0</code>.</li><li>Start at index 3 (the next unvisited index): Element <code>d</code> moves to index 3 (<code>P[3]=3</code>). This is a cycle of length 1: <code>3 -> 3</code>.
The permutation <code>P</code> consists of two cycles: <code>(0 2 1)</code> and <code>(3)</code>.</li></ul><p><strong>Algorithm Idea</strong>: If we can process one cycle at a time, we can do it in place.</p><ol><li>Iterate through the array <code>A</code> from <code>i = 0</code> to <code>n-1</code>.</li><li>For each index <code>i</code>, check if the element at this position has already been moved as part of a previous cycle. If it has, skip it.</li><li>If the element at <code>i</code> hasn&rsquo;t been moved, we&rsquo;ve found the start of a new cycle. Process this cycle:<ul><li>Remember the starting index <code>start = i</code> and the value <code>temp = A[start]</code>.</li><li><em>Easier cycle traversal</em>:<ul><li>Store the element you&rsquo;re about to overwrite: <code>value_to_move = A[i]</code>.</li><li>Follow the cycle: <code>curr = i</code>.</li><li>Loop:<ul><li><code>next_idx = P[curr]</code>.</li><li>Save the element at the destination: <code>next_value = A[next_idx]</code>.</li><li>Move the <code>value_to_move</code> to the destination: <code>A[next_idx] = value_to_move</code>.</li><li>Update <code>curr = next_idx</code>.</li><li>Update <code>value_to_move = next_value</code>.</li><li>Mark the position <code>curr</code> (or maybe <code>P[curr]</code>) as visited so we don&rsquo;t process this cycle again.</li><li>Stop when <code>curr</code> gets back to the starting index <code>i</code>.</li></ul></li></ul></li></ul></li></ol><p><strong>How to Mark Visited Cycles without O(n) Space?</strong>
This is the clever trick. We can modify the permutation array <code>P</code> itself to mark elements that have been processed. The book suggests subtracting <code>n</code> (or using the sign bit if possible) from <code>P[i]</code> after its corresponding element <code>A[i]</code> has been placed correctly.</p><h3 id=the-cycle-idea-follow-one-element-all-the-way>The Cycle Idea: Follow One Element All the Way</h3><p>Let&rsquo;s pick an element and follow its journey until it lands in its final spot, and see where the element it displaced needs to go, and so on.</p><p>Let&rsquo;s trace starting with index <code>i = 0</code>:</p><ol><li>Element: <code>A[0]</code> is &lsquo;a&rsquo;.</li><li>Destination: Where should &lsquo;a&rsquo; go? <code>P[0]</code> tells us it goes to index 2.</li><li>Problem: Index 2 currently holds &lsquo;c&rsquo;. We can&rsquo;t just overwrite &lsquo;c&rsquo;.</li><li>Solution: Before moving &lsquo;a&rsquo; to index 2, let&rsquo;s save &lsquo;c&rsquo; somewhere temporarily. Let <code>temp = 'c'</code>.</li><li>Move &lsquo;a&rsquo;: Now, put &lsquo;a&rsquo; into <code>A[2]</code>. The array <code>A</code> is now <code>['a', 'b', 'a', 'd']</code>. (We still have &lsquo;c&rsquo; saved in <code>temp</code>).</li><li>Where does &lsquo;c&rsquo; go? &lsquo;c&rsquo; originally came from index 2. According to <code>P</code>, the element from index 2 should go to index <code>P[2] = 1</code>.</li><li>Problem: Index 1 currently holds &lsquo;b&rsquo;.</li><li>Solution: Save &lsquo;b&rsquo;. Let <code>temp = 'b'</code>.</li><li>Move &lsquo;c&rsquo;: Put &lsquo;c&rsquo; (which we saved way back in step 4) into <code>A[1]</code>. Array <code>A</code> is now <code>['a', 'c', 'a', 'd']</code>. (We have &lsquo;b&rsquo; saved in <code>temp</code>).</li><li>Where does &lsquo;b&rsquo; go? &lsquo;b&rsquo; originally came from index 1. According to <code>P</code>, the element from index 1 should go to index <code>P[1] = 0</code>.</li><li>Problem: Index 0 currently holds &lsquo;a&rsquo;.</li><li>Solution: Save &lsquo;a&rsquo;. Let <code>temp = 'a'</code>.</li><li>Move &lsquo;b&rsquo;: Put &lsquo;b&rsquo; (saved in step 8) into <code>A[0]</code>. Array <code>A</code> is now <code>['b', 'c', 'a', 'd']</code>. (We have &lsquo;a&rsquo; saved in <code>temp</code>).</li><li>Where does &lsquo;a&rsquo; go? This &lsquo;a&rsquo; originally came from index 0. We followed the path <code>0 -> 2 -> 1 -> 0</code>. We are back where we started! This &lsquo;a&rsquo; we saved in step 12 is the one we started with. Since we&rsquo;re back at the start, the cycle is complete. We don&rsquo;t need to place this saved &lsquo;a&rsquo;; it&rsquo;s already implicitly handled because the element now at index 0 (&lsquo;b&rsquo;) is correct.</li></ol><p>We&rsquo;ve just processed the cycle <code>0 -> 2 -> 1 -> 0</code>! The array <code>A</code> is now <code>['b', 'c', 'a', 'd']</code>.</p><p>How do we know we are done? We need to check other starting points.</p><ul><li>Let&rsquo;s trace starting with index <code>i = 1</code>:<ul><li>We need a way to know if index 1 was already handled. If we followed the cycle correctly above, index 1 was involved. We need a mechanism to remember this.</li></ul></li><li>Let&rsquo;s trace starting with index <code>i = 3</code>:<ul><li>Assume index 3 hasn&rsquo;t been handled yet.</li><li>Element: <code>A[3]</code> is &rsquo;d&rsquo;.</li><li>Destination: <code>P[3]</code> tells us it goes to index 3.</li><li>It&rsquo;s already there! This is a cycle of length 1: <code>3 -> 3</code>. We don&rsquo;t need to do anything.</li></ul></li></ul><h3 id=putting-it-together--the-marking-trick>Putting it Together & The &ldquo;Marking&rdquo; Trick:</h3><p>The process above shows how a cycle works with temporary variables. The challenge is doing it without explicitly using lots of temp variables (just one is needed at a time) and knowing which cycles have been completed.
This is where modifying the <code>perm</code> array comes in (or using a <code>visited</code> array). We mark <code>perm[k]</code> by making it negative after we&rsquo;ve moved the element originally at <code>A[k]</code> to its correct spot.</p><p><em>My previous manual trace using the book&rsquo;s code swap logic was slightly off. The core idea of the book&rsquo;s code <em>is</em> to complete a cycle correctly.</em></p><p><strong>Corrected Trace (Using Book&rsquo;s Code Logic - <code>A[next_idx], A[target_idx] = A[target_idx], A[next_idx]</code>):</strong></p><ul><li><p><strong>Initial State</strong>: <code>A = ['a', 'b', 'c', 'd']</code>, <code>perm = [2, 0, 1, 3]</code></p></li><li><p><strong>Outer loop: <code>i = 0</code></strong></p><ul><li><code>next_idx = 0</code>. <code>perm[0]</code> (2) <code>>= 0</code>. Enter <code>while</code>.<ul><li><code>target_idx = perm[0] = 2</code>.</li><li>Swap <code>A[0]</code> (&lsquo;a&rsquo;) and <code>A[target_idx]</code> (<code>A[2]</code> which is &lsquo;c&rsquo;). <code>A</code> becomes <code>['c', 'b', 'a', 'd']</code>.</li><li><code>temp = perm[0]</code> (which is <code>2</code>).</li><li>Mark <code>perm[0]</code>: <code>perm[0] = 2 - 4 = -2</code>. <code>perm</code> is now <code>[-2, 0, 1, 3]</code>.</li><li><code>next_idx = temp = 2</code>.</li></ul></li><li><code>perm[2]</code> (1) <code>>= 0</code>. Continue <code>while</code>.<ul><li><code>target_idx = perm[2] = 1</code>.</li><li>Swap <code>A[next_idx]</code> (<code>A[2]</code> which is &lsquo;a&rsquo;) and <code>A[target_idx]</code> (<code>A[1]</code> which is &lsquo;b&rsquo;). <code>A</code> becomes <code>['c', 'a', 'b', 'd']</code>.</li><li><code>temp = perm[2]</code> (which is <code>1</code>).</li><li>Mark <code>perm[2]</code>: <code>perm[2] = 1 - 4 = -3</code>. <code>perm</code> is now <code>[-2, 0, -3, 3]</code>.</li><li><code>next_idx = temp = 1</code>.</li></ul></li><li><code>perm[1]</code> (0) <code>>= 0</code>. Continue <code>while</code>.<ul><li><code>target_idx = perm[1] = 0</code>.</li><li>Swap <code>A[next_idx]</code> (<code>A[1]</code> which is &lsquo;a&rsquo;) and <code>A[target_idx]</code> (<code>A[0]</code> which is &lsquo;c&rsquo;). <code>A</code> becomes <code>['a', 'c', 'b', 'd']</code>.</li><li><code>temp = perm[1]</code> (which is <code>0</code>).</li><li>Mark <code>perm[1]</code>: <code>perm[1] = 0 - 4 = -4</code>. <code>perm</code> is now <code>[-2, -4, -3, 3]</code>.</li><li><code>next_idx = temp = 0</code>.</li></ul></li><li><code>perm[0]</code> (-2) <code>&lt; 0</code>. Exit <code>while</code> loop.</li></ul></li><li><p><strong>Outer loop: <code>i = 1</code></strong></p><ul><li><code>perm[1]</code> (-4) is negative. Skip <code>while</code> loop. (This index was part of the cycle we just processed).</li></ul></li><li><p><strong>Outer loop: <code>i = 2</code></strong></p><ul><li><code>perm[2]</code> (-3) is negative. Skip <code>while</code> loop.</li></ul></li><li><p><strong>Outer loop: <code>i = 3</code></strong></p><ul><li><code>next_idx = 3</code>. <code>perm[3]</code> (3) <code>>= 0</code>. Enter <code>while</code>.<ul><li><code>target_idx = perm[3] = 3</code>.</li><li>Swap <code>A[3]</code> (&rsquo;d&rsquo;) and <code>A[3]</code> (&rsquo;d&rsquo;). <code>A</code> is unchanged: <code>['a', 'c', 'b', 'd']</code>.</li><li><code>temp = perm[3]</code> (which is <code>3</code>).</li><li>Mark <code>perm[3]</code>: <code>perm[3] = 3 - 4 = -1</code>. <code>perm</code> is now <code>[-2, -4, -3, -1]</code>.</li><li><code>next_idx = temp = 3</code>.</li></ul></li><li><code>perm[3]</code> (-1) <code>&lt; 0</code>. Exit <code>while</code> loop.</li></ul></li><li><p>Outer loop finishes.</p></li><li><p>Final state for <code>A</code> is <code>['a', 'c', 'b', 'd']</code>. This trace still gives the incorrect result.</p></li></ul><p>The confusion arises from how the swaps in the book&rsquo;s code achieve the &ldquo;following an element&rdquo; logic. Let&rsquo;s use the &ldquo;pick up and carry&rdquo; mental model which is more direct.</p><p><strong>Cycle Following - Simpler View (Corrected to match desired outcome):</strong></p><p>This approach correctly gets the desired result by focusing on placing the element currently &ldquo;held&rdquo; (value) to its destination, and then picking up the element that was <em>at</em> that destination.</p><ol><li><strong>Outer loop <code>i = 0</code> to <code>n-1</code></strong>:<ul><li>If <code>perm[i]</code> is negative, this element&rsquo;s cycle is already processed. Skip.</li><li>Start a new cycle:<ul><li><code>current_cycle_idx = i</code></li><li><code>value_to_place = A[i]</code> (the element we are &ldquo;holding&rdquo;)</li><li><strong>Inner <code>do-while</code> loop (or <code>while True</code> with a break):</strong><ol><li><code>next_target_pos = perm[current_cycle_idx]</code> (where <code>value_to_place</code> should go).</li><li><code>value_at_target = A[next_target_pos]</code> (save the element currently at the target).</li><li><code>A[next_target_pos] = value_to_place</code> (place our &ldquo;held&rdquo; value).</li><li>Mark <code>perm[current_cycle_idx]</code> as processed (e.g., <code>perm[current_cycle_idx] -= len(perm)</code>).</li><li><code>current_cycle_idx = next_target_pos</code> (this is where <code>value_at_target</code> came from).</li><li><code>value_to_place = value_at_target</code> (this is the new value we are &ldquo;holding&rdquo;).</li><li>If <code>current_cycle_idx == i</code> (we&rsquo;ve returned to the start of the cycle), break the inner loop.</li></ol></li></ul></li></ul></li></ol><p>Let&rsquo;s try this view on <code>A = ['a', 'b', 'c', 'd']</code>, <code>P = [2, 0, 1, 3]</code></p><ul><li><p><strong>Outer loop <code>i = 0</code></strong>:</p><ul><li><code>perm[0]</code> (2) is not negative. Start cycle.</li><li><code>current_cycle_idx = 0</code>. <code>value_to_place = A[0] = 'a'</code>.</li><li><strong>Inner Loop 1</strong>:<ol><li><code>next_target_pos = perm[0] = 2</code>.</li><li><code>value_at_target = A[2] = 'c'</code>.</li><li><code>A[2] = 'a'</code>. <code>A</code> is <code>['a', 'b', 'a', 'd']</code>.</li><li><code>perm[0] -= 4 \implies -2</code>. <code>perm</code> is <code>[-2, 0, 1, 3]</code>.</li><li><code>current_cycle_idx = 2</code>.</li><li><code>value_to_place = 'c'</code>.</li><li><code>current_cycle_idx</code> (2) != <code>i</code> (0). Continue.</li></ol></li><li><strong>Inner Loop 2</strong>:<ol><li><code>next_target_pos = perm[2] = 1</code>.</li><li><code>value_at_target = A[1] = 'b'</code>.</li><li><code>A[1] = 'c'</code>. <code>A</code> is <code>['a', 'c', 'a', 'd']</code>.</li><li><code>perm[2] -= 4 \implies -3</code>. <code>perm</code> is <code>[-2, 0, -3, 3]</code>.</li><li><code>current_cycle_idx = 1</code>.</li><li><code>value_to_place = 'b'</code>.</li><li><code>current_cycle_idx</code> (1) != <code>i</code> (0). Continue.</li></ol></li><li><strong>Inner Loop 3</strong>:<ol><li><code>next_target_pos = perm[1] = 0</code>.</li><li><code>value_at_target = A[0] = 'a'</code>.</li><li><code>A[0] = 'b'</code>. <code>A</code> is <code>['b', 'c', 'a', 'd']</code>.</li><li><code>perm[1] -= 4 \implies -4</code>. <code>perm</code> is <code>[-2, -4, -3, 3]</code>.</li><li><code>current_cycle_idx = 0</code>.</li><li><code>value_to_place = 'a'</code>.</li><li><code>current_cycle_idx</code> (0) == <code>i</code> (0). Break inner loop. Cycle for <code>i=0</code> is complete.</li></ol></li></ul></li><li><p><strong>Outer loop <code>i = 1</code></strong>:</p><ul><li><code>perm[1]</code> (-4) is negative. Skip.</li></ul></li><li><p><strong>Outer loop <code>i = 2</code></strong>:</p><ul><li><code>perm[2]</code> (-3) is negative. Skip.</li></ul></li><li><p><strong>Outer loop <code>i = 3</code></strong>:</p><ul><li><code>perm[3]</code> (3) is not negative. Start cycle.</li><li><code>current_cycle_idx = 3</code>. <code>value_to_place = A[3] = 'd'</code>.</li><li><strong>Inner Loop 1</strong>:<ol><li><code>next_target_pos = perm[3] = 3</code>.</li><li><code>value_at_target = A[3] = 'd'</code>.</li><li><code>A[3] = 'd'</code>. <code>A</code> is <code>['b', 'c', 'a', 'd']</code>.</li><li><code>perm[3] -= 4 \implies -1</code>. <code>perm</code> is <code>[-2, -4, -3, -1]</code>.</li><li><code>current_cycle_idx = 3</code>.</li><li><code>value_to_place = 'd'</code>.</li><li><code>current_cycle_idx</code> (3) == <code>i</code> (3). Break inner loop. Cycle for <code>i=3</code> is complete.</li></ol></li></ul></li></ul><p>Done. Final <code>A</code> is <code>['b', 'c', 'a', 'd']</code>. This matches the desired result!
The key is correctly following the element you &ldquo;picked up&rdquo; and placing it, then picking up the displaced element and continuing, while marking the <em>origin index</em> in <code>P</code> as complete for that step of placing its element.
The book&rsquo;s code&rsquo;s swap <code>A[next_idx], A[target_idx] = A[target_idx], A[next_idx]</code> is actually performing this &ldquo;pick up and carry&rdquo; implicitly. The element at <code>target_idx</code> is moved to <code>next_idx</code>, and the old <code>A[next_idx]</code> is moved to <code>target_idx</code>. The <code>next_idx</code> for the next iteration then becomes the <em>original</em> <code>target_idx</code>. This is a common way to implement cycle sort.</p><hr><h2 id=section-511-compute-the-next-permutation-page-16--pdf-page-52>Section 5.11: Compute the Next Permutation (Page 16 / PDF Page 52)</h2><p><strong>The Problem</strong>: Given an array <code>perm</code> representing a permutation of numbers (e.g., <code>[1, 0, 3, 2]</code>), find the next permutation in dictionary (lexicographical) order. If the input is already the largest possible permutation (i.e., sorted in descending order, like <code>[3, 2, 1, 0]</code>), return an empty array or list.</p><p><strong>Dictionary Order</strong>: Think of the permutations as words. <code>[0, 1, 2]</code> comes before <code>[0, 2, 1]</code>, which comes before <code>[1, 0, 2]</code>, etc. We want the permutation that comes immediately after the input one in this sorted list of all permutations.</p><p><strong>Example</strong>:</p><ul><li>Input: <code>[1, 0, 3, 2]</code> -> Output: <code>[1, 2, 0, 3]</code></li><li>Input: <code>[1, 2, 0, 3]</code> -> Output: <code>[1, 2, 3, 0]</code></li><li>Input: <code>[3, 2, 1, 0]</code> -> Output: <code>[]</code> (or indication of none)</li></ul><h3 id=the-key-insight-minimizing-the-change>The Key Insight: Minimizing the Change</h3><p>We want to find the next permutation, which means we want to increase the sequence by the smallest possible amount while still making it larger.</p><p><strong>Where to Make the Change?</strong>
To make the smallest possible increase, we want to change the sequence as far to the right as possible.</p><p>Consider <code>[1, 0, 3, 2]</code>:</p><ul><li>If we only change <code>[3, 2]</code>? The only other arrangement is <code>[2, 3]</code>. This gives <code>[1, 0, 2, 3]</code>. Is this larger than the original <code>[1, 0, 3, 2]</code>? Yes (because at index 2, 2 &lt; 3).</li><li>If we only change <code>[0, 3, 2]</code>? We could rearrange these to <code>[2, 0, 3]</code>, <code>[2, 3, 0]</code>, <code>[3, 0, 2]</code>, <code>[3, 2, 0]</code>. Combined with the 1 at the start, these give <code>[1, 2, 0, 3]</code>, <code>[1, 2, 3, 0]</code>, <code>[1, 3, 0, 2]</code>, <code>[1, 3, 2, 0]</code>. All of these are larger than the original. Which one is the smallest? <code>[1, 2, 0, 3]</code>.</li></ul><p>Notice that <code>[1, 2, 0, 3]</code> seems to be the smallest possible increase we found. It involved changing the <code>0</code> at index 1.</p><p><strong>Finding the &ldquo;Pivot&rdquo; - Where the Increase Must Happen</strong>
Let&rsquo;s look at the sequence from right to left.
<code>perm = [1, 0, 3, 2]</code></p><ul><li><code>2</code>: Nothing to compare.</li><li><code>3, 2</code>: <code>3 > 2</code>. The sequence is decreasing here.</li><li><code>0, 3, 2</code>: <code>0 &lt; 3</code>. The decreasing trend is <strong>broken!</strong> This <code>0</code> at index <code>k=1</code> is important. Why? Because any rearrangement only involving the suffix <code>[3, 2]</code> will keep the <code>[1, 0]</code> prefix the same. To get a permutation larger than <code>[1, 0, 3, 2]</code> but potentially smaller than <code>[1, 0, 2, 3]</code> (which we found by rearranging only the suffix), we must change something at or before index 1. To make the smallest change, we should change the rightmost possible element, which is <code>perm[1]=0</code>.</li></ul><p>This leads to:</p><p><strong>Algorithm Steps:</strong></p><ol><li><p><strong>Find the &ldquo;pivot&rdquo; (k)</strong>:</p><ul><li>Scan the permutation <code>perm</code> from right to left. Find the first index <code>k</code> such that <code>perm[k] &lt; perm[k+1]</code>.</li><li>This <code>perm[k]</code> is the rightmost element we can increase while potentially making the resulting permutation larger than the original but as small as possible.</li><li>If no such <code>k</code> exists (the entire array is in descending order), it&rsquo;s the last permutation. Return an empty list or signal no next permutation.</li><li><em>For <code>[1, 0, 3, 2]</code>, <code>k=1</code> (where <code>perm[k]=0</code>). The suffix is <code>[3, 2]</code>.</em></li></ul></li><li><p><strong>Find the &ldquo;successor&rdquo; (l) to swap with the pivot</strong>:</p><ul><li>We need to replace <code>perm[k]</code> with something larger than it. To make the overall permutation increase by the least amount, we should replace <code>perm[k]</code> with the <em>smallest</em> possible value from the suffix <code>perm[k+1:]</code> that is <em>still greater than</em> <code>perm[k]</code>.</li><li>Scan the suffix <code>perm[k+1:]</code> from <strong>right to left</strong>. Find the first element <code>perm[l]</code> that is greater than <code>perm[k]</code>.</li><li><em>For <code>[1, 0, 3, 2]</code>, <code>perm[k]=0</code>. Suffix is <code>[3, 2]</code>. Scan from right:</em><ul><li><code>perm[3] = 2</code>. Is <code>2 > 0</code>? Yes. Found it! <code>l=3</code>. The successor value is <code>2</code>.</li></ul></li><li><em>(Why scan from the right for the successor? Because the suffix <code>perm[k+1:]</code> was identified because <code>k</code> was the first break in a descending sequence from the right. This means the suffix <code>perm[k+1:]</code> itself must be in descending order. Scanning a descending sequence from the right guarantees that the first element we find that&rsquo;s greater than the pivot is also the smallest element in that suffix that&rsquo;s greater than the pivot.)</em></li></ul></li><li><p><strong>Swap pivot and successor</strong>:</p><ul><li>Swap <code>perm[k]</code> and <code>perm[l]</code>.</li><li><em>Swap <code>perm[1](0)</code> and <code>perm[3](2)</code>. <code>perm</code> becomes <code>[1, 2, 3, 0]</code>.</em></li></ul></li><li><p><strong>Make the rest of the sequence (suffix after k) as small as possible</strong>:</p><ul><li>We&rsquo;ve now made the prefix up to index <code>k</code> (e.g., <code>[1, 2]</code>) the smallest possible <em>larger</em> prefix.</li><li>Now, we need to make the suffix (the part after index <code>k</code>, which is now <code>[3, 0]</code>) as small as possible in dictionary order to ensure this is the very next permutation.</li><li>How do you make a sequence of numbers as small as possible in dictionary order? You sort it in ascending order.</li><li>The suffix after index <code>k</code> (<code>perm[k+1:]</code>) was originally in descending order (or became so after the swap, as <code>perm[l]</code> was replaced by <code>perm[k]</code>, which is smaller than other elements in the original suffix). To sort a descending sequence into ascending order efficiently, <strong>just reverse it!</strong></li><li><em>The suffix after <code>k=1</code> is <code>[3, 0]</code>. Reversing it gives <code>[0, 3]</code>.</em></li><li><em>Attach this to the prefix: <code>[1, 2]</code> + <code>[0, 3]</code> = <code>[1, 2, 0, 3]</code>.</em> This is the final answer.</li></ul></li></ol><p><strong>Let&rsquo;s try <code>perm = [6, 2, 1, 5, 4, 3, 0]</code> again:</strong></p><ol><li><p><strong>Find k</strong>: Scan right-to-left.</p><ul><li><code>0</code></li><li><code>3 > 0</code></li><li><code>4 > 3</code></li><li><code>5 > 4</code></li><li><code>1 &lt; 5</code>. Break! <code>k=2</code> (pivot <code>perm[k]=1</code>). Suffix is <code>[5, 4, 3, 0]</code>.</li></ul></li><li><p><strong>Find l</strong>: Scan suffix <code>[5, 4, 3, 0]</code> right-to-left for first element > <code>perm[k](1)</code>.</p><ul><li><code>0 > 1</code>? No.</li><li><code>3 > 1</code>? Yes. Found it! <code>l=5</code> (index in original array, successor <code>perm[l]=3</code>).</li></ul></li><li><p><strong>Swap</strong>: Swap <code>perm[k](1)</code> and <code>perm[l](3)</code>.</p><ul><li><code>perm</code> becomes <code>[6, 2, 3, 5, 4, 1, 0]</code>.</li></ul></li><li><p><strong>Reverse suffix</strong>: Reverse the part after <code>k=2</code>, which is <code>[5, 4, 1, 0]</code>.</p><ul><li>Reversing gives <code>[0, 1, 4, 5]</code>.</li></ul></li><li><p><strong>Final Result</strong>: <code>[6, 2, 3]</code> + <code>[0, 1, 4, 5]</code> = <code>[6, 2, 3, 0, 1, 4, 5]</code>.</p></li></ol><p>This algorithm correctly finds the immediate next permutation by making the smallest necessary change to the prefix and then making the suffix as small as possible.</p><hr><h2 id=sampling-algorithms-and-their-implementation>Sampling Algorithms and their implementation</h2><p><strong>Problem</strong>: You have a bag (array <code>A</code>) with <code>n</code> distinct items. You want to pull out exactly <code>k</code> items such that every possible group of <code>k</code> items has the same chance of being selected. You do this by modifying the original array <code>A</code> so the chosen <code>k</code> items end up in the first <code>k</code> positions (<code>A[0]</code> to <code>A[k-1]</code>).</p><h3 id=analogy-picking-players-for-a-team>Analogy: Picking Players for a Team</h3><ul><li>You have <code>n</code> players lined up (<code>A[0]</code> to <code>A[n-1]</code>).</li><li>You need to form a team of <code>k</code> players.</li><li>You want the selection process to be completely fair – any group of <code>k</code> players is equally likely.</li></ul><p><strong>A Naive (But Fair) Way - Drawing Names from a Hat:</strong></p><ol><li>Write each of the <code>n</code> player names on a slip of paper.</li><li>Put all <code>n</code> slips into a hat.</li><li>Shake the hat well.</li><li>Draw out <code>k</code> slips one by one without putting them back.
This is perfectly fair. Every group of <code>k</code> names has an equal chance.</li></ol><p><strong>How can we simulate this &ldquo;drawing from a hat&rdquo; using the array <code>A</code> directly?</strong>
This is what the Offline Sampling algorithm (<code>random_sampling</code>) does. Let&rsquo;s trace it with <code>A = ['A', 'B', 'C', 'D', 'E']</code> and <code>k = 3</code>. We want to pick 3 players fairly and put them in <code>A[0]</code>, <code>A[1]</code>, <code>A[2]</code>.</p><h3 id=the-algorithm-step-by-step>The Algorithm Step-by-Step:</h3><p><strong>Goal</strong>: Fill <code>A[0]</code>, then <code>A[1]</code>, then <code>A[2]</code> with fairly chosen players.</p><p><strong>Step 1: Fill <code>A[0]</code> (<code>i=0</code>)</strong></p><ul><li><strong>Idea</strong>: We need to pick one player randomly out of the entire group (<code>A[0]</code> to <code>A[4]</code>) to put into the first team slot (<code>A[0]</code>).</li><li><strong>Action</strong>:<ol><li>Choose a random index <code>r</code> between <code>0</code> and <code>4</code> (inclusive). Let&rsquo;s say <code>random.randrange(0, 5)</code> gives <code>r = 3</code>.</li><li>Swap the player currently at <code>A[0]</code> (which is &lsquo;A&rsquo;) with the player at the random index <code>A[r]</code> (which is <code>A[3]</code>, &lsquo;D&rsquo;).</li><li><code>A</code> becomes <code>['D', 'B', 'C', 'A', 'E']</code>.</li></ol></li><li><strong>Result</strong>: <code>A[0]</code> now contains &lsquo;D&rsquo;. &lsquo;D&rsquo; was chosen uniformly from all 5 original players. We have fairly selected the first team member and placed them in the first slot. The remaining players (<code>['B', 'C', 'A', 'E']</code>) are now in slots <code>A[1]</code> to <code>A[4]</code>.</li></ul><p><strong>Step 2: Fill <code>A[1]</code> (<code>i=1</code>)</strong></p><ul><li><strong>Idea</strong>: We need to pick the second team member. This member must be chosen fairly from the players who haven&rsquo;t been picked yet. Where are the unpicked players? They are currently in the array from index <code>i=1</code> to the end (<code>A[1]</code> to <code>A[4]</code>). There are <code>n-i = 5-1 = 4</code> players remaining (&lsquo;B&rsquo;, &lsquo;C&rsquo;, &lsquo;A&rsquo;, &lsquo;E&rsquo;).</li><li><strong>Action</strong>:<ol><li>Choose a random index <code>r</code> between <code>1</code> and <code>4</code> (inclusive). Let&rsquo;s say <code>random.randrange(1, 5)</code> gives <code>r = 1</code>.</li><li>Swap the player currently at <code>A[i]</code> (which is <code>A[1]</code>, &lsquo;B&rsquo;) with the player at the random index <code>A[r]</code> (which is <code>A[1]</code>, &lsquo;B&rsquo;).</li><li><code>A</code> remains <code>['D', 'B', 'C', 'A', 'E']</code>. (Swapping with itself).</li></ol></li><li><strong>Result</strong>: <code>A[1]</code> now contains &lsquo;B&rsquo;. &lsquo;B&rsquo; was chosen uniformly from the 4 players available (B, C, A, E) after &lsquo;D&rsquo; was picked. We have fairly selected the second team member. The remaining 3 players (<code>['C', 'A', 'E']</code>) are now in slots <code>A[2]</code> to <code>A[4]</code>.</li></ul><p><strong>Step 3: Fill <code>A[2]</code> (<code>i=2</code>)</strong></p><ul><li><strong>Idea</strong>: Pick the third team member fairly from the remaining players. The available players are at indices <code>i=2</code> to the end (<code>A[2]</code> to <code>A[4]</code>). There are <code>n-i = 5-2 = 3</code> players remaining (&lsquo;C&rsquo;, &lsquo;A&rsquo;, &lsquo;E&rsquo;).</li><li><strong>Action</strong>:<ol><li>Choose a random index <code>r</code> between <code>2</code> and <code>4</code> (inclusive). Let&rsquo;s say <code>random.randrange(2, 5)</code> gives <code>r = 4</code>.</li><li>Swap the player currently at <code>A[i]</code> (which is <code>A[2]</code>, &lsquo;C&rsquo;) with the player at the random index <code>A[r]</code> (which is <code>A[4]</code>, &lsquo;E&rsquo;).</li><li><code>A</code> becomes <code>['D', 'B', 'E', 'A', 'C']</code>.</li></ol></li><li><strong>Result</strong>: <code>A[2]</code> now contains &lsquo;E&rsquo;. &lsquo;E&rsquo; was chosen uniformly from the 3 players available (C, A, E) after &lsquo;D&rsquo; and &lsquo;B&rsquo; were picked. We have fairly selected the third team member.</li></ul><p><strong>Stop</strong>: We needed <code>k=3</code> players, and we have filled <code>A[0]</code>, <code>A[1]</code>, <code>A[2]</code>.</p><p><strong>Final State</strong>: The array is <code>['D', 'B', 'E', 'A', 'C']</code>.
The <strong>Sample</strong>: The first <code>k=3</code> elements are <code>['D', 'B', 'E']</code>. This is our uniformly random sample.</p><h3 id=why-is-this-like-drawing-from-a-hat>Why is this like drawing from a hat?</h3><ul><li>At step <code>i</code>, choosing a random index <code>r</code> from <code>i</code> to <code>n-1</code> is like drawing one name randomly from the <code>n-i</code> names still left in the hat.</li><li>Swapping <code>A[i]</code> with <code>A[r]</code> is like taking the drawn name (<code>A[r]</code>) and putting it aside as the <code>i</code>-th selected player (by placing it at <code>A[i]</code>), while the name that was at <code>A[i]</code> is effectively put back into the &ldquo;remaining players&rdquo; part of the array (at index <code>r</code>) to potentially be drawn later.</li></ul><p>This process ensures that at each step <code>i</code>, every available element has an equal chance of being selected for position <code>i</code>. Over <code>k</code> steps, this builds up a sample where every possible group of <code>k</code> had an equal shot.</p><p><strong>Let&rsquo;s try a different random sequence for <code>k=2</code>, <code>A=['a','b','c','d']</code>:</strong></p><ul><li><code>i=0</code>: <code>n=4</code>. Pick <code>r</code> from <code>[0, 1, 2, 3]</code>. Say <code>r=2</code>. Swap <code>A[0]</code>(&lsquo;a&rsquo;) and <code>A[2]</code>(&lsquo;c&rsquo;). <code>A = ['c', 'b', 'a', 'd']</code>. <code>A[0]</code> is fairly chosen.</li><li><code>i=1</code>: <code>n=4</code>. Pick <code>r</code> from <code>[1, 2, 3]</code>. Say <code>r=3</code>. Swap <code>A[1]</code>(&lsquo;b&rsquo;) and <code>A[3]</code>(&rsquo;d&rsquo;). <code>A = ['c', 'd', 'a', 'b']</code>. <code>A[1]</code> is fairly chosen from the rest.</li><li>Stop. <code>k=2</code>. Sample is <code>A[0..1] = ['c', 'd']</code>.</li></ul><p>Think about filling slots <code>0</code> to <code>k-1</code>. For slot <code>i</code>, you randomly pick one element from all elements currently at or after index <code>i</code> and swap it into place.</p><hr><h2 id=section-512-sample-offline-data-page-18--pdf-page-54>Section 5.12: Sample Offline Data (Page 18 / PDF Page 54)</h2><p><strong>The Scenario</strong>: Imagine you have a large dataset (like all your customers, or all sensor readings from a day) stored in an array <code>A</code>. You want to select a smaller, random sample of size <code>k</code> from this dataset (e.g., to send a survey to, or to analyze more closely). The key requirement is that <strong>every possible subset of size <code>k</code> must have an equal chance of being selected</strong>. This is called uniform random sampling. &ldquo;Offline&rdquo; means you have the entire dataset <code>A</code> available before you start sampling.</p><p><strong>The Problem</strong>: Implement an algorithm that takes an array <code>A</code> of <code>n</code> distinct elements and an integer <code>k</code> (where <code>k &lt;= n</code>). It should rearrange <code>A</code> such that the first <code>k</code> elements (<code>A[0]</code> to <code>A[k-1]</code>) hold a uniformly random subset of the original elements of size <code>k</code>.</p><p><strong>Example</strong>:</p><ul><li>Input: <code>A = [3, 7, 5, 11]</code>, <code>k = 3</code></li><li>Possible outputs (in the first <code>k=3</code> slots): <code>[3, 7, 5]</code>, <code>[3, 5, 11]</code>, <code>[7, 3, 11]</code>, <code>[11, 5, 7]</code>, etc. Each combination of 3 elements should appear with probability 1/(4 choose 3) = 1/4. The order within the first <code>k</code> elements doesn&rsquo;t strictly matter for the subset definition, but the algorithm naturally produces a random permutation within the subset.</li></ul><p><strong>Why Not Just Pick Random Indices?</strong>
If you just pick <code>k</code> random indices between 0 and <code>n-1</code>, you might pick the same index multiple times. If you discard duplicates and retry, the process becomes complex and potentially slow (related to the Coupon Collector&rsquo;s problem), especially if <code>k</code> is close to <code>n</code>.</p><h3 id=the-efficient-in-place-algorithm-fisher-yates-shuffle-adaptation>The Efficient In-Place Algorithm (Fisher-Yates Shuffle Adaptation):</h3><p>This algorithm is elegant and efficient. It builds the random subset in the first <code>k</code> positions of the array iteratively.</p><p><strong>Algorithm</strong>:</p><ol><li>Iterate with an index <code>i</code> from <code>0</code> up to <code>k-1</code>. This loop runs exactly <code>k</code> times.</li><li>In each iteration <code>i</code>:<ul><li>We need to select a random element from the portion of the array that hasn&rsquo;t been considered for the sample yet. This &ldquo;unseen&rdquo; portion is from index <code>i</code> to <code>n-1</code> (inclusive).</li><li>Generate a random integer <code>r</code> such that <code>i &lt;= r &lt; n</code>. (Pick a random index from the current position <code>i</code> to the end).</li><li>Swap the element at the current index <code>i</code> with the element at the randomly chosen index <code>r</code>: <code>A[i], A[r] = A[r], A[i]</code>.</li></ul></li><li>After the loop finishes (after <code>k</code> swaps), the subarray <code>A[0...k-1]</code> contains the uniformly random sample of size <code>k</code>.</li></ol><p><strong>Why does this work? (Intuition)</strong></p><ul><li><strong>Iteration <code>i=0</code></strong>: We randomly pick an index <code>r</code> from <code>0</code> to <code>n-1</code>. We swap <code>A[0]</code> with <code>A[r]</code>. Now <code>A[0]</code> holds a uniformly random element chosen from the entire original array.</li><li><strong>Iteration <code>i=1</code></strong>: We randomly pick an index <code>r</code> from <code>1</code> to <code>n-1</code>. This picks uniformly from all elements <em>except</em> the one we already placed at <code>A[0]</code>. We swap <code>A[1]</code> with <code>A[r]</code>. Now <code>A[1]</code> holds a uniformly random element chosen from the remaining <code>n-1</code> elements. <code>A[0]</code> and <code>A[1]</code> together now form a random pair.</li><li><strong>Iteration <code>i</code></strong>: We pick a random index <code>r</code> from <code>i</code> to <code>n-1</code>. This selects uniformly from the <code>n-i</code> elements that haven&rsquo;t yet been fixed into the sample positions <code>0</code> to <code>i-1</code>. We swap <code>A[i]</code> with <code>A[r]</code>. This places a uniformly chosen element (from the remaining available ones) into position <code>i</code>.</li></ul><p>By induction, after <code>k</code> steps, <code>A[0...k-1]</code> holds a uniformly chosen subset of size <code>k</code>. Each element had an equal chance of ending up in each position of the sample.</p><hr><h2 id=section-513-sample-online-data-page-19--pdf-page-55>Section 5.13: Sample Online Data (Page 19 / PDF Page 55)</h2><p><strong>The Scenario</strong>: Now imagine data isn&rsquo;t available all at once (&ldquo;offline&rdquo;). Instead, you&rsquo;re receiving a <strong>stream</strong> of data items (like packets in a network session, or log entries as they happen). You <strong>don&rsquo;t know how many items will be in the stream in total beforehand</strong>. You want to maintain a random sample of size <code>k</code> from the items seen so far. As each new item arrives, you update your sample. The sample must always be a uniformly random subset of the items processed up to that point.</p><p><strong>The Problem</strong>: Design an algorithm that takes an input size <code>k</code> and reads a sequence of data items (an iterator or stream). It should continuously maintain a subset of size <code>k</code> of the items read so far. This subset must be a uniformly random sample.</p><p><strong>Why this is Tricky</strong>:</p><ul><li>You don&rsquo;t know <code>n</code> (the total number of items) in advance.</li><li>When the <code>(m+1)</code>-th item arrives, you need to decide if it should be in your sample of size <code>k</code> (replacing one of the existing <code>k</code> items) or if it should be discarded. This decision must ensure that after processing <code>m+1</code> items, any <code>k</code> items from the <code>m+1</code> seen so far have an equal chance of being in your sample.</li></ul><h3 id=the-algorithm-reservoir-sampling>The Algorithm: Reservoir Sampling</h3><p>This is a classic algorithm for this problem.</p><p><strong>Algorithm</strong>:</p><ol><li><strong>Initialization</strong>: Read the first <code>k</code> items from the stream and store them directly into your sample (let&rsquo;s call it <code>sample_array</code> of size <code>k</code>). At this point, <code>sample_array</code> is trivially a uniform random sample of the first <code>k</code> items.</li><li><strong>Process Subsequent Items</strong>: For each subsequent item <code>x</code> that arrives (from item <code>k+1</code> onwards):<ul><li>Let <code>num_items_seen_so_far</code> be the total number of items processed so far (including the current item <code>x</code>). So, when processing the <code>(k+1)</code>-th item, <code>num_items_seen_so_far = k+1</code>. When processing the <code>(k+2)</code>-th, <code>num_items_seen_so_far = k+2</code>, and so on.</li><li>Generate a random integer <code>r</code> between <code>0</code> and <code>num_items_seen_so_far - 1</code> (inclusive). (Or 1 to <code>num_items_seen_so_far</code> and adjust).</li><li><strong>Decision</strong>:<ul><li>If <code>r &lt; k</code> (i.e., if the random number falls within the range <code>0</code> to <code>k-1</code>), then replace the element <code>sample_array[r]</code> with the current item <code>x</code>.</li><li>If <code>r >= k</code>, do nothing; discard the current item <code>x</code>.</li></ul></li></ul></li><li>After processing all items in the stream, <code>sample_array</code> will hold a uniformly random sample of size <code>k</code> from the entire stream.</li></ol><p><strong>Why does this work? (Proof by Induction - High Level)</strong></p><ul><li><p><strong>Base Case</strong>: After seeing <code>k</code> items, the <code>sample_array</code> contains all <code>k</code> items. This is a uniform random sample (the only possible sample of size <code>k</code> from <code>k</code> items).</p></li><li><p><strong>Inductive Hypothesis</strong>: Assume that after seeing <code>m</code> items (where <code>m >= k</code>), the <code>sample_array</code> (of size <code>k</code>) is a uniformly random sample of size <code>k</code> from those <code>m</code> items. This means any specific item <code>y</code> from the first <code>m</code> items has a probability of <code>k/m</code> of being in the <code>sample_array</code>.</p></li><li><p><strong>Inductive Step</strong>: Now, the <code>(m+1)</code>-th item, let&rsquo;s call it <code>x_m+1</code>, arrives.</p><ul><li><strong>What is the probability that <code>x_m+1</code> enters the sample?</strong><ul><li>It enters if we pick a random number <code>r</code> (from <code>0</code> to <code>m</code>) and <code>r &lt; k</code>.</li><li>The probability of this is <code>k / (m+1)</code>.</li></ul></li><li><strong>What is the probability that an old item <code>y</code> (which was among the first <code>m</code> items and was in the sample) remains in the sample?</strong><ul><li>Prob(<code>y</code> was in sample after <code>m</code> items) = <code>k/m</code>.</li><li>Prob(<code>y</code> is not kicked out when <code>x_m+1</code> arrives) =
Prob(<code>x_m+1</code> is not chosen to replace anything) + Prob(<code>x_m+1</code> is chosen, but <code>y</code> is not the one picked for replacement).</li><li>This is <code>(1 - k/(m+1))</code> (if <code>x_m+1</code> doesn&rsquo;t replace anything) + <code>(k/(m+1)) * ((k-1)/k)</code> (if <code>x_m+1</code> replaces, but it replaces one of the other <code>k-1</code> items).</li><li><code>= (m+1-k)/(m+1) + (k-1)/(m+1)</code></li><li><code>= (m+1-k+k-1)/(m+1) = m/(m+1)</code>.</li></ul></li><li>So, Prob(<code>y</code> remains in sample) = (Prob(<code>y</code> was in sample)) * (Prob(<code>y</code> not kicked out))<ul><li><code>= (k/m) * (m/(m+1)) = k/(m+1)</code>.</li></ul></li></ul></li><li><p><strong>Conclusion</strong>: After <code>m+1</code> items, both the new item <code>x_m+1</code> and any old item <code>y</code> (that was previously in the sample) now have a probability of <code>k/(m+1)</code> of being in the sample. This holds true for all items, thus maintaining the uniform random property.</p></li></ul><hr><h2 id=sampling-algorithms-recap>sampling Algorithms Recap</h2><h3 id=recall-the-offline-sampling-fisher-yates-logic>Recall the Offline Sampling (Fisher-Yates) Logic:</h3><p>At step <code>i</code> (filling the <code>i</code>-th slot of our sample, 0-indexed), we do:</p><ol><li><code>r = random.randrange(i, n)</code></li><li><code>A[i], A[r] = A[r], A[i]</code></li></ol><p>The key principle ensuring fairness here is: At step <code>i</code>, we choose uniformly from all items not yet placed in the sample (those in positions <code>i</code> through <code>n-1</code>) and place the chosen item into position <code>i</code>.</p><h3 id=now-the-onlinereservoir-sampling-challenge>Now, the Online/Reservoir Sampling Challenge:</h3><p>When the <code>m</code>-th item arrives (<code>m > k</code>), we don&rsquo;t know <code>n</code>. We cannot simply pick a random index <code>r</code> from <code>i</code> to <code>n-1</code>. We only know the items seen so far (<code>m</code> items). We have a reservoir <code>R</code> of size <code>k</code> which (by induction) is a fair sample of the first <code>m-1</code> items.</p><p><strong>Goal</strong>: Update the reservoir <code>R</code> using the <code>m</code>-th item (<code>x_m</code>) such that <code>R</code> becomes a fair sample of all <code>m</code> items. Fairness means every item <code>x_1, ..., x_m</code> must have a <code>k/m</code> probability of being in <code>R</code>.</p><p><strong>Reservoir Sampling Step for item <code>m</code></strong>:</p><ol><li>Generate <code>r = random.randrange(m)</code> (an index from 0 to <code>m-1</code>).</li><li><code>if r &lt; k:</code><ul><li><code>R[r] = x_m</code> (replace element at index <code>r</code> in the reservoir with the new item).</li></ul></li></ol><p><strong>How does this achieve the <code>k/m</code> probability goal?</strong></p><p>Let&rsquo;s connect this to the &ldquo;drawing from a hat&rdquo; idea.</p><ul><li><strong>Imagine a Hypothetical Hat</strong>: Conceptually, after <code>m-1</code> items, our reservoir <code>R</code> holds <code>k</code> items drawn fairly from a hat containing the first <code>m-1</code> items.</li><li><strong>Item <code>m</code> Arrives</strong>: It&rsquo;s like adding the <code>m</code>-th item&rsquo;s name (<code>x_m</code>) to the hat. Now the hat contains <code>m</code> items.</li><li><strong>Fair Draw Needed</strong>: To get a fair sample of size <code>k</code> from this hat of <code>m</code> items, each item in the hat should have a <code>k/m</code> chance of being selected if we were to redraw completely.</li></ul><p><strong>Can we achieve this without redrawing?</strong></p><p>Let&rsquo;s analyze the chances for the <strong>new item <code>x_m</code></strong>:</p><ul><li>The algorithm gives <code>x_m</code> a chance to get into the reservoir if <code>r &lt; k</code>, where <code>r</code> is chosen from <code>0</code> to <code>m-1</code>.</li><li>There are <code>k</code> &ldquo;winning&rdquo; values for <code>r</code> (0 to <code>k-1</code>) out of <code>m</code> total possibilities.</li><li>So, <strong>Prob(<code>x_m</code> enters the reservoir) = <code>k/m</code></strong>. This is exactly the fairness probability we need for the new item!</li></ul><p>Now, let&rsquo;s analyze the chances for an <strong>old item <code>Y</code></strong> that was already in the reservoir <code>R</code> before <code>x_m</code> arrived.</p><ul><li><p>By our assumption (inductive hypothesis), <code>Y</code> was in the reservoir with probability <code>k / (m-1)</code> after <code>m-1</code> items.</p></li><li><p>For <code>Y</code> to still be in the reservoir after item <code>m</code> is processed, one of two things must happen:</p><ol><li>The random number <code>r</code> was not less than <code>k</code> (i.e., <code>r >= k</code>). This happens with probability <code>(m-k)/m</code>. In this case, <code>x_m</code> is ignored, and <code>Y</code> definitely stays.</li><li>The random number <code>r</code> was less than <code>k</code> (prob <code>k/m</code>), AND the slot chosen for replacement was not <code>Y</code>&rsquo;s slot. Since <code>r</code> is chosen uniformly from <code>0</code> to <code>k-1</code> in this case to be the replacement index, the chance that <code>Y</code>&rsquo;s specific slot is <em>not</em> picked is <code>(k-1)/k</code>. So, the probability of this combined event is <code>(k/m) * (k-1)/k = (k-1)/m</code>.</li></ol></li><li><p>Total probability <code>Y</code> stays in the reservoir = Prob(Case 1) + Prob(Case 2)
<code>= (m-k)/m + (k-1)/m = (m-1)/m</code>.</p></li><li><p>Now, the final probability that <code>Y</code> is in the reservoir after processing item <code>m</code> is:
Prob(<code>Y</code> was in after <code>m-1</code>) * Prob(<code>Y</code> stays when <code>m</code> arrives)
<code>= [k / (m-1)] * [(m-1) / m]</code>
<code>= k/m</code>.</p></li></ul><h3 id=the-connection>The Connection:</h3><p>Both algorithms achieve fairness, but through different mechanisms constrained by what information is available:</p><ul><li><strong>Offline (Fisher-Yates)</strong>: Knows <code>n</code>. Can directly simulate picking from the remaining available items at each step <code>i</code> by choosing a random index <code>r</code> in the future part of the array (<code>i</code> to <code>n-1</code>) and swapping into position <code>i</code>. It ensures fairness by giving every available item an equal chance (<code>1/(n-i)</code>) to be put into slot <code>i</code>.</li><li><strong>Online (Reservoir)</strong>: Doesn&rsquo;t know <code>n</code>. Cannot pick from future indices. Instead, it uses probabilities based on the count <code>m</code> seen so far. It gives the new item <code>x_m</code> the exact target probability <code>k/m</code> of being included. If included, the random replacement maintains the correct probabilities for the older items, ensuring they also end up with probability <code>k/m</code>. It achieves the same final probability distribution as Offline Sampling, but through an incremental, probabilistic update rather than direct selection and placement.</li></ul><p>Think of Reservoir Sampling as cleverly calculating how often the new item should replace an old one to maintain the correct <code>k/m</code> probability for everyone in the long run, even without knowing the total number of items <code>m</code> will eventually reach.</p><hr><h2 id=section-515-compute-a-random-subset-page-21--pdf-page-57>Section 5.15: Compute a Random Subset (Page 21 / PDF Page 57)</h2><p><strong>The Problem</strong>: Given a positive integer <code>n</code> and a size <code>k &lt;= n</code>, return a size-<code>k</code> subset of the set <code>{0, 1, 2, ..., n-1}</code>. The subset should be represented as an array. All <code>(n choose k)</code> possible subsets should be equally likely. Additionally, all permutations of elements within the returned array should be equally likely (though this is often a natural byproduct of algorithms that produce uniform subsets).</p><p><strong>How is this different from Offline Sampling (Section 5.12)?</strong></p><ul><li><strong>Offline Sampling (5.12)</strong>: Input is an existing array <code>A</code>. Output is a modification of <code>A</code> where <code>A[0...k-1]</code> holds the sample. It operates on <em>given elements</em>.</li><li><strong>This Problem (5.15)</strong>: Input is just integers <code>n</code> and <code>k</code>. The &ldquo;elements&rdquo; are implicitly the integers from <code>0</code> to <code>n-1</code>. We need to <em>construct</em> an array containing a random subset of these integers.</li></ul><h3 id=solution-approach-1-mimic-offline-sampling-fisher-yates>Solution Approach 1: Mimic Offline Sampling (Fisher-Yates)</h3><ol><li>Create an array <code>elements = [0, 1, ..., n-1]</code>.</li><li>Apply the Offline Sampling algorithm (from Section 5.12, also known as Fisher-Yates shuffle) to this <code>elements</code> array to pick <code>k</code> items.</li><li>Return the first <code>k</code> elements of the shuffled <code>elements</code> array (<code>elements[0...k-1]</code>).</li></ol><ul><li><strong>Complexity</strong>:<ul><li>Time: O(n) to create the initial <code>elements</code> array + O(k) for sampling = <strong>O(n)</strong>.</li><li>Space: <strong>O(n)</strong> for the <code>elements</code> array.</li></ul></li></ul><p><strong>Can we do better if <code>k</code> is much smaller than <code>n</code>?</strong> (e.g., sample 3 items from 1 million)
Creating an array of 1 million elements just to pick 3 seems wasteful.</p><h3 id=solution-approach-2-using-a-hash-table-for-k--n>Solution Approach 2: Using a Hash Table (for k &#171; n)</h3><p>This approach avoids creating the full array of <code>n</code> elements if <code>k</code> is small. It directly simulates the Fisher-Yates logic but only keeps track of the elements that would have been moved from their original positions.</p><p><strong>The Idea</strong>:
Imagine you&rsquo;re running the Fisher-Yates shuffle on the conceptual array <code>[0, 1, ..., n-1]</code>.</p><ul><li>The array initially has <code>A[j] = j</code>.</li><li>When you iterate for the <code>i</code>-th element of your sample (from <code>i=0</code> to <code>k-1</code>):<ul><li>You pick a random index <code>rand_idx</code> from <code>i</code> to <code>n-1</code>.</li><li>You swap <code>A[i]</code> and <code>A[rand_idx]</code>.
If <code>k</code> is small, most of the conceptual array <code>A</code> will remain <code>A[j]=j</code>. Only a few elements get swapped. We can use a hash table (dictionary in Python) to store only those elements whose values are not equal to their indices (i.e., the elements that have been moved).</li></ul></li></ul><p><strong>Algorithm with Hash Table</strong>:</p><ol><li>Initialize an empty dictionary <code>changed_elements</code>. This dictionary will store <code>index: value</code> pairs for any position where the value is different from what it would be in the identity permutation <code>[0, 1, ..., n-1]</code> after our simulated swaps.</li><li>Iterate <code>i</code> from <code>0</code> to <code>k-1</code> (to select <code>k</code> elements for our subset).<ol><li>Generate a random index <code>rand_idx</code> in the range <code>[i, n-1]</code>.</li><li>Get current values:<ul><li><code>value_at_i = changed_elements.get(i, i)</code> (If <code>i</code> is in the dictionary, use its stored value; otherwise, its value is <code>i</code>).</li><li><code>value_at_rand_idx = changed_elements.get(rand_idx, rand_idx)</code> (Similarly for <code>rand_idx</code>).</li></ul></li><li>Perform the swap (conceptually, updating the dictionary):<ul><li>Store <code>value_at_i</code> at <code>rand_idx</code>: <code>changed_elements[rand_idx] = value_at_i</code>.</li><li>Store <code>value_at_rand_idx</code> at <code>i</code>: <code>changed_elements[i] = value_at_rand_idx</code>.</li></ul></li></ol></li><li>After the loop, the desired subset consists of the values that are conceptually in <code>A[0]...A[k-1]</code>. We retrieve these from our <code>changed_elements</code> dictionary (defaulting to <code>i</code> if <code>i</code> is not a key).<ul><li><code>result_subset = [changed_elements.get(j, j) for j in range(k)]</code>.</li></ul></li></ol><p><strong>When is the Hash Table approach better?</strong></p><p>When <code>k</code> is <strong>significantly smaller</strong> than <code>n</code>.</p><ul><li><strong>Fisher-Yates on full array (Approach 1)</strong>:<ul><li>Time: O(n)</li><li>Space: O(n) (for the initial array <code>[0, ..., n-1]</code>)</li></ul></li><li><strong>Hash Table method (Approach 2)</strong>:<ul><li>Time: O(k) (k iterations, each with dictionary operations which are O(1) on average)</li><li>Space: O(k) (at most <code>2k</code> entries in the dictionary if <code>i</code> and <code>rand_idx</code> are always different and neither was previously in the dictionary)</li></ul></li></ul><p>So, if <code>k &lt;&lt; n</code> (k is much much less than n), the hash table method wins on both time and space by avoiding the creation and full scan of the n-element array.</p><p>If <code>k</code> is close to <code>n</code> (e.g., <code>k = n/2</code> or <code>k = n-1</code>), the O(n) approach (Approach 1) is fine and might even be slightly faster in practice due to less overhead compared to dictionary get/set operations, even though their asymptotic complexities might suggest otherwise for <code>k ~ O(n)</code>. The constant factors matter.</p><hr><h2 id=section-516-generate-nonuniform-random-numbers-page-22--pdf-page-58>Section 5.16: Generate Nonuniform Random Numbers (Page 22 / PDF Page 58)</h2><p><strong>The Problem</strong>: You are given:</p><ul><li>A list of <code>n</code> numbers (values): <code>T = [t_0, t_1, ..., t_{n-1}]</code>.</li><li>A list of <code>n</code> corresponding probabilities: <code>P = [p_0, p_1, ..., p_{n-1}]</code>. These probabilities sum up to 1.</li></ul><p>You need to write a function that generates one of the numbers from <code>T</code> according to its specified probability <code>p_i</code>. You have access to a standard uniform random number generator that produces values in the range <code>[0.0, 1.0)</code> (i.e., 0 inclusive, 1 exclusive).</p><p><strong>Example</strong>:</p><ul><li>Numbers <code>T = [3, 5, 7, 11]</code></li><li>Probabilities <code>P = [9/18, 6/18, 2/18, 1/18]</code> (which are <code>[0.5, 0.333..., 0.111..., 0.055...]</code>)</li></ul><p>If you call your function many times:</p><ul><li>About 50% of the time, it should return 3.</li><li>About 33.3% of the time, it should return 5.</li><li>About 11.1% of the time, it should return 7.</li><li>About 5.5% of the time, it should return 11.</li></ul><h3 id=the-core-idea-mapping-the-01-interval>The Core Idea: Mapping the [0,1) Interval</h3><p>The uniform random number generator gives us a value <code>r</code> in <code>[0.0, 1.0)</code>. We need to divide this <code>[0.0, 1.0)</code> interval into <code>n</code> segments, where the length of each segment corresponds to the probability of picking the associated number.</p><ul><li><strong>Segment 0</strong>: Length <code>p_0</code>. Corresponds to <code>t_0</code>. Range <code>[0, p_0)</code>.</li><li><strong>Segment 1</strong>: Length <code>p_1</code>. Corresponds to <code>t_1</code>. Range <code>[p_0, p_0 + p_1)</code>.</li><li><strong>Segment 2</strong>: Length <code>p_2</code>. Corresponds to <code>t_2</code>. Range <code>[p_0 + p_1, p_0 + p_1 + p_2)</code>.</li><li>&mldr;and so on.</li><li><strong>Segment n-1</strong>: Length <code>p_{n-1}</code>. Corresponds to <code>t_{n-1}</code>. Range <code>[sum(p_0 to p_{n-2}), sum(p_0 to p_{n-1}) = 1.0)</code></li></ul><h3 id=analogy-a-dartboard-with-unequal-slices>Analogy: A Dartboard with Unequal Slices</h3><p>Imagine you have a circular dartboard. Instead of all slices being equal (like in a standard dartboard), the slices have different sizes.</p><ul><li>You have <code>n</code> numbers you want to pick from: <code>t_0, t_1, t_2, ..., t_{n-1}</code>.</li><li>Each number <code>t_i</code> has a probability <code>p_i</code> of being picked.</li><li>The slice on the dartboard for <code>t_0</code> takes up <code>p_0</code> fraction of the dartboard&rsquo;s area.</li><li>The slice for <code>t_1</code> takes up <code>p_1</code> fraction of the area.</li><li>And so on. All <code>p_i</code> fractions add up to 1 (the whole dartboard).</li></ul><p><strong>Example</strong>:</p><ul><li>Numbers <code>T = [Red, Green, Blue]</code></li><li>Probabilities <code>P = [0.5 (for Red), 0.3 (for Green), 0.2 (for Blue)]</code><ul><li>Red slice covers 50% of the dartboard.</li><li>Green slice covers 30%.</li><li>Blue slice covers 20%.</li></ul></li></ul><p><strong>How to Pick Fairly?</strong></p><ol><li>Throw a dart completely randomly at the dartboard. &ldquo;Completely randomly&rdquo; means any point on the board is equally likely to be hit.</li><li>See which slice your dart lands in. That&rsquo;s the number you pick.
Since the Red slice is bigger, you&rsquo;re more likely to hit Red. This simulates the probabilities.</li></ol><h3 id=connecting-to-randomrandom-which-gives-a-number-in-00-10>Connecting to <code>random.random()</code> which gives a number in <code>[0.0, 1.0)</code></h3><p>Instead of a circular dartboard, let&rsquo;s imagine a straight line segment of length 1. Think of it like a ruler from 0.0 to 1.0.
We&rsquo;re going to divide this ruler into sections, where the length of each section is proportional to the probability.</p><p>For <code>T = [Red, Green, Blue]</code> and <code>P = [0.5, 0.3, 0.2]</code>:</p><ul><li>Section for Red: Length 0.5. It goes from 0.0 up to 0.5. (Range: <code>[0.0, 0.5)</code>)</li><li>Section for Green: Length 0.3. It starts where Red left off, so it goes from 0.5 up to 0.5 + 0.3 = 0.8. (Range: <code>[0.5, 0.8)</code>)</li><li>Section for Blue: Length 0.2. It starts where Green left off, so it goes from 0.8 up to 0.8 + 0.2 = 1.0. (Range: <code>[0.8, 1.0)</code>)</li></ul><p>Visually:</p><table><thead><tr><th>0.0 0.5 0.8 1.0</th><th></th><th></th></tr></thead><tbody><tr><td>&lt;&mdash; Red &mdash;> &lt;&ndash; Green &ndash;> &lt;&ndash; Blue &ndash;></td><td></td><td></td></tr><tr><td>(length 0.5) (length 0.3) (length 0.2)</td><td></td><td></td></tr></tbody></table><h3 id=the-algorithm-using-this-ruler>The Algorithm using this &ldquo;Ruler&rdquo;:</h3><ol><li><p><strong>Prepare the Ruler Divisions (these are the &ldquo;cumulative probabilities&rdquo;)</strong>:</p><ul><li>Red ends at: <code>0.5</code></li><li>Green ends at: <code>0.5 + 0.3 = 0.8</code></li><li>Blue ends at: <code>0.5 + 0.3 + 0.2 = 1.0</code>
Let&rsquo;s call these end-points: <code>Endpoints = [0.5, 0.8, 1.0]</code></li></ul></li><li><p><strong>&ldquo;Throw a Dart&rdquo;</strong>: Get a random number from your computer, <code>rand_val = random.random()</code>. This <code>rand_val</code> will be somewhere between 0.0 and 1.0 (but not including 1.0).</p></li><li><p><strong>See Which Section it Lands In</strong>:</p><ul><li>If <code>0.0 &lt;= rand_val &lt; Endpoints[0]</code> (i.e., <code>rand_val &lt; 0.5</code>), it landed in Red&rsquo;s section. Output: Red.</li><li>Else if <code>Endpoints[0] &lt;= rand_val &lt; Endpoints[1]</code> (i.e., <code>0.5 &lt;= rand_val &lt; 0.8</code>), it landed in Green&rsquo;s section. Output: Green.</li><li>Else if <code>Endpoints[1] &lt;= rand_val &lt; Endpoints[2]</code> (i.e., <code>0.8 &lt;= rand_val &lt; 1.0</code>), it landed in Blue&rsquo;s section. Output: Blue.</li></ul></li></ol><p><strong>Why does this work?</strong>
Because the length of each section on our &ldquo;ruler&rdquo; is exactly its probability, a uniformly random <code>rand_val</code> is proportionally more likely to fall into longer sections.</p><p><strong>Example from the Book</strong>:</p><ul><li>Numbers <code>T = [3, 5, 7, 11]</code></li><li>Probabilities <code>P = [9/18, 6/18, 2/18, 1/18]</code></li><li><code>P_decimal = [0.5, 0.333..., 0.111..., 0.055...]</code></li></ul><p>Ruler Divisions (Cumulative Probabilities):</p><ul><li><code>div[0]</code> (for number 3): <code>0.5</code></li><li><code>div[1]</code> (for number 5): <code>0.5 + 0.333... = 0.833...</code></li><li><code>div[2]</code> (for number 7): <code>0.833... + 0.111... = 0.944...</code></li><li><code>div[3]</code> (for number 11): <code>0.944... + 0.055... = 1.0</code>
So, <code>Endpoints = [0.5, 0.833..., 0.944..., 1.0]</code></li></ul><p>Throw a Dart: <code>rand_val = random.random()</code>. Let&rsquo;s say <code>rand_val = 0.75</code>.</p><p>See Where it Lands:</p><ul><li>Is <code>0.75 &lt; Endpoints[0]</code> (0.5)? No.</li><li>Is <code>0.75 &lt; Endpoints[1]</code> (0.833&mldr;)? Yes.<ul><li>Aha! It landed between <code>Endpoints[0]</code> and <code>Endpoints[1]</code>. This corresponds to the second number in our original list <code>T</code>, which is 5.</li><li>So, we output 5.</li></ul></li></ul><p>What if <code>rand_val = 0.2</code>?</p><ul><li>Is <code>0.2 &lt; Endpoints[0]</code> (0.5)? Yes.<ul><li>It landed before the first endpoint. This corresponds to the first number, 3. Output 3.</li></ul></li></ul><h3 id=the-binary-search-part-eg-bisect_left>The &ldquo;Binary Search&rdquo; Part (e.g., <code>bisect_left</code>)</h3><p>When we have many sections (many numbers <code>t_i</code>), checking <code>rand_val</code> against each endpoint one by one (if <code>rand_val &lt; E[0]</code>&mldr; else if <code>rand_val &lt; E[1]</code>&mldr;) is slow (O(n)).
Since the <code>Endpoints</code> array <code>[0.5, 0.833, 0.944, 1.0]</code> is sorted, we can use <strong>binary search</strong> to quickly find which &ldquo;bucket&rdquo; <code>rand_val</code> falls into.
<code>bisect_left(Endpoints, rand_val)</code> efficiently finds the index <code>idx</code> such that all <code>Endpoints[j]</code> for <code>j &lt; idx</code> are less than <code>rand_val</code>, and <code>Endpoints[idx]</code> is the first endpoint that is greater than or equal to <code>rand_val</code>. This <code>idx</code> is precisely the index of the chosen <code>t_i</code> in our original list <code>T</code>.</p><h3 id=summary-in-simple-terms>Summary in Simple Terms:</h3><ol><li>Line up all your probabilities end-to-end on a ruler of length 1. Mark where each probability &ldquo;ends&rdquo;.</li><li>Generate a random point on that ruler (a random number between 0 and 1).</li><li>See which probability&rsquo;s segment your random point landed in.</li><li>Pick the number associated with that segment.
<em>(Binary search is just a fast way to do step 3 if you have lots of segments).</em></li></ol><hr><h2 id=section-517-the-sudoku-checker-problem-page-24--pdf-page-60>Section 5.17: The Sudoku Checker Problem (Page 24 / PDF Page 60)</h2><p><strong>The Problem</strong>: You are given a 9x9 2D array (a grid) representing a partially or fully completed Sudoku puzzle. The grid contains integers from 0 to 9. A value of 0 indicates an empty cell. Values from 1 to 9 are filled-in digits.</p><p>Your task is to determine if the current state of the Sudoku grid is <strong>valid</strong> according to Sudoku rules:</p><ol><li>Each <strong>row</strong> must contain unique digits from 1 to 9 (ignoring 0s).</li><li>Each <strong>column</strong> must contain unique digits from 1 to 9 (ignoring 0s).</li><li>Each of the nine <strong>3x3 subgrids</strong> (also called &ldquo;boxes&rdquo; or &ldquo;regions&rdquo;) must contain unique digits from 1 to 9 (ignoring 0s).</li></ol><p>The problem asks only to check for validity (no duplicate 1-9 digits in any row, column, or 3x3 box). It does <strong>not</strong> ask you to solve the Sudoku.</p><p><strong>Example</strong>:</p><ul><li>Figure 5.2(a) on page 60 is a partially filled valid Sudoku.</li><li>Figure 5.2(b) is a complete, valid solution.</li><li>An invalid example: A row <code>[5, 3, 4, 6, 7, 8, 9, 1, 5]</code> is invalid because 5 appears twice.</li></ul><h3 id=core-implementation-idea-directly-testing-constraints>Core Implementation Idea (Directly Testing Constraints):</h3><p>The most straightforward approach is to check each of the three types of constraints one by one. For checking uniqueness within a row, column, or 3x3 box, a common technique is to use a helper data structure (like a hash set or a boolean array) to keep track of the digits seen so far within that unit.</p><p><strong>Algorithm Outline</strong>:</p><ol><li><p><strong>Function to Check a Unit (Row, Column, or Box)</strong>:</p><ul><li>Create a helper function, say <code>has_duplicate(unit_array)</code>, that takes a 1D array (representing a row, column, or flattened 3x3 box) and returns <code>True</code> if it contains duplicate digits from 1-9, <code>False</code> otherwise.</li><li>Inside <code>has_duplicate(unit_array)</code>:<ul><li>Initialize a <code>seen_digits = set()</code> (or a boolean array <code>seen = [False]*10</code>).</li><li>Iterate through each <code>digit</code> in <code>unit_array</code>:<ul><li>If <code>digit == 0</code>, ignore it (empty cell).</li><li>If <code>digit != 0</code>:<ul><li>If <code>digit</code> is already in <code>seen_digits</code> (or <code>seen[digit]</code> is <code>True</code>), then a duplicate is found. Return <code>True</code> immediately.</li><li>Otherwise, add <code>digit</code> to <code>seen_digits</code> (or set <code>seen[digit] = True</code>).</li></ul></li></ul></li><li>If the loop finishes without finding duplicates, return <code>False</code>.</li></ul></li></ul></li><li><p><strong>Check Row Constraints</strong>:</p><ul><li>Iterate <code>i</code> from 0 to 8 (for each row).</li><li>Extract row <code>i</code> from the Sudoku grid: <code>row_data = grid[i]</code>.</li><li>If <code>has_duplicate(row_data)</code> is <code>True</code>, then the Sudoku is invalid. Return <code>False</code>.</li></ul></li><li><p><strong>Check Column Constraints</strong>:</p><ul><li>Iterate <code>j</code> from 0 to 8 (for each column).</li><li>Extract column <code>j</code>: <code>col_data = [grid[i][j] for i in range(9)]</code>.</li><li>If <code>has_duplicate(col_data)</code> is <code>True</code>, then the Sudoku is invalid. Return <code>False</code>.</li></ul></li><li><p><strong>Check 3x3 Subgrid Constraints</strong>:</p><ul><li>Iterate through the 9 subgrids. A common way is to use nested loops for the top-left corner of each subgrid:<ul><li>Iterate <code>box_row_start</code> from 0 to 6, with a step of 3 (i.e., 0, 3, 6).</li><li>Iterate <code>box_col_start</code> from 0 to 6, with a step of 3 (i.e., 0, 3, 6).</li><li>For each (<code>box_row_start</code>, <code>box_col_start</code>):<ul><li><em>(The next step would be to extract the 3x3 subgrid data and call <code>has_duplicate</code> on it. If it returns <code>True</code>, the Sudoku is invalid and we return <code>False</code> from the main function.)</em></li></ul></li></ul></li></ul></li><li><p><strong>All Checks Passed</strong>: If all the above checks pass without returning False, then the Sudoku grid is valid. Return True.</p></li></ol><p>Simplified Implementation Steps:</p><ol><li><p><strong>Helper function <code>is_unit_valid(list_of_9_cells)</code></strong>:</p><ul><li>Takes a list (a row, a column, or the 9 cells of a box).</li><li>Uses a <code>seen_numbers = set()</code>.</li><li>For each <code>cell</code> in <code>list_of_9_cells</code>:<ul><li>If <code>cell == 0</code>, continue.</li><li>If <code>cell</code> is in <code>seen_numbers</code>, return <code>False</code> (duplicate found!).</li><li>Add <code>cell</code> to <code>seen_numbers</code>.</li></ul></li><li>If loop finishes, return <code>True</code> (no duplicates).</li></ul></li><li><p><strong>Main function <code>is_sudoku_valid(grid)</code></strong>:</p><ul><li><strong>Rows</strong>: For each row <code>r</code> from 0 to 8:<ul><li>If not <code>is_unit_valid(grid[r])</code>, then return <code>False</code>.</li></ul></li><li><strong>Columns</strong>: For each column <code>c</code> from 0 to 8:<ul><li>Create <code>column_list = [grid[r][c] for r in range(9)]</code>.</li><li>If not <code>is_unit_valid(column_list)</code>, then return <code>False</code>.</li></ul></li><li><strong>Boxes</strong>: For each box (e.g., <code>box_row_start</code> from 0,3,6 and <code>box_col_start</code> from 0,3,6):<ul><li>Create <code>box_list</code> by picking the 9 cells.</li><li>If not <code>is_unit_valid(box_list)</code>, then return <code>False</code>.</li></ul></li><li>If you get through all of this, return <code>True</code>.</li></ul></li></ol><hr><h2 id=section-518-compute-the-spiral-ordering-of-a-2d-array-page-25--pdf-page-61>Section 5.18: Compute the Spiral Ordering of a 2D Array (Page 25 / PDF Page 61)</h2><p><strong>What</strong>: Given an <code>n x n</code> 2D array, return a 1D list of its elements in &ldquo;spiral order&rdquo; (outside-in, clockwise).</p><p><strong>Why (Interview)</strong>: This is a common 2D array traversal problem. It tests:</p><ul><li>Ability to manage 2D array indices carefully.</li><li>Handling boundary conditions.</li><li>Devising a systematic way to cover all elements without repetition.</li><li>State management (current position, current direction, visited cells).</li></ul><p><strong>Underlying Pattern</strong>: Systematic Traversal with State Management. The two main patterns are &ldquo;Layer Peeling&rdquo; or &ldquo;Path Simulation.&rdquo;</p><h3 id=simplified-implementation-intuition-simulation-approach---robot-walk>Simplified Implementation Intuition (Simulation Approach - &ldquo;Robot Walk&rdquo;):</h3><p>Imagine a robot starting at <code>matrix[0][0]</code>. It needs to walk in a spiral and report the numbers it steps on.</p><p><strong>Setup</strong>:</p><ul><li><code>result_list = []</code> (to store the spiral numbers).</li><li><code>current_row = 0</code>, <code>current_col = 0</code>.</li><li><code>directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]</code> (These are <code>[row_change, col_change]</code> for Right, Down, Left, Up).</li><li><code>current_direction_idx = 0</code> (Start by going Right).</li><li><code>num_elements = n * n</code>.</li><li>A way to mark visited cells: Let&rsquo;s assume we can modify the input matrix. We&rsquo;ll set <code>matrix[row][col] = None</code> (or some other special marker) after visiting. (If not, use a separate <code>visited[n][n]</code> boolean array).</li></ul><p><strong>The Walk (Loop <code>num_elements</code> times)</strong>:</p><ol><li><strong>Collect</strong>: Add <code>matrix[current_row][current_col]</code> to <code>result_list</code>.</li><li><strong>Mark</strong>: <code>matrix[current_row][current_col] = None</code> (or <code>visited[current_row][current_col] = True</code>).</li><li><strong>Try to move in current direction</strong>:<ul><li><code>next_row_change, next_col_change = directions[current_direction_idx]</code>.</li><li><code>potential_next_row = current_row + next_row_change</code>.</li><li><code>potential_next_col = current_col + next_col_change</code>.</li></ul></li><li><strong>Check if turn is needed</strong>:<ul><li>Is (<code>potential_next_row</code>, <code>potential_next_col</code>) OFF the grid (e.g., <code>potential_next_row &lt; 0</code> or <code>>= n</code>, or <code>potential_next_col &lt; 0</code> or <code>>= n</code>)?</li><li>OR, is <code>matrix[potential_next_row][potential_next_col]</code> ALREADY visited (e.g., <code>== None</code>)?</li></ul></li><li><strong>If YES (turn needed)</strong>:<ul><li>Change direction: <code>current_direction_idx = (current_direction_idx + 1) % 4</code> (turn clockwise).</li><li>Recalculate actual next step with new direction:<ul><li><code>next_row_change, next_col_change = directions[current_direction_idx]</code>.</li><li><code>current_row += next_row_change</code>.</li><li><code>current_col += next_col_change</code>.</li></ul></li></ul></li><li><strong>If NO (can continue in current direction)</strong>:<ul><li><code>current_row = potential_next_row</code>.</li><li><code>current_col = potential_next_col</code>.</li></ul></li><li>Return <code>result_list</code>.</li></ol><p><strong>Example Trace Snippet (3x3): <code>[[1,2,3],[4,5,6],[7,8,9]]</code></strong>
<code>res=[]</code>, <code>(r,c)=(0,0)</code>, <code>dir=0</code> (Right)</p><ol><li>Add 1. <code>res=[1]</code>. <code>matrix[0][0]=None</code>. Try (0,1) (Right). Valid. <code>(r,c)=(0,1)</code>.</li><li>Add 2. <code>res=[1,2]</code>. <code>matrix[0][1]=None</code>. Try (0,2) (Right). Valid. <code>(r,c)=(0,2)</code>.</li><li>Add 3. <code>res=[1,2,3]</code>. <code>matrix[0][2]=None</code>. Try (0,3) (Right). INVALID (off grid).<ul><li>Turn! <code>dir=(0+1)%4 = 1</code> (Down).</li><li>New try from (0,2) with Down: (1,2). Valid. <code>(r,c)=(1,2)</code>.</li></ul></li><li>Add 6. <code>res=[1,2,3,6]</code>. <code>matrix[1][2]=None</code>. Try (2,2) (Down). Valid. <code>(r,c)=(2,2)</code>.</li><li>Add 9. <code>res=[1,2,3,6,9]</code>. <code>matrix[2][2]=None</code>. Try (3,2) (Down). INVALID (off grid).<ul><li>Turn! <code>dir=(1+1)%4 = 2</code> (Left).</li><li>New try from (2,2) with Left: (2,1). Valid. <code>(r,c)=(2,1)</code>.</li><li>&mldr;and so on.</li></ul></li></ol><h3 id=managing-direction>Managing Direction:</h3><p>We need two things:</p><ol><li>A way to represent the current direction.</li><li>A way to change the direction systematically (usually clockwise).</li></ol><p><strong>1. Representing Direction:</strong>
We can assign numbers to directions:</p><ul><li>0: Right</li><li>1: Down</li><li>2: Left</li><li>3: Up
We store the robot&rsquo;s current direction in a variable, say <code>current_direction_idx</code> (initialized to 0 for Right).</li></ul><p><strong>2. Changing Direction (Turning Clockwise):</strong>
When the robot hits a wall or an already visited cell, it needs to turn right (clockwise).</p><ul><li>If current direction is Right (0), next is Down (1).</li><li>If current direction is Down (1), next is Left (2).</li><li>If current direction is Left (2), next is Up (3).</li><li>If current direction is Up (3), next is Right (0).
This pattern can be achieved with a simple calculation:
<code>current_direction_idx = (current_direction_idx + 1) % 4</code>
(<code>% 4</code> (modulo 4) ensures that if <code>current_direction_idx</code> becomes 4, it wraps around back to 0).</li><li><code>(0 + 1) % 4 = 1</code></li><li><code>(1 + 1) % 4 = 2</code></li><li><code>(2 + 1) % 4 = 3</code></li><li><code>(3 + 1) % 4 = 0</code></li></ul><p><strong>3. How Direction Affects Movement (Delta Row, Delta Column):</strong>
Once we know the <code>current_direction_idx</code>, how do we know how to change the <code>row</code> and <code>col</code> to move one step? We can use a lookup table (an array or list of lists/tuples) that stores the change in row (<code>dr</code>) and change in column (<code>dc</code>) for each direction index.</p><p>Let <code>SHIFT = [[0, 1], # Direction 0 (Right): row doesn't change, col increases by 1</code>
<code>[1, 0], # Direction 1 (Down): row increases by 1, col doesn't change</code>
<code>[0, -1], # Direction 2 (Left): row doesn't change, col decreases by 1</code>
<code>[-1, 0]] # Direction 3 (Up): row decreases by 1, col doesn't change</code></p><p>When the robot wants to move:</p><ul><li>Get the changes for the current direction:<ul><li><code>dr = SHIFT[current_direction_idx][0]</code></li><li><code>dc = SHIFT[current_direction_idx][1]</code></li></ul></li><li>Calculate the potential next position:<ul><li><code>potential_next_row = current_row + dr</code></li><li><code>potential_next_col = current_col + dc</code></li></ul></li></ul><hr><h2 id=section-519-rotate-a-2d-array-page-28--pdf-page-64>Section 5.19: Rotate a 2D Array (Page 28 / PDF Page 64)</h2><p><strong>The Problem</strong>: You are given an <code>n x n</code> 2D array (a square matrix). You need to rotate this matrix by 90 degrees clockwise, <strong>in-place</strong> (O(1) additional space).</p><p><strong>Example (from Figure 5.4)</strong>:</p><p>Input Matrix <code>A</code>:</p><pre tabindex=0><code>[ [ 1,  2,  3,  4],
  [ 5,  6,  7,  8],
  [ 9, 10, 11, 12],
  [13, 14, 15, 16] ]
</code></pre><p>Output Matrix <code>A</code> (after rotation):</p><pre tabindex=0><code>[ [13,  9,  5,  1],
  [14, 10,  6,  2],
  [15, 11,  7,  3],
  [16, 12,  8,  4] ]
</code></pre><p><strong>Observations / How Elements Move</strong>:</p><ul><li>The first row of the original (<code>[1,2,3,4]</code>) becomes the last column of the rotated, read from top to bottom (<code>[1,2,3,4]</code>).</li><li>The last column of the original (<code>[4,8,12,16]</code>) becomes the first row of the rotated, but reversed (or the last row of the transposed, reversed matrix - it&rsquo;s easier to think in terms of layers).<ul><li>More precisely: <code>A[row][col]</code> moves to <code>A[col][n-1-row]</code>.</li></ul></li></ul><h3 id=approach-1-using-extra-space-not-in-place-for-understanding>Approach 1: Using Extra Space (Not In-Place, for understanding)</h3><ol><li>Create a new <code>n x n</code> matrix, say <code>rotated_matrix</code>.</li><li>For each element <code>A[row][col]</code> in the original matrix:<ul><li>The new position in <code>rotated_matrix</code> will be <code>rotated_matrix[col][n - 1 - row]</code>.</li><li><code>rotated_matrix[col][n - 1 - row] = A[row][col]</code></li></ul></li><li>Copy <code>rotated_matrix</code> back to <code>A</code>.</li></ol><ul><li><strong>Time</strong>: O(N2)</li><li><strong>Space</strong>: O(N2) for <code>rotated_matrix</code>. Fails the in-place requirement.</li></ul><h3 id=approach-2-in-place-rotation-by-layers>Approach 2: In-Place Rotation by Layers</h3><p>This is the standard and efficient way to do it in-place.</p><p><strong>Key Idea</strong>: The rotation can be performed layer by layer, from the outermost layer inwards. Within each layer, elements move in groups of four.</p><p>Consider the outermost layer of the 4x4 example:</p><ul><li><code>A[0][0]</code> (1) moves to where <code>A[0][3]</code> (4) was.</li><li><code>A[0][3]</code> (4) moves to where <code>A[3][3]</code> (16) was.</li><li><code>A[3][3]</code> (16) moves to where <code>A[3][0]</code> (13) was.</li><li><code>A[3][0]</code> (13) moves to where <code>A[0][0]</code> (1) was.
This is a 4-way swap for the corners: (1) -> (4) -> (16) -> (13) -> (1)</li></ul><p>Original positions: <code>A[0][0]</code>, <code>A[0][3]</code>, <code>A[3][3]</code>, <code>A[3][0]</code>
After 90-deg clockwise rotation, their new conceptual positions are:</p><ul><li>The value originally at <code>A[3][0]</code> (13) moves to <code>A[0][0]</code>.</li><li>The value originally at <code>A[0][0]</code> (1) moves to <code>A[0][3]</code>.</li><li>The value originally at <code>A[0][3]</code> (4) moves to <code>A[3][3]</code>.</li><li>The value originally at <code>A[3][3]</code> (16) moves to <code>A[3][0]</code>.</li></ul><p>So, the values move like this in a cycle (let <code>TL</code>=TopLeft, <code>TR</code>=TopRight, <code>BR</code>=BottomRight, <code>BL</code>=BottomLeft for a specific group of 4):</p><pre tabindex=0><code>temp = value_at_TL
value_at_TL = value_at_BL
value_at_BL = value_at_BR
value_at_BR = value_at_TR
value_at_TR = temp
</code></pre><p><strong>Algorithm for In-Place Layer Rotation</strong>:</p><ol><li>The number of layers is <code>n // 2</code>.</li><li>Iterate through layers, from <code>layer = 0</code> to <code>n // 2 - 1</code>.<ul><li>For each <code>layer</code>:<ul><li>Define <code>first = layer</code> (first row/col index of this layer).</li><li>Define <code>last = n - 1 - layer</code> (last row/col index of this layer).</li><li>Now, iterate through the elements <em>within this layer&rsquo;s top row</em> (excluding the last one which is handled as a corner of another 4-element cycle). Iterate <code>i</code> from <code>first</code> to <code>last - 1</code>.<ul><li>An <code>offset = i - first</code>. This <code>offset</code> helps identify the corresponding elements in the other three sides of the current square within the layer.</li><li>For each <code>i</code> (or <code>offset</code>), perform a 4-way swap:<ol><li>Save top-left element: <code>top = matrix[first][i]</code> (which is <code>matrix[first][first + offset]</code>)</li><li>Left element moves to Top-Left: <code>matrix[first][i] = matrix[last - offset][first]</code></li><li>Bottom element moves to Left: <code>matrix[last - offset][first] = matrix[last][last - offset]</code></li><li>Right element moves to Bottom: <code>matrix[last][last - offset] = matrix[i][last]</code> (which is <code>matrix[first + offset][last]</code>)</li><li>Saved Top element moves to Right: <code>matrix[i][last] = top</code></li></ol></li></ul></li></ul></li></ul></li></ol><hr><p><strong>Section 5.20: Compute Rows in Pascal&rsquo;s Triangle (Page 29-30 / PDF Page 65-66 in your full book)</strong></p><p><strong>The Problem:</strong>
You are asked to generate the first <code>n</code> rows of Pascal&rsquo;s Triangle.
Pascal&rsquo;s Triangle has a specific structure:</p><ul><li>The first row (Row 0 conceptually) is just <code>[1]</code>.</li><li>Each subsequent row has one more element than the previous row.</li><li>The first and last element of every row is <code>1</code>.</li><li>Every other element in a row is the sum of the two elements directly above it (to its left and right) in the previous row.</li></ul><p><strong>Figure 5.5 Example (First 5 rows):</strong></p><pre tabindex=0><code>Row 0:         1
Row 1:        1 1
Row 2:       1 2 1
Row 3:      1 3 3 1
Row 4:     1 4 6 4 1
</code></pre><p><strong>Input:</strong> A non-negative integer <code>n</code> (number of rows to generate).
<strong>Output:</strong> A list of lists, where each inner list represents a row of Pascal&rsquo;s Triangle.</p><p><strong>Example:</strong>
If <code>n = 5</code>, output should be:</p><pre tabindex=0><code>[
  [1],
  [1, 1],
  [1, 2, 1],
  [1, 3, 3, 1],
  [1, 4, 6, 4, 1]
]
</code></pre><p><strong>The Core Rule (from the problem description):</strong>
&ldquo;the <em>j</em>-th entry in the <em>i</em>-th row is 1 if <em>j</em> = 0 or <em>j</em> = <em>i</em>, otherwise it is the sum of the (<em>j</em> - 1)-th and <em>j</em>-th entries in the (<em>i</em> - 1)-th row.&rdquo;
(Assuming 0-indexed rows <code>i</code> and 0-indexed entries <code>j</code> within a row).</p><p>Let <code>Triangle[i][j]</code> be the element at row <code>i</code>, column <code>j</code>.</p><ul><li><code>Triangle[i][0] = 1</code></li><li><code>Triangle[i][i] = 1</code> (since row <code>i</code> has <code>i+1</code> elements, so index <code>i</code> is the last one)</li><li><code>Triangle[i][j] = Triangle[i-1][j-1] + Triangle[i-1][j]</code> for <code>0 &lt; j &lt; i</code>.</li></ul><p><strong>Implementation Idea (Building Row by Row):</strong></p><ol><li>Initialize an empty list <code>pascal_triangle_result = []</code>.</li><li>Iterate <code>i</code> from <code>0</code> to <code>n-1</code> (to generate <code>n</code> rows, which will be Row 0 to Row <code>n-1</code>).<ul><li>For each <code>i</code>, create a <code>current_row</code> list. Row <code>i</code> will have <code>i+1</code> elements.</li><li>The first element of <code>current_row</code> (<code>current_row[0]</code>) is always <code>1</code>.</li><li>The last element of <code>current_row</code> (<code>current_row[i]</code>) is always <code>1</code> (if <code>i > 0</code>).</li><li>For the elements in between (from <code>j=1</code> to <code>j=i-1</code>):<ul><li><code>current_row[j] = pascal_triangle_result[i-1][j-1] + pascal_triangle_result[i-1][j]</code>.</li><li>This means we need access to the <em>previous row</em> (<code>pascal_triangle_result[i-1]</code>) that we already computed and stored.</li></ul></li><li>Add <code>current_row</code> to <code>pascal_triangle_result</code>.</li></ul></li><li>Return <code>pascal_triangle_result</code>.</li></ol><p><strong>The Code Explained (<code>generate_pascal_triangle</code> - from the book):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_pascal_triangle</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize the result list.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># The book&#39;s list comprehension initializes with all 1s, which is clever</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># because the first and last elements of each row are always 1.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Triangle[i] will have i+1 elements.</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n)]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Example for n=3: result will be [[1], [1,1], [1,1,1]]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Iterate from the third row (index 2) onwards, because Row 0 and Row 1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># are already correctly filled with all 1s by the initialization.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n): <span style=color:#75715e># Iterate through rows</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Iterate through elements in the current row &#39;i&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># We need to calculate elements from index 1 up to index i-1</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># (since index 0 and index i are already 1).</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, i): <span style=color:#75715e># This loop only runs if i &gt;= 2</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Sum of the two elements directly above in the previous row</span>
</span></span><span style=display:flex><span>            result[i][j] <span style=color:#f92672>=</span> result[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> result[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p><strong>Let&rsquo;s trace for <code>n=4</code>:</strong></p><ol><li><p><code>result = [[1] * (i + 1) for i in range(4)]</code>
<code>result = [[1], [1,1], [1,1,1], [1,1,1,1]]</code></p></li><li><p>Outer loop <code>for i in range(4)</code>:</p><ul><li><strong><code>i = 0</code>:</strong> Inner loop <code>for j in range(1, 0)</code> does not run. <code>result[0]</code> is <code>[1]</code>. Correct.</li><li><strong><code>i = 1</code>:</strong> Inner loop <code>for j in range(1, 1)</code> does not run. <code>result[1]</code> is <code>[1,1]</code>. Correct.</li><li><strong><code>i = 2</code>:</strong> (Generating Row 2: <code>[1,2,1]</code>)<ul><li>Inner loop <code>for j in range(1, 2)</code>:<ul><li><code>j = 1</code>:<ul><li><code>result[2][1] = result[2-1][1-1] + result[2-1][1]</code></li><li><code>result[2][1] = result[1][0] + result[1][1]</code></li><li><code>result[2][1] = 1 + 1 = 2</code>.</li></ul></li></ul></li><li><code>result[2]</code> is now <code>[1, 2, 1]</code>. Correct. (It was <code>[1,1,1]</code>, element at index 1 got updated).</li></ul></li><li><strong><code>i = 3</code>:</strong> (Generating Row 3: <code>[1,3,3,1]</code>)<ul><li>Inner loop <code>for j in range(1, 3)</code>:<ul><li><code>j = 1</code>:<ul><li><code>result[3][1] = result[3-1][1-1] + result[3-1][1]</code></li><li><code>result[3][1] = result[2][0] + result[2][1]</code></li><li><code>result[3][1] = 1 + 2 = 3</code>.</li></ul></li><li><code>j = 2</code>:<ul><li><code>result[3][2] = result[3-1][2-1] + result[3-1][2]</code></li><li><code>result[3][2] = result[2][1] + result[2][2]</code></li><li><code>result[3][2] = 2 + 1 = 3</code>.</li></ul></li></ul></li><li><code>result[3]</code> is now <code>[1, 3, 3, 1]</code>. Correct.</li></ul></li></ul></li><li><p>Return <code>result</code>.</p></li></ol><p><strong>Complexity:</strong></p><ul><li>The number of elements in Pascal&rsquo;s triangle up to row <code>n-1</code> is <code>1 + 2 + ... + n = n*(n+1)/2</code>.</li><li>Each element is computed in <code>O(1)</code> time (one addition).</li><li><strong>Time Complexity:</strong> <code>O(n^2)</code>.</li><li><strong>Space Complexity:</strong> <code>O(n^2)</code> to store the triangle.</li></ul><p><strong>Variant: Compute only the <code>n</code>-th row of Pascal&rsquo;s triangle using <code>O(n)</code> space.</strong>
(Here <code>n</code> would mean Row <code>n</code>, e.g., if input is <code>3</code>, compute Row 3 <code>[1,3,3,1]</code>).</p><ul><li><strong>Idea:</strong> To compute Row <code>i</code>, you only need Row <code>i-1</code>. You don&rsquo;t need Row <code>i-2</code>, Row <code>i-3</code>, etc.</li><li>So, you can keep track of just two rows: <code>previous_row</code> and <code>current_row</code>.</li><li>Initialize <code>previous_row = [1]</code>.</li><li>Loop <code>k</code> from 1 up to <code>n</code> (to compute up to Row <code>n</code>):<ul><li><code>current_row</code> will have <code>k+1</code> elements.</li><li><code>current_row[0] = 1</code>, <code>current_row[k] = 1</code>.</li><li>For <code>j</code> from <code>1</code> to <code>k-1</code>: <code>current_row[j] = previous_row[j-1] + previous_row[j]</code>.</li><li>Set <code>previous_row = current_row</code> for the next iteration.</li></ul></li><li>The final <code>current_row</code> (or <code>previous_row</code> after the loop) is the answer.</li><li>This takes <code>O(n)</code> iterations to get to the <code>n</code>-th row. Each iteration does <code>O(k)</code> work (where <code>k</code> goes up to <code>n</code>). Total time: <code>O(1+2+...+n) = O(n^2)</code>.</li><li><strong>Space:</strong> <code>O(n)</code> because we only store two rows at a time, each of length at most <code>n+1</code>.</li><li><strong>Further Optimization for O(n) space, O(n^2) time (generating k-th row):</strong>
You can even do it with a single array of size <code>k+1</code> by computing the values for the next row <em>in reverse order</em> within that array. If <code>row</code> stores row <code>i-1</code>, to compute row <code>i</code> in place:
<code>row[j] = row[j] + row[j-1]</code> for <code>j</code> from <code>i-1</code> down to <code>1</code>.
The <code>row[0]</code> remains 1. You&rsquo;d need to append a 1 at the end for <code>row[i]</code>.</li></ul><p><strong>Interview Takeaway:</strong></p><ul><li>Tests basic 2D array/list of lists manipulation.</li><li>Understanding the recursive definition of Pascal&rsquo;s triangle is key.</li><li>The <code>O(n^2)</code> time and space for generating all <code>n</code> rows is standard.</li><li>The variant tests if you can optimize space when only the last result is needed, a common DP optimization technique (reducing space by noticing limited dependencies).</li></ul></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer></body></html>