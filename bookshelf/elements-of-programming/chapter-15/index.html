<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul></nav></header><main><article class=book-single><h1>Chapter 15: Recursion</h1><span class=reading-time><em>15 min read</em></span><div class=book-details><div class=book-content><h1 id=recursion>Recursion</h1><p><strong>Core Idea of Recursion</strong>: At its simplest, recursion means a function calls itself to solve a smaller version of the same problem.</p><p><a href=https://aistudio.google.com/prompts/1iT6e8TzouWLkMJqnlyvEmF3SBLGpkJJr>Prompt Link</a>(my private discussion for this chapter using ai studio and this chapters main system prompt)</p><p>Two Key Ingredients :</p><ul><li><strong>Base Cases</strong>: These are the simplest instances of the problem that the function can solve directly, without further recursion.
Intuition: &ldquo;When do I know the answer without asking for more help?&rdquo;</li><li><strong>Progress (Recursive Call with different arguments):</strong> The function must call itself with arguments that move it closer to a base case. If it doesn&rsquo;t make progress, it&rsquo;ll loop forever.</li></ul><p>Recursion: The &ldquo;Ask a Mini-Me&rdquo; Approach:</p><p>Imagine you&rsquo;re a kid and your parent asks you to clean your entire room. It&rsquo;s a disaster. Toys everywhere.
You (the function): &ldquo;Ugh, this is too much!&rdquo;</p><p>Your thought process:</p><ul><li>Base Case (Simplest Job): &ldquo;Is there just ONE toy left on the floor?&rdquo; If yes, you pick it up. Done! Easy.</li><li>Recursive Step (Making it Simpler): &ldquo;Okay, there&rsquo;s more than one toy. What if I pick up just one toy and put it away? Now the room is slightly cleaner. The remaining mess is a smaller version of the original problem.&rdquo;</li><li>The &ldquo;Call a Mini-Me&rdquo;: &ldquo;Hey, Mini-Me (you call yourself again), can you clean this slightly cleaner room?&rdquo;
Trusting Mini-Me: You assume Mini-Me will somehow get the job done.
What you do after Mini-Me is done: Nothing! You already did your one piece of work (picking up one toy).</li></ul><p><strong>Why is recursion useful?</strong></p><ul><li>When the input itself is recursive (like file system directories, or a computer grammar).</li><li>For problems like searching, enumeration (listing all possibilities), and divide-and-conquer.</li></ul><p><strong>Divide-and-Conquer vs. Recursion:</strong></p><ul><li>Divide-and-Conquer: A strategy. It breaks a problem into independent smaller subproblems of the same type, solves them, and combines their solutions. Merge Sort is a classic.</li><li>Recursion: A technique. It&rsquo;s how you often implement divide-and-conquer. But recursion is more general. You might have only one subproblem (like binary search or factorial), or the subproblems might not be independent (hello, Dynamic Programming!).</li></ul><hr><p><strong>Example: Counting Down</strong></p><p>Let&rsquo;s say you want to write a function that prints numbers from N down to 1.
countdown(N):</p><p>Job: Print N, then N-1, then N-2, &mldr;, down to 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>countdown</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># Base case: stop when we reach 0 (or 1, if you prefer to print 1)</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Blast off!&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>      <span style=color:#75715e># This is important! Stop the recursion.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    print(n)          <span style=color:#75715e># Do a small piece of work</span>
</span></span><span style=display:flex><span>    countdown(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># Ask a &#34;mini-me&#34; to do the rest (a smaller version)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>countdown(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Output:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Blast off!</span>
</span></span></code></pre></div><hr><h1 id=1-recursion-boot-camp>1. Recursion boot camp</h1><ol><li><p>Euclidean Algorithm for GCD (Greatest Common Divisor)</p><ul><li>Problem: Find the largest number that divides both x and y without a remainder.</li><li>Core Idea (from the book): GCD(x, y) is the same as GCD(y, x % y). (Assuming x > y, initially it might be GCD(x-y, y) repeatedly, which simplifies to GCD(x % y, y) and then swapping to keep the first argument larger or just using GCD(y, x%y)).</li></ul></li></ol><p>Let&rsquo;s think recursively:
def gcd(x, y):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gcd</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Base case: if y is 0, then x is the GCD.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Think: GCD(12, 0) -&gt; what&#39;s the largest number that divides 12 and 0? It&#39;s 12.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#66d9ef>if</span> y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> gcd(y, x <span style=color:#f92672>%</span> y)
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><ul><li><strong>The &ldquo;Work&rdquo;</strong>: The % (modulo) operation is the work that makes the problem smaller.</li><li><strong>&ldquo;Smaller&rdquo;</strong>: The numbers y and x % y are generally smaller than x and y. Specifically, x % y is guaranteed to be less than y.</li><li><strong>Base Case</strong>: y == 0. When the second number is zero, the first number is the GCD. GCD(12, 0) = 12.</li></ul><hr><h1 id=2-mutilated-chessboard-page-218>2. Mutilated Chessboard (Page 218)</h1><p>This is a fantastic example of <strong>divide-and-conquer</strong>.</p><h3 id=-problem>🧩 Problem</h3><p>Cover an <code>8x8</code> board with <strong>one square missing</strong> (mutilated) using <strong>L-shaped triominoes</strong> (3 squares each).</p><ul><li>Total squares: 63</li><li>Required triominoes: 21</li></ul><h3 id=-epis-reasoning>💡 EPI&rsquo;s Reasoning</h3><blockquote><p>Don’t think <code>n → n+1</code>. That’s a dead end.<br>Instead, think:<br><strong>If I can solve for an <code>n x n</code> Mboard, can I solve for a <code>2n x 2n</code> Mboard?</strong></p></blockquote><h3 id=-the-aha-insight-figure-151b>✨ The &ldquo;Aha!&rdquo; Insight (Figure 15.1(b))</h3><ol><li><strong>Imagine a <code>2n x 2n</code> board</strong>.</li><li><strong>Divide it into four <code>n x n</code> quadrants</strong>.</li><li>One quadrant <strong>contains the original missing square</strong>.<ul><li>This is already an <code>n x n</code> <strong>Mboard</strong> (mutilated board) — by hypothesis, we can tile it!</li></ul></li><li>The <strong>other three quadrants</strong> are not Mboards yet.</li></ol><h3 id=-clever-step>🧠 Clever Step</h3><ul><li><strong>Place one triomino</strong> in the <strong>center of the <code>2n x 2n</code> board</strong>.</li><li>Align it such that it <strong>covers one corner square from each of the three &ldquo;full&rdquo; <code>n x n</code> quadrants</strong>.</li><li>This action <strong>creates a new missing square in each of the three quadrants</strong>, turning them into Mboards!</li></ul><p>By hypothesis, we can now <strong>tile all four <code>n x n</code> Mboards</strong> — problem solved!</p><hr><h1 id=3--table-151-top-tips-for-recursion-page-219>3. 📘 Table 15.1: Top Tips for Recursion <em>(Page 219)</em></h1><h3 id=1---recursive-rules-input>1. 🔁 <strong>Recursive Rules Input</strong></h3><p>If the <strong>problem description sounds recursive</strong>, then recursion is a natural fit.</p><blockquote><p>Example: <em>&ldquo;A directory contains files and other directories.&rdquo;</em></p></blockquote><h3 id=2--search-enumerate-divide-and-conquer>2. 🧭 <strong>Search, Enumerate, Divide-and-Conquer</strong></h3><p>These problem types are <strong>prime candidates</strong> for recursion:</p><ul><li><p><strong>🔍 Search:</strong><br>&ldquo;Is the item in the left half? Or the right half?&rdquo;<br><em>→ Example: Binary Search</em></p></li><li><p><strong>📋 Enumerate:</strong><br>&ldquo;What if I pick this? What are the options then? What if I don’t pick this?&rdquo;<br><em>→ Example: Generating all subsets</em></p></li><li><p><strong>🧩 Divide-and-Conquer:</strong><br>Break the problem into smaller subproblems of the same type.</p></li></ul><h3 id=3--alternative-to-nested-loops-of-undefined-depth>3. 🔄 <strong>Alternative to Nested Loops (of Undefined Depth)</strong></h3><p>When you <strong>don’t know how many nested loops</strong> you’ll need (e.g., problems with variable segments like IP address parsing),<br>recursion <strong>gracefully handles varying depth</strong>.</p><h3 id=4--removing-recursion-mimic-the-call-stack>4. 🧱 <strong>Removing Recursion (Mimic the Call Stack)</strong></h3><p>If you&rsquo;re asked to <strong>make a recursive solution iterative</strong>:</p><blockquote><p>Use your own <strong>stack data structure</strong> to keep track of “what to do next.”</p></blockquote><h3 id=5--tail-recursion>5. 🎯 <strong>Tail Recursion</strong></h3><p>If the <strong>recursive call is the last operation</strong> in the function, it can often be <strong>converted into a loop</strong>.</p><blockquote><p>Note: <strong>Python does not optimize tail recursion</strong>, but understanding it is still valuable.</p></blockquote><h3 id=6--caching-repeated-calls-memoization>6. 💾 <strong>Caching Repeated Calls (Memoization)</strong></h3><p>If your recursive function <strong>recomputes the same result</strong> multiple times:</p><ul><li><strong>Store the result</strong> (e.g., <code>fib(3)</code> is needed by both <code>fib(5)</code> and <code>fib(4)</code>)</li><li>This is the <strong>gateway to Dynamic Programming</strong>!</li></ul><hr><h1 id=-problem-151-the-towers-of-hanoi-page-219>🧠 Problem 15.1: The Towers of Hanoi (Page 219)</h1><p>This is a <strong>classic recursion problem</strong>.<br>If you understand this one, you&rsquo;ve got a solid grasp of <strong>basic recursive thinking</strong>.</p><h3 id=-the-setup>🏗️ The Setup</h3><ul><li><p><strong>Three pegs:</strong></p><ul><li><code>P1</code> → Source</li><li><code>P2</code> → Destination</li><li><code>P3</code> → Auxiliary / Helper</li></ul></li><li><p><strong>n disks</strong> of decreasing sizes stacked on <code>P1</code>:</p><ul><li>Largest at the <strong>bottom</strong>, smallest at the <strong>top</strong></li></ul></li><li><p><strong>Goal:</strong><br>Move <strong>all <code>n</code> disks</strong> from <code>P1</code> to <code>P2</code>.</p></li></ul><h3 id=-rules>📏 Rules</h3><ol><li>Only <strong>one disk</strong> can be moved at a time.</li><li>A disk can <strong>only be moved</strong> if it is the <strong>top disk</strong> on a peg.</li><li>A <strong>larger disk</strong> can <strong>never</strong> be placed on top of a <strong>smaller disk</strong>.</li></ol><h3 id=-task>🧾 Task</h3><p>Write a <strong>program that prints the sequence of operations</strong><br>required to move all <code>n</code> disks from <code>P1</code> to <code>P2</code>, obeying the rules.</p><p>The recursive solution has a pattern:</p><p>If n > 0:</p><ol><li>Hanoi(n-1, src, aux, dest)</li><li>Move disk n from src to dest</li><li>Hanoi(n-1, aux, dest, src)</li></ol><p>Define the recursive function:</p><p>compute_tower_hanoi_steps(num_rings_to_move, from_peg, to_peg, use_peg)</p><p>Base Case:</p><ul><li>If num_rings_to_move == 0: do nothing.</li><li>If num_rings_to_move == 1: move the single disk from from_peg to to_peg.</li></ul><p>Note: The EPI book uses an implicit base case with <code>if num_rings_to_move > 0:</code>. This works because:</p><ul><li>When num_rings_to_move == 1, the first recursive call is with 0 disks (no action),</li><li>then it moves the disk,</li><li>then a second call with 0 disks (again, no action).
This pattern is correct and avoids explicitly writing a base case. However, using <code>num_rings_to_move == 1</code> explicitly can improve clarity when learning recursion.</li></ul><p>Recursive Step (if num_rings_to_move > 1):</p><ol><li>Move (n - 1) disks from from_peg to use_peg using to_peg as a temporary:
compute_tower_hanoi_steps(num_rings_to_move - 1, from_peg, use_peg, to_peg)</li><li>Move the nth disk (the largest in this subproblem) from from_peg to to_peg:
print(&ldquo;Move disk&rdquo;, num_rings_to_move, &ldquo;from&rdquo;, from_peg, &ldquo;to&rdquo;, to_peg)
(In EPI: pegs[to_peg].append(pegs[from_peg].pop()); result.append(&mldr;))</li><li>Move (n - 1) disks from use_peg to to_peg using from_peg as a temporary:
compute_tower_hanoi_steps(num_rings_to_move - 1, use_peg, to_peg, from_peg)</li></ol><hr><h3 id=backtracking-and-recursion-pre-requiste>Backtracking and Recursion Pre-requiste</h3><h4 id=goal>Goal</h4><p>Find all 2-letter &ldquo;words&rdquo; using letters from &ldquo;ABC&rdquo;, where each letter is used at most once.<br><strong>Expected Output:</strong> &ldquo;AB&rdquo;, &ldquo;AC&rdquo;, &ldquo;BA&rdquo;, &ldquo;BC&rdquo;, &ldquo;CA&rdquo;, &ldquo;CB&rdquo;</p><p><strong>Recursive Function</strong>
Let our recursive function be:<br><code>find_words(current_word, used_letters)</code></p><p><strong>Base Case</strong>
If <code>len(current_word) == 2</code>:</p><ul><li>We&rsquo;ve built a 2-letter word.</li><li>Add it to the list of solutions.</li><li>Return.</li></ul><p><strong>Recursive Step</strong>
Iterate through each letter in <code>"ABC"</code>:</p><ul><li>Check if the letter is already in <code>used_letters</code>.</li><li>If the letter is <strong>not used</strong>:<br>a. <strong>Place / Choose</strong><ul><li>Add the letter to <code>current_word</code></li><li>Add the letter to <code>used_letters</code><br>b. <strong>Recurse</strong></li><li>Call <code>find_words(current_word, used_letters)</code><br>c. <strong>Backtrack / Undo</strong></li><li>Remove the letter from <code>current_word</code></li><li>Remove the letter from <code>used_letters</code></li></ul></li></ul><p>Backtracking ensures the state is clean when trying the next available letter.</p><p><strong>Visualization of This Simpler Problem</strong></p><p>Imagine you have 3 slots to pick from: A, B, C. You are building a 2-letter word.</p><p>1st letter choice:<br>Pick &lsquo;A&rsquo;<br>→ Now need 1 more letter.<br>→ Used: {&lsquo;A&rsquo;}<br>→ Word so far: &ldquo;A&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;A&rsquo;):<br>Pick &lsquo;B&rsquo;<br>→ Word is &ldquo;AB&rdquo; — Done! (Base case)<br>Backtrack: Forget &lsquo;B&rsquo;<br>→ Word so far: &ldquo;A&rdquo;<br>→ Used: {&lsquo;A&rsquo;}</p><p>Pick &lsquo;C&rsquo;<br>→ Word is &ldquo;AC&rdquo; — Done! (Base case)<br>Backtrack: Forget &lsquo;C&rsquo;<br>→ Word so far: &ldquo;A&rdquo;<br>→ Used: {&lsquo;A&rsquo;}</p><p>Backtrack: Forget &lsquo;A&rsquo;<br>→ Word so far: ""<br>→ Used: {}</p><p>Pick &lsquo;B&rsquo;<br>→ Now need 1 more letter.<br>→ Used: {&lsquo;B&rsquo;}<br>→ Word so far: &ldquo;B&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;B&rsquo;):<br>Pick &lsquo;A&rsquo;<br>→ Word is &ldquo;BA&rdquo; — Done!<br>Backtrack: Forget &lsquo;A&rsquo;<br>→ Word so far: &ldquo;B&rdquo;<br>→ Used: {&lsquo;B&rsquo;}</p><p>Pick &lsquo;C&rsquo;<br>→ Word is &ldquo;BC&rdquo; — Done!<br>Backtrack: Forget &lsquo;C&rsquo;<br>→ Word so far: &ldquo;B&rdquo;<br>→ Used: {&lsquo;B&rsquo;}</p><p>Backtrack: Forget &lsquo;B&rsquo;<br>→ Word so far: ""<br>→ Used: {}</p><p>Pick &lsquo;C&rsquo;<br>→ Now need 1 more letter.<br>→ Used: {&lsquo;C&rsquo;}<br>→ Word so far: &ldquo;C&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;C&rsquo;):<br>Pick &lsquo;A&rsquo;<br>→ Word is &ldquo;CA&rdquo; — Done!<br>Backtrack: Forget &lsquo;A&rsquo;<br>→ Word so far: &ldquo;C&rdquo;<br>→ Used: {&lsquo;C&rsquo;}</p><p>Pick &lsquo;B&rsquo;<br>→ Word is &ldquo;CB&rdquo; — Done!<br>Backtrack: Forget &lsquo;B&rsquo;<br>→ Word so far: &ldquo;C&rdquo;<br>→ Used: {&lsquo;C&rsquo;}</p><p>Backtrack: Forget &lsquo;C&rsquo;<br>→ Word so far: ""<br>→ Used: {}</p><p>Here the Undo part ( Backtrack ) is <strong>EXPLICIT</strong> when we do &ldquo;FORGET&rdquo; aplhabet (A/B/C)</p><h3 id=when-is-the-on-simple-iterative-solution-good-enough>When is the O(N²) Simple Iterative Solution &ldquo;Good Enough&rdquo;?</h3><p><strong>Preferred When:</strong></p><ul><li>The <strong>depth of choices is small and fixed</strong> (e.g., K = 2).</li><li>The <strong>state between choices is minimal</strong>.</li><li><strong>Raw performance</strong> is critical and recursion’s function call overhead, though usually minor, matters.</li></ul><p><strong>Mental Model:</strong></p><ul><li><p><strong>Iterative Nested Loops</strong>:</p><ul><li>Best for <strong>fixed, shallow decision trees</strong>.</li><li>Like building with a <strong>fixed number of Lego blocks</strong> in a specific sequence.</li></ul></li><li><p><strong>Recursive Backtracking</strong>:</p><ul><li>Best for <strong>variable-depth or complex decision trees</strong>.</li><li>Like exploring a <strong>maze with unknown turns and constraints</strong>.</li><li><strong>BACKTRACKING HELPS FIND ALL POSSIBLE SOLUTIONS</strong></li></ul></li></ul><hr><h1 id=-152-generate-all-nonattacking-placements-of-n-queens-page-221>♛ 15.2 GENERATE ALL NONATTACKING PLACEMENTS OF N-QUEENS (Page 221)</h1><p><strong>Goal:</strong> Place N queens on an N×N chessboard such that no two queens attack each other.</p><h3 id=-the-problem>🧩 The Problem:</h3><ul><li>Given an <strong>N × N</strong> chessboard.</li><li>Place <strong>N queens</strong> on the board such that <strong>no two queens attack each other</strong>.</li></ul><h4 id=-attack-rules>⚔️ Attack Rules:</h4><ul><li>Queens can attack <strong>horizontally</strong>, <strong>vertically</strong>, and <strong>diagonally</strong>.</li></ul><h4 id=-goal>🎯 Goal:</h4><ul><li>Return <strong>all distinct configurations</strong> (valid placements) of these N queens.</li></ul><h3 id=-task-1>🧾 Task</h3><p>Exact problem: Place exactly <strong>one queen per row</strong>. Find <strong>ALL</strong> Possible combinations</p><p>Recusrion Backtracking: &ldquo;choose, explore, undo&rdquo; pattern</p><p><strong>TLDR;</strong></p><ul><li><strong>How it happens in N-Queens (EPI style):</strong><ol><li>You are trying to place a queen in <code>Row X</code>.</li><li>You try putting it in <code>Column A</code>. <code>board_config[X] = A</code>.</li><li>You recursively try to solve for <code>Row X+1</code> and beyond.</li><li>When that recursion finishes and returns, you are still in the loop for <code>Row X</code>.</li><li>Next, you try putting the queen for <code>Row X</code> in <code>Column B</code>.</li><li><strong>The &ldquo;Undo&rdquo;</strong>: <code>board_config[X] = B</code> <strong>overwrites</strong> <code>board_config[X] = A</code>. The choice of <code>A</code> for <code>Row X</code> is now gone for future explorations from <code>Row X</code>.</li></ol></li></ul><p><strong>Recursive Function Idea: solve_queens(row_to_place_in, current_board_config)</strong></p><ol><li><p><strong>&ldquo;Building the solution piece by piece&rdquo;</strong> (like building the word letter by letter):</p><ul><li>In N-Queens: We are trying to decide the <strong>column</strong> for the queen in the <code>row_to_place_in</code>.</li><li>This is like deciding the next letter for our word.</li></ul></li><li><p><strong>&ldquo;What choices do I have for the current piece?&rdquo;</strong></p><ul><li>Alphabet problem: Choose any unused letter from &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;.</li><li>N-Queens: For the current <code>row_to_place_in</code>, try placing the queen in <strong>column 0</strong>, then <strong>column 1</strong>, then <strong>column 2</strong>, &mldr;, up to <strong>column N-1</strong>.</li></ul></li><li><p><code>solve_queens(row, placement)</code> (where <code>placement[r]</code> stores the column of the queen in row <code>r</code>)</p><ul><li><p><strong>Base Case (Solution Found)</strong>:</p><ul><li>Alphabet: <code>if len(current_word) == K_target_length:</code> Solution found.</li><li>N-Queens: <code>if row == N:</code> We have successfully placed queens in row 0 to N-1. All N queens are on the board. This is a valid complete solution.<ul><li><strong>Action</strong>: Add a copy of <code>placement</code> to our list of results. Return.</li></ul></li></ul></li><li><p><strong>Recursive Step (Trying to place a queen in the current <code>row</code>)</strong>:</p><ul><li>Loop through all possible choices for this step:<ul><li><p>Alphabet: <code>for each_letter in available_letters:</code></p></li><li><p>N-Queens: <code>for col_choice from 0 to N-1:</code> (This is trying each column for the queen in the current <code>row</code>)</p></li><li><p><strong>Check if the choice is valid/allowed</strong>:</p><ul><li>Alphabet: <code>if each_letter not in used_letters:</code></li><li>N-Queens: <code>if is_safe_to_place_queen_at(row, col_choice, placement_so_far):</code><ul><li>The <code>is_safe_to_place_queen_at</code> function checks:<ol><li>Is <code>col_choice</code> already taken by a queen in a previous row (<code>placement[prev_row] == col_choice</code>)?</li><li>Is <code>(row, col_choice)</code> on a diagonal with any queen in a previous row<br>(<code>abs(placement[prev_row] - col_choice) == abs(prev_row - row)</code>)?</li></ol></li></ul></li></ul></li><li><p><strong>If the choice IS VALID/SAFE</strong>:
a. <strong>&ldquo;Place&rdquo; / Make the Choice</strong>:</p><ul><li>Alphabet: <code>current_word.append(each_letter)</code>, <code>used_letters.add(each_letter)</code></li><li>N-Queens: <code>placement[row] = col_choice</code> (We’ve decided the queen for the current <code>row</code> goes in <code>col_choice</code>)</li></ul><p>b. <strong>&ldquo;Explore&rdquo; / Recurse</strong> (Try to complete the rest of the solution based on this choice):</p><ul><li>Alphabet: <code>find_words(current_word, used_letters)</code> (which internally will try to fill the next letter position)</li><li>N-Queens: <code>solve_queens(row + 1, placement)</code> (Try to place queens for all subsequent rows, starting with the very next row)</li></ul><p>c. <strong>&ldquo;Backtrack&rdquo; / Undo the Choice</strong> (CRUCIAL for exploring other options for the current step):</p><ul><li>Alphabet: current_word.pop(), used_letters.remove(each_letter)</li><li>N-Queens: This is where the EPI code is a bit more implicit.</li><li>When the <code>solve_queens(row + 1, placement)</code> call returns (meaning it has fully explored all possibilities from placing a queen at <code>(row, col_choice)</code>, or it hit a dead end), the execution comes back to the for <code>col_choice ... loop.</code></li><li>If the loop continues to the next col_choice for the same current row, the line <code>placement[row] = new_col_choice</code> will simply overwrite the previous col_choice. This acts as the &ldquo;undo&rdquo; for the specific assignment to <code>placement[row]</code>.</li><li>If the for <code>col_choice ...</code> loop finishes for the current row (all columns tried), the solve_queens(row, placement) function itself returns. This signifies that all paths starting with the configuration of queens up to row-1 (that led to this call) have been explored for this particular row. The state <code>placement[0...row-1]</code> remains untouched by this returning function, allowing the caller (which was trying to place a queen in row-1) to potentially try a different column for row-1.</li></ul></li></ul></li></ul></li></ul></li></ol><h4 id=q-so-what-if-we-find-all-the-valid-placements-in-the-first-go-itself--then-dont-you-think-our-return-and-the-loop-for-placementrow--new_col_choice-iterating-further-undoing-our-setup-wasted-when-we-have-a-valid-placement>Q. so what if we find all the valid placements in the first go itself . Then don&rsquo;t you think our return and the loop for placement[row] = new_col_choice iterating further undoing our setup wasted when we Have a valid placement?</h4><p>You&rsquo;re asking: <strong>If a particular choice for <code>placement[row]</code> (say, <code>col_A</code>) leads to one or more valid complete solutions through the <code>solve(row+1, ...)</code> call, why does the <code>for</code> loop for <code>row</code> continue to try other columns (like <code>col_B</code>) for that same <code>row</code>?</strong> Isn&rsquo;t that wasted effort if we&rsquo;ve already found solutions?</p><p>The answer depends on the <strong>goal of the problem</strong>:</p><ul><li><p><strong>Goal: Find ALL distinct non-attacking placements (as in N-Queens).</strong><br>If the goal is to find <em>all</em> possible solutions, then no, <strong>it&rsquo;s not wasted</strong>. We <strong>must</strong> continue exploring.</p><ul><li>Just because placing a queen at <code>(row, col_A)</code> led to <em>some</em> solutions doesn&rsquo;t mean that placing a queen at <code>(row, col_B)</code> (if safe) <em>won&rsquo;t also</em> lead to <em>other, different</em> valid solutions.</li><li>The N-Queens problem specifically asks for <em>all distinct nonattacking placements</em>. To achieve this, the backtracking algorithm <strong>must</strong> systematically explore every possible valid path in the decision tree.</li><li>When <code>solve(row+1, ...)</code> returns after exploring the consequences of <code>placement[row] = col_A</code>, it has done its job for that branch. The <code>for</code> loop for <code>row</code> then <strong>must</strong> try <code>placement[row] = col_B</code> (and <code>col_C</code>, etc.) to see if those choices also lead to valid complete solutions.<br>Each of these will be a distinct branch.</li></ul></li><li><p><strong>Goal: Find ANY ONE non-attacking placement (or determine if one exists).</strong><br>If the problem was modified to &ldquo;find just <em>one</em> solution and then stop,&rdquo; then <strong>yes, you could optimize</strong>.</p><ul><li>In this scenario, your recursive function could return a boolean: <code>true</code> if a solution was found down that path, <code>false</code> otherwise.</li></ul></li></ul></div></div></article></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer></body></html>