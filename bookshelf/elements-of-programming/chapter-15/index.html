<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#recursion>Recursion</a></li><li><a href=#1-recursion-boot-camp>1. Recursion boot camp</a></li><li><a href=#2-mutilated-chessboard-page-218>2. Mutilated Chessboard (Page 218)</a><ul><li><ul><li><a href=#-problem>üß© Problem</a></li><li><a href=#-epis-reasoning>üí° EPI&rsquo;s Reasoning</a></li><li><a href=#-the-aha-insight-figure-151b>‚ú® The &ldquo;Aha!&rdquo; Insight (Figure 15.1(b))</a></li><li><a href=#-clever-step>üß† Clever Step</a></li></ul></li></ul></li><li><a href=#3--table-151-top-tips-for-recursion-page-219>3. üìò Table 15.1: Top Tips for Recursion <em>(Page 219)</em></a><ul><li><ul><li><a href=#1---recursive-rules-input>1. üîÅ Recursive Rules Input</a></li><li><a href=#2--search-enumerate-divide-and-conquer>2. üß≠ Search, Enumerate, Divide-and-Conquer</a></li><li><a href=#3--alternative-to-nested-loops-of-undefined-depth>3. üîÑ Alternative to Nested Loops (of Undefined Depth)</a></li><li><a href=#4--removing-recursion-mimic-the-call-stack>4. üß± Removing Recursion (Mimic the Call Stack)</a></li><li><a href=#5--tail-recursion>5. üéØ Tail Recursion</a></li><li><a href=#6--caching-repeated-calls-memoization>6. üíæ Caching Repeated Calls (Memoization)</a></li></ul></li></ul></li><li><a href=#-problem-151-the-towers-of-hanoi-page-219>üß† Problem 15.1: The Towers of Hanoi (Page 219)</a><ul><li><ul><li><a href=#-the-setup>üèóÔ∏è The Setup</a></li><li><a href=#-rules>üìè Rules</a></li><li><a href=#-task>üßæ Task</a></li><li><a href=#backtracking-and-recursion-pre-requiste>Backtracking and Recursion Pre-requiste</a></li><li><a href=#when-is-the-on-simple-iterative-solution-good-enough>When is the O(N¬≤) Simple Iterative Solution &ldquo;Good Enough&rdquo;?</a></li></ul></li></ul></li><li><a href=#-152-generate-all-nonattacking-placements-of-n-queens-page-221>‚ôõ 15.2 GENERATE ALL NONATTACKING PLACEMENTS OF N-QUEENS (Page 221)</a><ul><li><ul><li><a href=#-the-problem>üß© The Problem:</a></li><li><a href=#-task-1>üßæ Task</a></li></ul></li></ul></li><li><a href=#153-generate-permutations-page-222>15.3 GENERATE PERMUTATIONS (Page 222)</a></li><li><a href=#154-generate-the-power-set-page-224>15.4 GENERATE THE POWER SET (Page 224)</a></li><li><a href=#155-generate-all-subsets-of-size-k-page-226>15.5 GENERATE ALL SUBSETS OF SIZE k (Page 226)</a></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 15: Recursion</h1><span class=reading-time><em>29 min read</em></span><div class=book-details><div class=book-content><h1 id=recursion>Recursion</h1><p><strong>Core Idea of Recursion</strong>: At its simplest, recursion means a function calls itself to solve a smaller version of the same problem.</p><p><a href=https://aistudio.google.com/prompts/1iT6e8TzouWLkMJqnlyvEmF3SBLGpkJJr>Prompt Link</a>(my private discussion for this chapter using ai studio and this chapters main system prompt along with the pdf of this chapter)</p><p>Two Key Ingredients :</p><ul><li><strong>Base Cases</strong>: These are the simplest instances of the problem that the function can solve directly, without further recursion.
Intuition: &ldquo;When do I know the answer without asking for more help?&rdquo;</li><li><strong>Progress (Recursive Call with different arguments):</strong> The function must call itself with arguments that move it closer to a base case. If it doesn&rsquo;t make progress, it&rsquo;ll loop forever.</li></ul><p>Recursion: The &ldquo;Ask a Mini-Me&rdquo; Approach:</p><p>Imagine you&rsquo;re a kid and your parent asks you to clean your entire room. It&rsquo;s a disaster. Toys everywhere.
You (the function): &ldquo;Ugh, this is too much!&rdquo;</p><p>Your thought process:</p><ul><li>Base Case (Simplest Job): &ldquo;Is there just ONE toy left on the floor?&rdquo; If yes, you pick it up. Done! Easy.</li><li>Recursive Step (Making it Simpler): &ldquo;Okay, there&rsquo;s more than one toy. What if I pick up just one toy and put it away? Now the room is slightly cleaner. The remaining mess is a smaller version of the original problem.&rdquo;</li><li>The &ldquo;Call a Mini-Me&rdquo;: &ldquo;Hey, Mini-Me (you call yourself again), can you clean this slightly cleaner room?&rdquo;
Trusting Mini-Me: You assume Mini-Me will somehow get the job done.
What you do after Mini-Me is done: Nothing! You already did your one piece of work (picking up one toy).</li></ul><p><strong>Why is recursion useful?</strong></p><ul><li>When the input itself is recursive (like file system directories, or a computer grammar).</li><li>For problems like searching, enumeration (listing all possibilities), and divide-and-conquer.</li></ul><p><strong>Divide-and-Conquer vs. Recursion:</strong></p><ul><li>Divide-and-Conquer: A strategy. It breaks a problem into independent smaller subproblems of the same type, solves them, and combines their solutions. Merge Sort is a classic.</li><li>Recursion: A technique. It&rsquo;s how you often implement divide-and-conquer. But recursion is more general. You might have only one subproblem (like binary search or factorial), or the subproblems might not be independent (hello, Dynamic Programming!).</li></ul><hr><p><strong>Example: Counting Down</strong></p><p>Let&rsquo;s say you want to write a function that prints numbers from N down to 1.
countdown(N):</p><p>Job: Print N, then N-1, then N-2, &mldr;, down to 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>countdown</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># Base case: stop when we reach 0 (or 1, if you prefer to print 1)</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Blast off!&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>      <span style=color:#75715e># This is important! Stop the recursion.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    print(n)          <span style=color:#75715e># Do a small piece of work</span>
</span></span><span style=display:flex><span>    countdown(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># Ask a &#34;mini-me&#34; to do the rest (a smaller version)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>countdown(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Output:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Blast off!</span>
</span></span></code></pre></div><hr><h1 id=1-recursion-boot-camp>1. Recursion boot camp</h1><ol><li><p>Euclidean Algorithm for GCD (Greatest Common Divisor)</p><ul><li>Problem: Find the largest number that divides both x and y without a remainder.</li><li>Core Idea (from the book): GCD(x, y) is the same as GCD(y, x % y). (Assuming x > y, initially it might be GCD(x-y, y) repeatedly, which simplifies to GCD(x % y, y) and then swapping to keep the first argument larger or just using GCD(y, x%y)).</li></ul></li></ol><p>Let&rsquo;s think recursively:
def gcd(x, y):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gcd</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Base case: if y is 0, then x is the GCD.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Think: GCD(12, 0) -&gt; what&#39;s the largest number that divides 12 and 0? It&#39;s 12.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#66d9ef>if</span> y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> gcd(y, x <span style=color:#f92672>%</span> y)
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><ul><li><strong>The &ldquo;Work&rdquo;</strong>: The % (modulo) operation is the work that makes the problem smaller.</li><li><strong>&ldquo;Smaller&rdquo;</strong>: The numbers y and x % y are generally smaller than x and y. Specifically, x % y is guaranteed to be less than y.</li><li><strong>Base Case</strong>: y == 0. When the second number is zero, the first number is the GCD. GCD(12, 0) = 12.</li></ul><hr><h1 id=2-mutilated-chessboard-page-218>2. Mutilated Chessboard (Page 218)</h1><p>This is a fantastic example of <strong>divide-and-conquer</strong>.</p><h3 id=-problem>üß© Problem</h3><p>Cover an <code>8x8</code> board with <strong>one square missing</strong> (mutilated) using <strong>L-shaped triominoes</strong> (3 squares each).</p><ul><li>Total squares: 63</li><li>Required triominoes: 21</li></ul><h3 id=-epis-reasoning>üí° EPI&rsquo;s Reasoning</h3><blockquote><p>Don‚Äôt think <code>n ‚Üí n+1</code>. That‚Äôs a dead end.<br>Instead, think:<br><strong>If I can solve for an <code>n x n</code> Mboard, can I solve for a <code>2n x 2n</code> Mboard?</strong></p></blockquote><h3 id=-the-aha-insight-figure-151b>‚ú® The &ldquo;Aha!&rdquo; Insight (Figure 15.1(b))</h3><ol><li><strong>Imagine a <code>2n x 2n</code> board</strong>.</li><li><strong>Divide it into four <code>n x n</code> quadrants</strong>.</li><li>One quadrant <strong>contains the original missing square</strong>.<ul><li>This is already an <code>n x n</code> <strong>Mboard</strong> (mutilated board) ‚Äî by hypothesis, we can tile it!</li></ul></li><li>The <strong>other three quadrants</strong> are not Mboards yet.</li></ol><h3 id=-clever-step>üß† Clever Step</h3><ul><li><strong>Place one triomino</strong> in the <strong>center of the <code>2n x 2n</code> board</strong>.</li><li>Align it such that it <strong>covers one corner square from each of the three &ldquo;full&rdquo; <code>n x n</code> quadrants</strong>.</li><li>This action <strong>creates a new missing square in each of the three quadrants</strong>, turning them into Mboards!</li></ul><p>By hypothesis, we can now <strong>tile all four <code>n x n</code> Mboards</strong> ‚Äî problem solved!</p><hr><h1 id=3--table-151-top-tips-for-recursion-page-219>3. üìò Table 15.1: Top Tips for Recursion <em>(Page 219)</em></h1><h3 id=1---recursive-rules-input>1. üîÅ Recursive Rules Input</h3><p>If the <strong>problem description sounds recursive</strong>, then recursion is a natural fit.</p><blockquote><p>Example: <em>&ldquo;A directory contains files and other directories.&rdquo;</em></p></blockquote><h3 id=2--search-enumerate-divide-and-conquer>2. üß≠ Search, Enumerate, Divide-and-Conquer</h3><p>These problem types are <strong>prime candidates</strong> for recursion:</p><ul><li><p><strong>üîç Search:</strong><br>&ldquo;Is the item in the left half? Or the right half?&rdquo;<br><em>‚Üí Example: Binary Search</em></p></li><li><p><strong>üìã Enumerate:</strong><br>&ldquo;What if I pick this? What are the options then? What if I don‚Äôt pick this?&rdquo;<br><em>‚Üí Example: Generating all subsets</em></p></li><li><p><strong>üß© Divide-and-Conquer:</strong><br>Break the problem into smaller subproblems of the same type.</p></li></ul><h3 id=3--alternative-to-nested-loops-of-undefined-depth>3. üîÑ Alternative to Nested Loops (of Undefined Depth)</h3><p>When you <strong>don‚Äôt know how many nested loops</strong> you‚Äôll need (e.g., problems with variable segments like IP address parsing),<br>recursion <strong>gracefully handles varying depth</strong>.</p><h3 id=4--removing-recursion-mimic-the-call-stack>4. üß± Removing Recursion (Mimic the Call Stack)</h3><p>If you&rsquo;re asked to <strong>make a recursive solution iterative</strong>:</p><blockquote><p>Use your own <strong>stack data structure</strong> to keep track of ‚Äúwhat to do next.‚Äù</p></blockquote><h3 id=5--tail-recursion>5. üéØ Tail Recursion</h3><p>If the <strong>recursive call is the last operation</strong> in the function, it can often be <strong>converted into a loop</strong>.</p><blockquote><p>Note: <strong>Python does not optimize tail recursion</strong>, but understanding it is still valuable.</p></blockquote><h3 id=6--caching-repeated-calls-memoization>6. üíæ Caching Repeated Calls (Memoization)</h3><p>If your recursive function <strong>recomputes the same result</strong> multiple times:</p><ul><li><strong>Store the result</strong> (e.g., <code>fib(3)</code> is needed by both <code>fib(5)</code> and <code>fib(4)</code>)</li><li>This is the <strong>gateway to Dynamic Programming</strong>!</li></ul><hr><h1 id=-problem-151-the-towers-of-hanoi-page-219>üß† Problem 15.1: The Towers of Hanoi (Page 219)</h1><p>This is a <strong>classic recursion problem</strong>.<br>If you understand this one, you&rsquo;ve got a solid grasp of <strong>basic recursive thinking</strong>.</p><h3 id=-the-setup>üèóÔ∏è The Setup</h3><ul><li><p><strong>Three pegs:</strong></p><ul><li><code>P1</code> ‚Üí Source</li><li><code>P2</code> ‚Üí Destination</li><li><code>P3</code> ‚Üí Auxiliary / Helper</li></ul></li><li><p><strong>n disks</strong> of decreasing sizes stacked on <code>P1</code>:</p><ul><li>Largest at the <strong>bottom</strong>, smallest at the <strong>top</strong></li></ul></li><li><p><strong>Goal:</strong><br>Move <strong>all <code>n</code> disks</strong> from <code>P1</code> to <code>P2</code>.</p></li></ul><h3 id=-rules>üìè Rules</h3><ol><li>Only <strong>one disk</strong> can be moved at a time.</li><li>A disk can <strong>only be moved</strong> if it is the <strong>top disk</strong> on a peg.</li><li>A <strong>larger disk</strong> can <strong>never</strong> be placed on top of a <strong>smaller disk</strong>.</li></ol><h3 id=-task>üßæ Task</h3><p>Write a <strong>program that prints the sequence of operations</strong><br>required to move all <code>n</code> disks from <code>P1</code> to <code>P2</code>, obeying the rules.</p><p>The recursive solution has a pattern:</p><p>If n > 0:</p><ol><li>Hanoi(n-1, src, aux, dest)</li><li>Move disk n from src to dest</li><li>Hanoi(n-1, aux, dest, src)</li></ol><p>Define the recursive function:</p><p>compute_tower_hanoi_steps(num_rings_to_move, from_peg, to_peg, use_peg)</p><p>Base Case:</p><ul><li>If num_rings_to_move == 0: do nothing.</li><li>If num_rings_to_move == 1: move the single disk from from_peg to to_peg.</li></ul><p>Note: The EPI book uses an implicit base case with <code>if num_rings_to_move > 0:</code>. This works because:</p><ul><li>When num_rings_to_move == 1, the first recursive call is with 0 disks (no action),</li><li>then it moves the disk,</li><li>then a second call with 0 disks (again, no action).
This pattern is correct and avoids explicitly writing a base case. However, using <code>num_rings_to_move == 1</code> explicitly can improve clarity when learning recursion.</li></ul><p>Recursive Step (if num_rings_to_move > 1):</p><ol><li>Move (n - 1) disks from from_peg to use_peg using to_peg as a temporary:
compute_tower_hanoi_steps(num_rings_to_move - 1, from_peg, use_peg, to_peg)</li><li>Move the nth disk (the largest in this subproblem) from from_peg to to_peg:
print(&ldquo;Move disk&rdquo;, num_rings_to_move, &ldquo;from&rdquo;, from_peg, &ldquo;to&rdquo;, to_peg)
(In EPI: pegs[to_peg].append(pegs[from_peg].pop()); result.append(&mldr;))</li><li>Move (n - 1) disks from use_peg to to_peg using from_peg as a temporary:
compute_tower_hanoi_steps(num_rings_to_move - 1, use_peg, to_peg, from_peg)</li></ol><hr><h3 id=backtracking-and-recursion-pre-requiste>Backtracking and Recursion Pre-requiste</h3><p><strong>What is Backtracking? It&rsquo;s a Problem-Solving Technique (not a specific formula).</strong></p><p>Think of backtracking as a <strong>systematic way to explore all possible solutions to a problem, especially when the problem involves a sequence of choices.</strong></p><p>Imagine you&rsquo;re trying to find your way out of a maze:</p><ol><li><strong>You reach a junction (a decision point).</strong> You have multiple paths to choose from.</li><li><strong>You CHOOSE one path.</strong></li><li><strong>You EXPLORE that path.</strong><ul><li>If this path leads to the exit (a solution!), great! You might record it.</li><li>If this path leads to a dead end (not a solution, or violates a rule), or if you&rsquo;ve explored all it has to offer&mldr;</li></ul></li><li><strong>You BACKTRACK:</strong> You return to the junction where you made your last choice.</li><li><strong>You UNDO your previous choice</strong> (mentally or actually &ldquo;un-take&rdquo; that path).</li><li><strong>You CHOOSE a <em>different, unexplored</em> path</strong> from that same junction and explore it.</li><li>If all paths from a junction have been explored (and possibly led to dead ends), you backtrack even further to the <em>previous</em> junction.</li></ol><p><strong>Core Components of Backtracking:</strong></p><ol><li><p><strong>Problem Representation:</strong> The problem can be broken down into a sequence of decisions. The set of all possible decision sequences forms a &ldquo;search space&rdquo; or &ldquo;state-space tree.&rdquo;</p><ul><li><em>N-Queens:</em> Decision at each row = which column to place the queen.</li><li><em>Permutations:</em> Decision at each position = which available item to place.</li><li><em>Power Set:</em> Decision for each item = include it or exclude it.</li></ul></li><li><p><strong>Recursive Structure:</strong> Backtracking is almost always implemented using recursion because it naturally handles the &ldquo;explore deeper&rdquo; and &ldquo;return to previous state&rdquo; aspects.</p><ul><li>A function call represents making a set of choices up to a certain point and then trying to make the next choice.</li></ul></li><li><p><strong>The &ldquo;Try, Recurse, Undo&rdquo; Pattern (The Heart of Backtracking):</strong>
Inside a recursive backtracking function, for the current decision point:</p><ul><li><strong>Iterate through all possible CHOICES for the current step.</strong><ul><li>For each <code>choice</code>:
a. <strong>Validate the <code>choice</code>:</strong> Can I make this choice given the previous choices? (e.g., Is it safe to place a queen here? Is this letter already used?).
b. <strong>If <code>choice</code> is valid:</strong>
i. <strong>MAKE the <code>choice</code>:</strong> Update the current state (e.g., place the queen, add the letter to the word).
ii. <strong>EXPLORE (Recurse):</strong> Call the function recursively to make the <em>next</em> set of choices, building upon the current <code>choice</code>.
iii. <strong>UNDO the <code>choice</code> (Backtrack):</strong> Revert the state to what it was <em>before</em> making this <code>choice</code>. This is CRUCIAL. It allows the loop to correctly try the <em>next</em> possible <code>choice</code> for the <em>current</em> decision point without being affected by the exploration of the previous <code>choice</code>.</li></ul></li></ul></li><li><p><strong>Base Cases:</strong></p><ul><li><strong>Solution Found:</strong> The sequence of choices has led to a valid, complete solution. (e.g., N queens placed, word of K length formed). Record it.</li><li><strong>Dead End / Invalid Path:</strong> The current path of choices cannot possibly lead to a solution, or it violates a fundamental constraint. (e.g., no safe spot for the current queen). The function returns, triggering backtracking in the caller.</li></ul></li></ol><p><strong>Why is it called &ldquo;Backtracking&rdquo;?</strong>
Because when a path doesn&rsquo;t lead to a solution (or all solutions down that path have been found), the algorithm &ldquo;backtracks&rdquo; up the decision tree (i.e., recursive calls return) to a previous decision point to try a different option.</p><p><strong>Is it a formula?</strong>
No, it&rsquo;s more like a <strong>template</strong> or a <strong>strategy</strong> for designing algorithms. The specific implementation details (how state is stored, how choices are made, how validity is checked, how &ldquo;undo&rdquo; happens) vary from problem to problem.</p><p><strong>When to Think &ldquo;Backtracking&rdquo;:</strong></p><ul><li>You need to generate all possible configurations/solutions (permutations, combinations, subsets, placements).</li><li>The problem involves a sequence of decisions.</li><li>You can check the validity of a partial solution or a next choice.</li><li>You need to explore many possibilities, but some paths can be identified as &ldquo;dead ends&rdquo; early.</li></ul><p>Backtracking is the general search technique. The &ldquo;undo&rdquo; step is what makes it <em>backtracking</em> rather than just a one-way greedy search. Without the &ldquo;undo,&rdquo; you&rsquo;d explore one path and get stuck with its consequences. The &ldquo;undo&rdquo; allows you to say, &ldquo;Okay, that path (or sub-path) is done; let&rsquo;s rewind and try something else from my last major decision point.&rdquo;</p><h4 id=goal>Goal</h4><p>Find all 2-letter &ldquo;words&rdquo; using letters from &ldquo;ABC&rdquo;, where each letter is used at most once.<br><strong>Expected Output:</strong> &ldquo;AB&rdquo;, &ldquo;AC&rdquo;, &ldquo;BA&rdquo;, &ldquo;BC&rdquo;, &ldquo;CA&rdquo;, &ldquo;CB&rdquo;</p><p><strong>Recursive Function</strong>
Let our recursive function be:<br><code>find_words(current_word, used_letters)</code></p><p><strong>Base Case</strong>
If <code>len(current_word) == 2</code>:</p><ul><li>We&rsquo;ve built a 2-letter word.</li><li>Add it to the list of solutions.</li><li>Return.</li></ul><p><strong>Recursive Step</strong>
Iterate through each letter in <code>"ABC"</code>:</p><ul><li>Check if the letter is already in <code>used_letters</code>.</li><li>If the letter is <strong>not used</strong>:<br>a. <strong>Place / Choose</strong><ul><li>Add the letter to <code>current_word</code></li><li>Add the letter to <code>used_letters</code><br>b. <strong>Recurse</strong></li><li>Call <code>find_words(current_word, used_letters)</code><br>c. <strong>Backtrack / Undo</strong></li><li>Remove the letter from <code>current_word</code></li><li>Remove the letter from <code>used_letters</code></li></ul></li></ul><p>Backtracking ensures the state is clean when trying the next available letter.</p><p><strong>Visualization of This Simpler Problem</strong></p><p>Imagine you have 3 slots to pick from: A, B, C. You are building a 2-letter word.</p><p>1st letter choice:<br>Pick &lsquo;A&rsquo;<br>‚Üí Now need 1 more letter.<br>‚Üí Used: {&lsquo;A&rsquo;}<br>‚Üí Word so far: &ldquo;A&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;A&rsquo;):<br>Pick &lsquo;B&rsquo;<br>‚Üí Word is &ldquo;AB&rdquo; ‚Äî Done! (Base case)<br>Backtrack: Forget &lsquo;B&rsquo;<br>‚Üí Word so far: &ldquo;A&rdquo;<br>‚Üí Used: {&lsquo;A&rsquo;}</p><p>Pick &lsquo;C&rsquo;<br>‚Üí Word is &ldquo;AC&rdquo; ‚Äî Done! (Base case)<br>Backtrack: Forget &lsquo;C&rsquo;<br>‚Üí Word so far: &ldquo;A&rdquo;<br>‚Üí Used: {&lsquo;A&rsquo;}</p><p>Backtrack: Forget &lsquo;A&rsquo;<br>‚Üí Word so far: ""<br>‚Üí Used: {}</p><p>Pick &lsquo;B&rsquo;<br>‚Üí Now need 1 more letter.<br>‚Üí Used: {&lsquo;B&rsquo;}<br>‚Üí Word so far: &ldquo;B&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;B&rsquo;):<br>Pick &lsquo;A&rsquo;<br>‚Üí Word is &ldquo;BA&rdquo; ‚Äî Done!<br>Backtrack: Forget &lsquo;A&rsquo;<br>‚Üí Word so far: &ldquo;B&rdquo;<br>‚Üí Used: {&lsquo;B&rsquo;}</p><p>Pick &lsquo;C&rsquo;<br>‚Üí Word is &ldquo;BC&rdquo; ‚Äî Done!<br>Backtrack: Forget &lsquo;C&rsquo;<br>‚Üí Word so far: &ldquo;B&rdquo;<br>‚Üí Used: {&lsquo;B&rsquo;}</p><p>Backtrack: Forget &lsquo;B&rsquo;<br>‚Üí Word so far: ""<br>‚Üí Used: {}</p><p>Pick &lsquo;C&rsquo;<br>‚Üí Now need 1 more letter.<br>‚Üí Used: {&lsquo;C&rsquo;}<br>‚Üí Word so far: &ldquo;C&rdquo;</p><p>2nd letter choice (can&rsquo;t be &lsquo;C&rsquo;):<br>Pick &lsquo;A&rsquo;<br>‚Üí Word is &ldquo;CA&rdquo; ‚Äî Done!<br>Backtrack: Forget &lsquo;A&rsquo;<br>‚Üí Word so far: &ldquo;C&rdquo;<br>‚Üí Used: {&lsquo;C&rsquo;}</p><p>Pick &lsquo;B&rsquo;<br>‚Üí Word is &ldquo;CB&rdquo; ‚Äî Done!<br>Backtrack: Forget &lsquo;B&rsquo;<br>‚Üí Word so far: &ldquo;C&rdquo;<br>‚Üí Used: {&lsquo;C&rsquo;}</p><p>Backtrack: Forget &lsquo;C&rsquo;<br>‚Üí Word so far: ""<br>‚Üí Used: {}</p><p>Here the Undo part ( Backtrack ) is <strong>EXPLICIT</strong> when we do &ldquo;FORGET&rdquo; aplhabet (A/B/C)</p><p><strong>Let&rsquo;s re-look at the Alphabet example with the &ldquo;Backtracking Template&rdquo; in mind:</strong>
<code>find_words(current_word_list, used_letters_set)</code>
(Decision: What letter to pick next?)</p><ul><li><strong>Base Case (Solution Found):</strong> <code>len(current_word_list) == K</code>.</li><li><strong>Iterate through choices:</strong> <code>for letter in all_available_letters:</code><ul><li><strong>Validate:</strong> <code>if letter not in used_letters_set:</code><ul><li><strong>Make Choice:</strong> <code>current_word_list.append(letter)</code>, <code>used_letters_set.add(letter)</code></li><li><strong>Explore (Recurse):</strong> <code>find_words(next_state...)</code></li><li><strong>Undo Choice:</strong> <code>used_letters_set.remove(letter)</code>, <code>current_word_list.pop()</code></li></ul></li></ul></li></ul><p><strong>Key Characteristics/Benefits of Backtracking:</strong></p><ul><li><strong>Finds All Solutions:</strong> If you let it run its course without early termination, it will systematically find all solutions.</li><li><strong>Handles Constraints:</strong> The &ldquo;validate choice&rdquo; step allows you to prune the search space by not exploring paths that violate problem constraints.</li><li><strong>Conceptually Simple (once grasped):</strong> The &ldquo;try all options, and for each, recursively try all further options&rdquo; is a natural way to think about exhaustive search.</li><li><strong>Often a starting point:</strong> For many hard problems (NP-complete problems), backtracking is a fundamental approach. Optimizations (like memoization in dynamic programming, or better pruning heuristics) can then be built on top of it.</li></ul><h3 id=when-is-the-on-simple-iterative-solution-good-enough>When is the O(N¬≤) Simple Iterative Solution &ldquo;Good Enough&rdquo;?</h3><p><strong>Preferred When:</strong></p><ul><li>The <strong>depth of choices is small and fixed</strong> (e.g., K = 2).</li><li>The <strong>state between choices is minimal</strong>.</li><li><strong>Raw performance</strong> is critical and recursion‚Äôs function call overhead, though usually minor, matters.</li></ul><p><strong>Mental Model:</strong></p><ul><li><p><strong>Iterative Nested Loops</strong>:</p><ul><li>Best for <strong>fixed, shallow decision trees</strong>.</li><li>Like building with a <strong>fixed number of Lego blocks</strong> in a specific sequence.</li></ul></li><li><p><strong>Recursive Backtracking</strong>:</p><ul><li>Best for <strong>variable-depth or complex decision trees</strong>.</li><li>Like exploring a <strong>maze with unknown turns and constraints</strong>.</li><li><strong>BACKTRACKING HELPS FIND ALL POSSIBLE SOLUTIONS</strong></li></ul></li></ul><hr><h1 id=-152-generate-all-nonattacking-placements-of-n-queens-page-221>‚ôõ 15.2 GENERATE ALL NONATTACKING PLACEMENTS OF N-QUEENS (Page 221)</h1><p><strong>Goal:</strong> Place N queens on an N√óN chessboard such that no two queens attack each other.</p><h3 id=-the-problem>üß© The Problem:</h3><ul><li>Given an <strong>N √ó N</strong> chessboard.</li><li>Place <strong>N queens</strong> on the board such that <strong>no two queens attack each other</strong>.</li></ul><h4 id=-attack-rules>‚öîÔ∏è Attack Rules:</h4><ul><li>Queens can attack <strong>horizontally</strong>, <strong>vertically</strong>, and <strong>diagonally</strong>.</li></ul><h4 id=-goal>üéØ Goal:</h4><ul><li>Return <strong>all distinct configurations</strong> (valid placements) of these N queens.</li></ul><h3 id=-task-1>üßæ Task</h3><p>Exact problem: Place exactly <strong>one queen per row</strong>. Find <strong>ALL</strong> Possible combinations</p><p>Recusrion Backtracking: &ldquo;choose, explore, undo&rdquo; pattern</p><p><strong>TLDR;</strong></p><ul><li><strong>How it happens in N-Queens (EPI style):</strong><ol><li>You are trying to place a queen in <code>Row X</code>.</li><li>You try putting it in <code>Column A</code>. <code>board_config[X] = A</code>.</li><li>You recursively try to solve for <code>Row X+1</code> and beyond.</li><li>When that recursion finishes and returns, you are still in the loop for <code>Row X</code>.</li><li>Next, you try putting the queen for <code>Row X</code> in <code>Column B</code>.</li><li><strong>The &ldquo;Undo&rdquo;</strong>: <code>board_config[X] = B</code> <strong>overwrites</strong> <code>board_config[X] = A</code>. The choice of <code>A</code> for <code>Row X</code> is now gone for future explorations from <code>Row X</code>.</li></ol></li></ul><p><strong>Recursive Function Idea: solve_queens(row_to_place_in, current_board_config)</strong></p><ol><li><p><strong>&ldquo;Building the solution piece by piece&rdquo;</strong> (like building the word letter by letter):</p><ul><li>In N-Queens: We are trying to decide the <strong>column</strong> for the queen in the <code>row_to_place_in</code>.</li><li>This is like deciding the next letter for our word.</li></ul></li><li><p><strong>&ldquo;What choices do I have for the current piece?&rdquo;</strong></p><ul><li>Alphabet problem: Choose any unused letter from &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;.</li><li>N-Queens: For the current <code>row_to_place_in</code>, try placing the queen in <strong>column 0</strong>, then <strong>column 1</strong>, then <strong>column 2</strong>, &mldr;, up to <strong>column N-1</strong>.</li></ul></li><li><p><code>solve_queens(row, placement)</code> (where <code>placement[r]</code> stores the column of the queen in row <code>r</code>)</p><ul><li><p><strong>Base Case (Solution Found)</strong>:</p><ul><li>Alphabet: <code>if len(current_word) == K_target_length:</code> Solution found.</li><li>N-Queens: <code>if row == N:</code> We have successfully placed queens in row 0 to N-1. All N queens are on the board. This is a valid complete solution.<ul><li><strong>Action</strong>: Add a copy of <code>placement</code> to our list of results. Return.</li></ul></li></ul></li><li><p><strong>Recursive Step (Trying to place a queen in the current <code>row</code>)</strong>:</p><ul><li>Loop through all possible choices for this step:<ul><li><p>Alphabet: <code>for each_letter in available_letters:</code></p></li><li><p>N-Queens: <code>for col_choice from 0 to N-1:</code> (This is trying each column for the queen in the current <code>row</code>)</p></li><li><p><strong>Check if the choice is valid/allowed</strong>:</p><ul><li>Alphabet: <code>if each_letter not in used_letters:</code></li><li>N-Queens: <code>if is_safe_to_place_queen_at(row, col_choice, placement_so_far):</code><ul><li>The <code>is_safe_to_place_queen_at</code> function checks:<ol><li>Is <code>col_choice</code> already taken by a queen in a previous row (<code>placement[prev_row] == col_choice</code>)?</li><li>Is <code>(row, col_choice)</code> on a diagonal with any queen in a previous row<br>(<code>abs(placement[prev_row] - col_choice) == abs(prev_row - row)</code>)?</li></ol></li></ul></li></ul></li><li><p><strong>If the choice IS VALID/SAFE</strong>:
a. <strong>&ldquo;Place&rdquo; / Make the Choice</strong>:</p><ul><li>Alphabet: <code>current_word.append(each_letter)</code>, <code>used_letters.add(each_letter)</code></li><li>N-Queens: <code>placement[row] = col_choice</code> (We‚Äôve decided the queen for the current <code>row</code> goes in <code>col_choice</code>)</li></ul><p>b. <strong>&ldquo;Explore&rdquo; / Recurse</strong> (Try to complete the rest of the solution based on this choice):</p><ul><li>Alphabet: <code>find_words(current_word, used_letters)</code> (which internally will try to fill the next letter position)</li><li>N-Queens: <code>solve_queens(row + 1, placement)</code> (Try to place queens for all subsequent rows, starting with the very next row)</li></ul><p>c. <strong>&ldquo;Backtrack&rdquo; / Undo the Choice</strong> (CRUCIAL for exploring other options for the current step):</p><ul><li>Alphabet: current_word.pop(), used_letters.remove(each_letter)</li><li>N-Queens: This is where the EPI code is a bit more implicit.</li><li>When the <code>solve_queens(row + 1, placement)</code> call returns (meaning it has fully explored all possibilities from placing a queen at <code>(row, col_choice)</code>, or it hit a dead end), the execution comes back to the for <code>col_choice ... loop.</code></li><li>If the loop continues to the next col_choice for the same current row, the line <code>placement[row] = new_col_choice</code> will simply overwrite the previous col_choice. This acts as the &ldquo;undo&rdquo; for the specific assignment to <code>placement[row]</code>.</li><li>If the for <code>col_choice ...</code> loop finishes for the current row (all columns tried), the solve_queens(row, placement) function itself returns. This signifies that all paths starting with the configuration of queens up to row-1 (that led to this call) have been explored for this particular row. The state <code>placement[0...row-1]</code> remains untouched by this returning function, allowing the caller (which was trying to place a queen in row-1) to potentially try a different column for row-1.</li></ul></li></ul></li></ul></li></ul></li></ol><h4 id=q-so-what-if-we-find-all-the-valid-placements-in-the-first-go-itself--then-dont-you-think-our-return-and-the-loop-for-placementrow--new_col_choice-iterating-further-undoing-our-setup-wasted-when-we-have-a-valid-placement>Q. so what if we find all the valid placements in the first go itself . Then don&rsquo;t you think our return and the loop for placement[row] = new_col_choice iterating further undoing our setup wasted when we Have a valid placement?</h4><p>You&rsquo;re asking: <strong>If a particular choice for <code>placement[row]</code> (say, <code>col_A</code>) leads to one or more valid complete solutions through the <code>solve(row+1, ...)</code> call, why does the <code>for</code> loop for <code>row</code> continue to try other columns (like <code>col_B</code>) for that same <code>row</code>?</strong> Isn&rsquo;t that wasted effort if we&rsquo;ve already found solutions?</p><p>The answer depends on the <strong>goal of the problem</strong>:</p><ul><li><p><strong>Goal: Find ALL distinct non-attacking placements (as in N-Queens).</strong><br>If the goal is to find <em>all</em> possible solutions, then no, <strong>it&rsquo;s not wasted</strong>. We <strong>must</strong> continue exploring.</p><ul><li>Just because placing a queen at <code>(row, col_A)</code> led to <em>some</em> solutions doesn&rsquo;t mean that placing a queen at <code>(row, col_B)</code> (if safe) <em>won&rsquo;t also</em> lead to <em>other, different</em> valid solutions.</li><li>The N-Queens problem specifically asks for <em>all distinct nonattacking placements</em>. To achieve this, the backtracking algorithm <strong>must</strong> systematically explore every possible valid path in the decision tree.</li><li>When <code>solve(row+1, ...)</code> returns after exploring the consequences of <code>placement[row] = col_A</code>, it has done its job for that branch. The <code>for</code> loop for <code>row</code> then <strong>must</strong> try <code>placement[row] = col_B</code> (and <code>col_C</code>, etc.) to see if those choices also lead to valid complete solutions.<br>Each of these will be a distinct branch.</li></ul></li><li><p><strong>Goal: Find ANY ONE non-attacking placement (or determine if one exists).</strong><br>If the problem was modified to &ldquo;find just <em>one</em> solution and then stop,&rdquo; then <strong>yes, you could optimize</strong>.</p><ul><li>In this scenario, your recursive function could return a boolean: <code>true</code> if a solution was found down that path, <code>false</code> otherwise.</li></ul></li></ul><hr><h1 id=153-generate-permutations-page-222>15.3 GENERATE PERMUTATIONS (Page 222)</h1><p><strong>Problem:</strong> Given an array of <em>distinct</em> integers, generate all possible orderings (permutations) of those integers. No permutation should appear more than once.</p><p><strong>Core Idea (Recursive Backtracking):</strong>
To form a permutation of <code>N</code> items:</p><ol><li>Choose one item to be the <em>first</em> item in the permutation.</li><li>Then, generate all permutations of the <em>remaining</em> <code>N-1</code> items.</li><li>Prepend the chosen first item to each of these <code>N-1</code> item permutations.</li><li>Repeat this by choosing every possible item as the &ldquo;first&rdquo; item.</li></ol><p><strong>Simplified Recursive Logic: <code>generate_perms(index, current_array)</code></strong></p><ul><li><code>index</code>: The current position in the permutation we are trying to fill (from 0 to N-1).</li><li><code>current_array</code>: The array whose elements are being swapped to form permutations.</li></ul><ol><li><p><strong>Base Case:</strong></p><ul><li>If <code>index == N-1</code> (or <code>index == N</code> depending on how you structure it): We&rsquo;ve fixed elements for all positions from 0 to <code>N-1</code>. The <code>current_array</code> now holds one complete permutation.</li><li>Action: Add a <em>copy</em> of <code>current_array</code> to the results. Return.</li></ul></li><li><p><strong>Recursive Step (For the current <code>index</code>):</strong> Iterate <code>i</code> from <code>index</code> to <code>N-1</code> (these are the elements available to be placed at the current <code>index</code>).</p><ul><li><strong>Choose/Place:</strong> Swap <code>current_array[index]</code> with <code>current_array[i]</code>. This brings the element originally at <code>current_array[i]</code> into the <code>index</code>-th position.</li><li><strong>Explore/Recurse:</strong> Call <code>generate_perms(index + 1, current_array)</code>. This will generate all permutations for the rest of the array (from <code>index + 1</code> onwards), given the choice made for <code>index</code>.</li><li><strong>Undo/Backtrack:</strong> Swap <code>current_array[index]</code> with <code>current_array[i]</code> <em>again</em>. This restores the array to its state <em>before</em> this iteration&rsquo;s choice, allowing the next iteration of the <code>for</code> loop (for <code>i</code>) to correctly pick a different element for the <code>index</code>-th position. This is crucial.</li></ul></li></ol><p><strong>Example: <code>A = [1,2,3]</code>, <code>directed_permutations_recursive(0)</code></strong></p><ol><li><code>idx_to_fill = 0</code>: (Think of idx_to_fill as &ldquo;locking down&rdquo; elements from left to right. Everything to the left of idx_to_fill is considered &ldquo;fixed&rdquo; for the current branch of recursion.)<ul><li><code>i = 0</code>: <code>A=[1,2,3]</code>. Swap A[0],A[0] (no change). Recurse <code>d_p(1)</code> with <code>A=[1,2,3]</code>.<ul><li><code>idx_to_fill = 1</code>: (Processing <code>A=[1,_,_]</code>)<ul><li><code>i = 1</code>: <code>A=[1,2,3]</code>. Swap A[1],A[1]. Recurse <code>d_p(2)</code> with <code>A=[1,2,3]</code>.<ul><li><code>idx_to_fill = 2</code>. Base Case. Add <code>[1,2,3]</code> to result. Return.</li></ul></li><li>Undo swap A[1],A[1]. <code>A=[1,2,3]</code>.</li><li><code>i = 2</code>: <code>A=[1,2,3]</code>. Swap A[1],A[2] -> <code>A=[1,3,2]</code>. Recurse <code>d_p(2)</code> with <code>A=[1,3,2]</code>.<ul><li><code>idx_to_fill = 2</code>. Base Case. Add <code>[1,3,2]</code> to result. Return.</li></ul></li><li>Undo swap A[1],A[2] -> <code>A=[1,2,3]</code>.</li></ul></li><li><code>d_p(1)</code> returns.</li></ul></li><li>Undo swap A[0],A[0]. <code>A=[1,2,3]</code>.</li><li><code>i = 1</code>: <code>A=[1,2,3]</code>. Swap A[0],A[1] -> <code>A=[2,1,3]</code>. Recurse <code>d_p(1)</code> with <code>A=[2,1,3]</code>.<ul><li><code>idx_to_fill = 1</code>: (Processing <code>A=[2,_,_]</code>)<ul><li><code>i = 1</code>: <code>A=[2,1,3]</code>. Swap A[1],A[1]. Recurse <code>d_p(2)</code> with <code>A=[2,1,3]</code>.<ul><li>Add <code>[2,1,3]</code> to result.</li></ul></li><li>Undo.</li><li><code>i = 2</code>: <code>A=[2,1,3]</code>. Swap A[1],A[2] -> <code>A=[2,3,1]</code>. Recurse <code>d_p(2)</code> with <code>A=[2,3,1]</code>.<ul><li>Add <code>[2,3,1]</code> to result.</li></ul></li><li>Undo.</li></ul></li><li><code>d_p(1)</code> returns.</li></ul></li><li>Undo swap A[0],A[1] -> <code>A=[1,2,3]</code>.</li><li><code>i = 2</code>: <code>A=[1,2,3]</code>. Swap A[0],A[2] -> <code>A=[3,2,1]</code>. Recurse <code>d_p(1)</code> with <code>A=[3,2,1]</code>. (generates [3,2,1] and [3,1,2])</li><li>Undo.</li></ul></li></ol><ul><li><code>d_p(0)</code> returns.</li></ul><p><strong>Complexity:</strong></p><ul><li>There are <code>N!</code> permutations.</li><li>Each permutation is of length <code>N</code>. Generating it and copying it takes <code>O(N)</code>.</li><li>The recursion tree has roughly <code>N!</code> leaf nodes. The path to each leaf involves <code>N</code> levels of recursion. The work done at non-leaf nodes involves a loop and swaps.</li><li>Time: <code>O(N * N!)</code> because we spend <code>O(N)</code> work (loop and swaps) along the path to each of the <code>N!</code> permutations, and then <code>O(N)</code> to copy the result. More precisely, the number of recursive calls <code>C(N)</code> is <code>N * C(N-1)</code>, leading to <code>N!</code> calls roughly. Each call involves a loop. The book derives it as <code>sum(N! / (N-k)!)</code> calls, which is <code>O(N!)</code>.</li><li>Space: <code>O(N)</code> for the recursion call stack. <code>O(N * N!)</code> if storing all results.</li></ul><p>The &ldquo;swap, recurse, swap back&rdquo; is the classic pattern for generating permutations in place.</p><hr><h1 id=154-generate-the-power-set-page-224>15.4 GENERATE THE POWER SET (Page 224)</h1><p><strong>Problem:</strong> Given a set <code>S</code> (represented as a list/array for ordering purposes), return its power set. The power set is the set of <em>all possible subsets</em> of <code>S</code>, including the empty set and <code>S</code> itself.</p><p><strong>Example:</strong> If <code>S = {0, 1, 2}</code>, its power set is:
<code>{{}, {0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}}</code></p><p><strong>Core Idea (Recursive Backtracking - &ldquo;Take it or Leave it&rdquo;):</strong>
For each element in the input set, we have two choices:</p><ol><li>Include the element in the current subset we are building.</li><li>Do NOT include the element in the current subset we are building.</li></ol><p>We explore both choices recursively.</p><p><strong>Recursive Logic: <code>generate_power_set_recursive(index_of_element_to_consider, current_subset_being_built)</code></strong></p><ul><li><code>index_of_element_to_consider</code>: The index of the element in the input set <code>S</code> that we are currently deciding whether to include or not.</li><li><code>current_subset_being_built</code>: The subset formed so far based on decisions for elements <code>S[0]</code> through <code>S[index-1]</code>.</li></ul><ol><li><p><strong>Base Case:</strong></p><ul><li>If <code>index_of_element_to_consider == len(S)</code>: We have made a decision (include/exclude) for every element in the input set <code>S</code>.</li><li>Action: The <code>current_subset_being_built</code> is now one complete subset of <code>S</code>. Add a <em>copy</em> of it to our list of all subsets (the power set). Return.</li></ul></li><li><p><strong>Recursive Step (For <code>S[index_of_element_to_consider]</code>):</strong></p><ul><li>Let <code>element = S[index_of_element_to_consider]</code>.</li><li><strong>Choice 1: EXCLUDE <code>element</code></strong><ul><li>Don&rsquo;t add <code>element</code> to <code>current_subset_being_built</code>.</li><li>Recursively call <code>generate_power_set_recursive(index_of_element_to_consider + 1, current_subset_being_built)</code>. (Move to decide for the next element).</li></ul></li><li><strong>Choice 2: INCLUDE <code>element</code></strong><ul><li><strong>&ldquo;Place&rdquo;/Choose:</strong> Add <code>element</code> to <code>current_subset_being_built</code>.</li><li>Recursively call <code>generate_power_set_recursive(index_of_element_to_consider + 1, current_subset_being_built)</code>. (Move to decide for the next element, with the current one included).</li><li><strong>&ldquo;Undo&rdquo;/Backtrack:</strong> Remove <code>element</code> from <code>current_subset_being_built</code>. This is crucial so that when the &ldquo;EXCLUDE&rdquo; path for the <em>next higher level of recursion</em> (or other branches) is taken, <code>current_subset_being_built</code> is in the correct state.</li></ul></li></ul></li></ol><p><strong>EPI&rsquo;s <code>directed_power_set(to_be_selected, selected_so_far)</code> (Page 225):</strong></p><ul><li><code>to_be_selected</code>: Corresponds to my <code>index_of_element_to_consider</code>.</li><li><code>selected_so_far</code>: Corresponds to my <code>current_subset_being_built</code>.</li></ul><p><strong>Example: <code>input_set = [0, 1]</code>, <code>directed_power_set_recursive(0, [])</code></strong></p><ol><li><code>dps(0, [])</code>: (Deciding for element <code>0</code>)<ul><li><strong>Exclude <code>0</code></strong>: Call <code>dps(1, [])</code><ul><li><code>dps(1, [])</code>: (Deciding for element <code>1</code>)<ul><li><strong>Exclude <code>1</code></strong>: Call <code>dps(2, [])</code><ul><li><code>dps(2, [])</code>: <code>idx(2) == len(2)</code>. Base Case! Add <code>[]</code> to results. Return.</li></ul></li><li>Back in <code>dps(1, [])</code>.</li><li><strong>Include <code>1</code></strong>:<ul><li><code>current_subset.append(1)</code> -> <code>current_subset</code> is <code>[1]</code></li><li>Call <code>dps(2, [1])</code><ul><li><code>dps(2, [1])</code>: <code>idx(2) == len(2)</code>. Base Case! Add <code>[1]</code> to results. Return.</li></ul></li><li><code>current_subset.pop()</code> -> <code>current_subset</code> is <code>[]</code></li></ul></li><li><code>dps(1, [])</code> returns.</li></ul></li></ul></li><li>Back in <code>dps(0, [])</code>. <code>current_subset</code> is still <code>[]</code>.</li><li><strong>Include <code>0</code></strong>:<ul><li><code>current_subset.append(0)</code> -> <code>current_subset</code> is <code>[0]</code></li><li>Call <code>dps(1, [0])</code><ul><li><code>dps(1, [0])</code>: (Deciding for element <code>1</code>)<ul><li><strong>Exclude <code>1</code></strong>: Call <code>dps(2, [0])</code><ul><li><code>dps(2, [0])</code>: <code>idx(2) == len(2)</code>. Base Case! Add <code>[0]</code> to results. Return.</li></ul></li><li>Back in <code>dps(1, [0])</code>.</li><li><strong>Include <code>1</code></strong>:<ul><li><code>current_subset.append(1)</code> -> <code>current_subset</code> is <code>[0, 1]</code></li><li>Call <code>dps(2, [0, 1])</code><ul><li><code>dps(2, [0, 1])</code>: <code>idx(2) == len(2)</code>. Base Case! Add <code>[0, 1]</code> to results. Return.</li></ul></li><li><code>current_subset.pop()</code> -> <code>current_subset</code> is <code>[0]</code></li></ul></li><li><code>dps(1, [0])</code> returns.</li></ul></li></ul></li><li><code>current_subset.pop()</code> -> <code>current_subset</code> is <code>[]</code></li></ul></li><li><code>dps(0, [])</code> returns.</li></ul></li></ol><p>Results: <code>[ [], [1], [0], [0,1] ]</code> (Order might vary based on recursion path, but all subsets are there).</p><p><strong>Complexity:</strong></p><ul><li>There are <code>2^N</code> subsets for a set of <code>N</code> elements.</li><li>Each subset can have up to <code>N</code> elements. Copying a subset takes <code>O(N)</code>.</li><li>The recursion tree has <code>2^N</code> leaf nodes (each representing a subset). The depth is <code>N</code>.</li><li>Time: <code>O(N * 2^N)</code> because we generate <code>2^N</code> subsets, and for each, we might do <code>O(N)</code> work (e.g., appending to list, copying at the end). The number of nodes in the decision tree is <code>2^(N+1) - 1</code>.</li><li>Space: <code>O(N)</code> for the recursion call stack (depth N) and <code>O(N)</code> for <code>current_subset</code>. If storing all results, then <code>O(N * 2^N)</code>.</li></ul><p><strong>Alternative Iterative Approach (Bit Manipulation - Page 225):</strong></p><ul><li>If <code>N</code> is small (e.g., &lt;= 64), each integer from <code>0</code> to <code>2^N - 1</code> can represent a subset.</li><li>The <code>k</code>-th bit of the integer corresponds to the <code>k</code>-th element of the set. If the bit is 1, include the element; if 0, exclude.<ul><li>Example: <code>S = {a,b,c}</code> (N=3)<ul><li><code>0 (000_2)</code> -> <code>{}</code></li><li><code>1 (001_2)</code> -> <code>{c}</code> (assuming c is 0th, b is 1st, a is 2nd if mapping right to left)</li><li><code>2 (010_2)</code> -> <code>{b}</code></li><li>&mldr;</li><li><code>7 (111_2)</code> -> <code>{a,b,c}</code></li></ul></li></ul></li><li>This is often very fast in practice. Complexity is <code>O(N * 2^N)</code> because you iterate <code>2^N</code> numbers, and for each, you might iterate up to <code>N</code> bits to construct the subset.</li></ul><p>This &ldquo;take it or leave it&rdquo; recursive pattern is fundamental for many subset, combination, and related problems.</p><hr><h1 id=155-generate-all-subsets-of-size-k-page-226>15.5 GENERATE ALL SUBSETS OF SIZE k (Page 226)</h1><p><strong>Problem:</strong> Given <code>n</code> and <code>k</code>, compute all subsets of size <code>k</code> from the set <code>{1, 2, ..., n}</code>.
(The book uses <code>{1,2,...,n}</code> for the example, but the code can be adapted for any input set if needed by passing the set and an offset). This is also known as generating combinations: &ldquo;n choose k&rdquo;.</p><p><strong>Example:</strong> <code>n=5, k=2</code>.
Subsets of size 2 from <code>{1,2,3,4,5}</code>:
<code>{{1,2}, {1,3}, {1,4}, {1,5}, {2,3}, {2,4}, {2,5}, {3,4}, {3,5}, {4,5}}</code></p><p><strong>Core Idea (Recursive Backtracking - Focused &ldquo;Take it or Leave it&rdquo;):</strong>
We want to build a combination of size <code>k</code>. We can iterate through the numbers from <code>1</code> to <code>n</code>. For each number, we decide:</p><ol><li>Do we include this number in our current combination?</li><li>If we include it, we then need to find <code>k-1</code> more numbers from the <em>remaining available numbers</em> (i.e., numbers greater than the current one to avoid duplicates and maintain order).</li><li>If we don&rsquo;t include it, we need to find <code>k</code> numbers from the <em>remaining available numbers</em>.</li></ol><p>To make it more structured and avoid duplicate combinations (like <code>{1,2}</code> and <code>{2,1}</code> which are the same set), we can enforce that the numbers in our <code>partial_combination</code> are always added in increasing order.</p><p><strong>Recursive Logic: <code>generate_combinations_recursive(start_number_to_consider, current_combination)</code></strong></p><ul><li><code>start_number_to_consider</code>: The smallest number we can currently pick to add to our combination. This ensures we pick numbers in increasing order.</li><li><code>current_combination</code>: The list of numbers picked so far for the current combination.</li></ul><ol><li><p><strong>Base Case 1 (Combination Complete):</strong></p><ul><li>If <code>len(current_combination) == k</code>: We have found a combination of the desired size <code>k</code>.</li><li>Action: Add a <em>copy</em> of <code>current_combination</code> to our list of results. Return.</li></ul></li><li><p><strong>Base Case 2 (Not enough elements left to form a combination of size k):</strong></p><ul><li>If <code>start_number_to_consider > n</code> and <code>len(current_combination) &lt; k</code>: We&rsquo;ve run out of numbers to pick from, but haven&rsquo;t reached size <code>k</code>. This path is a dead end. Return.</li><li>More precisely, if the number of remaining elements <code>(n - start_number_to_consider + 1)</code> is less than the number of elements we still need <code>(k - len(current_combination))</code>, then we can&rsquo;t complete the combination. This check can prune branches earlier. (EPI code handles this implicitly with loop bounds).</li></ul></li><li><p><strong>Recursive Step (For numbers starting from <code>start_number_to_consider</code>):</strong></p><ul><li>Iterate <code>num_to_add</code> from <code>start_number_to_consider</code> up to <code>n</code>.<ul><li>(Optimization from EPI: <code>num_to_add</code> should not go so far that there aren&rsquo;t enough remaining elements to complete a k-sized combination. The loop in EPI is <code>while i &lt;= n and num_remaining &lt;= n - i + 1:</code> which captures this).
a. <strong>&ldquo;Place&rdquo;/Choose:</strong> Add <code>num_to_add</code> to <code>current_combination</code>.
b. <strong>Explore/Recurse:</strong> Call <code>generate_combinations_recursive(num_to_add + 1, current_combination)</code>.<ul><li>We pass <code>num_to_add + 1</code> as the next <code>start_number_to_consider</code> to ensure subsequent numbers are greater, maintaining sorted order and preventing duplicate combinations.
c. <strong>&ldquo;Undo&rdquo;/Backtrack:</strong> Remove <code>num_to_add</code> from <code>current_combination</code>. This is crucial to allow the <code>for</code> loop to try the <em>next</em> <code>num_to_add</code> for the current position in the combination, or for previous recursive calls to explore different branches.</li></ul></li></ul></li></ul></li></ol><p><strong>EPI&rsquo;s <code>directed_combinations(offset, partial_combination)</code> (Page 226):</strong></p><ul><li><code>offset</code>: Corresponds to my <code>start_number_to_consider</code>. (EPI uses 1-based indexing for numbers, so <code>offset</code> starts at 1).</li><li><code>partial_combination</code>: Corresponds to my <code>current_combination</code>.</li></ul><p><strong>Example: <code>n=4, k=2</code>, <code>directed_combinations_recursive(1, [])</code></strong></p><ol><li><code>dcr(1, [])</code>: <code>needed=2</code>. <code>end_loop_at = 4-2+1 = 3</code>. Loop <code>num_to_add</code> from 1 to 3.<ul><li><code>num_to_add = 1</code>: <code>combo=[1]</code>. Call <code>dcr(2, [1])</code>.<ul><li><code>dcr(2, [1])</code>: <code>needed=1</code>. <code>end_loop_at = 4-1+1 = 4</code>. Loop <code>num_to_add_inner</code> from 2 to 4.<ul><li><code>num_to_add_inner = 2</code>: <code>combo=[1,2]</code>. Call <code>dcr(3, [1,2])</code>.<ul><li><code>dcr(3, [1,2])</code>: <code>len==k</code>. Base! Add <code>[1,2]</code>. Return.</li></ul></li><li><code>combo.pop()</code> -> <code>[1]</code>.</li><li><code>num_to_add_inner = 3</code>: <code>combo=[1,3]</code>. Call <code>dcr(4, [1,3])</code>.<ul><li><code>dcr(4, [1,3])</code>: <code>len==k</code>. Base! Add <code>[1,3]</code>. Return.</li></ul></li><li><code>combo.pop()</code> -> <code>[1]</code>.</li><li><code>num_to_add_inner = 4</code>: <code>combo=[1,4]</code>. Call <code>dcr(5, [1,4])</code>.<ul><li><code>dcr(5, [1,4])</code>: <code>len==k</code>. Base! Add <code>[1,4]</code>. Return.</li></ul></li><li><code>combo.pop()</code> -> <code>[1]</code>.</li><li>Loop ends. <code>dcr(2, [1])</code> returns.</li></ul></li><li><code>combo.pop()</code> -> <code>[]</code>.</li></ul></li><li><code>num_to_add = 2</code>: <code>combo=[2]</code>. Call <code>dcr(3, [2])</code>.<ul><li><code>dcr(3, [2])</code>: <code>needed=1</code>. <code>end_loop_at = 4-1+1 = 4</code>. Loop <code>num_to_add_inner</code> from 3 to 4.<ul><li><code>num_to_add_inner = 3</code>: <code>combo=[2,3]</code>. Call <code>dcr(4, [2,3])</code>. Add <code>[2,3]</code>.</li><li><code>combo.pop()</code> -> <code>[2]</code>.</li><li><code>num_to_add_inner = 4</code>: <code>combo=[2,4]</code>. Call <code>dcr(5, [2,4])</code>. Add <code>[2,4]</code>.</li><li><code>combo.pop()</code> -> <code>[2]</code>.</li><li>Loop ends. <code>dcr(3, [2])</code> returns.</li></ul></li><li><code>combo.pop()</code> -> <code>[]</code>.</li></ul></li><li><code>num_to_add = 3</code>: <code>combo=[3]</code>. Call <code>dcr(4, [3])</code>.<ul><li><code>dcr(4, [3])</code>: <code>needed=1</code>. <code>end_loop_at = 4-1+1 = 4</code>. Loop <code>num_to_add_inner</code> from 4 to 4.<ul><li><code>num_to_add_inner = 4</code>: <code>combo=[3,4]</code>. Call <code>dcr(5, [3,4])</code>. Add <code>[3,4]</code>.</li><li><code>combo.pop()</code> -> <code>[3]</code>.</li><li>Loop ends. <code>dcr(4, [3])</code> returns.</li></ul></li><li><code>combo.pop()</code> -> <code>[]</code>.</li></ul></li><li>Loop ends. <code>dcr(1, [])</code> returns.</li></ul></li></ol><p>Results: <code>[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]</code></p><p><strong>Complexity:</strong></p><ul><li>Number of combinations is &ldquo;n choose k&rdquo;, denoted <code>C(n,k) = n! / (k! * (n-k)!)</code>.</li><li>Each combination has <code>k</code> elements.</li><li>Time: <code>O(k * C(n,k))</code> because we generate <code>C(n,k)</code> combinations, and forming/copying each takes about <code>O(k)</code>. The recursion depth is <code>k</code>.</li><li>Space: <code>O(k)</code> for the recursion stack and <code>current_combo</code>. <code>O(k * C(n,k))</code> if storing all results.</li></ul><p>This pattern is very similar to the power set, but with the added constraint on the size <code>k</code> and the optimization of only picking numbers greater than the previously picked one to ensure unique combinations.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>