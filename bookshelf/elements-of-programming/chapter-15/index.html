<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul></nav></header><main><article class=book-single><h1>Chapter 15: Recursion</h1><div class=book-details><div class=book-content><h1 id=recursion>Recursion</h1><p><strong>Core Idea of Recursion</strong>: At its simplest, recursion means a function calls itself to solve a smaller version of the same problem.</p><p>Two Key Ingredients :</p><ul><li><strong>Base Cases</strong>: These are the simplest instances of the problem that the function can solve directly, without further recursion.
Intuition: &ldquo;When do I know the answer without asking for more help?&rdquo;</li><li><strong>Progress (Recursive Call with different arguments):</strong> The function must call itself with arguments that move it closer to a base case. If it doesn&rsquo;t make progress, it&rsquo;ll loop forever.</li></ul><p>Recursion: The &ldquo;Ask a Mini-Me&rdquo; Approach:</p><p>Imagine you&rsquo;re a kid and your parent asks you to clean your entire room. It&rsquo;s a disaster. Toys everywhere.
You (the function): &ldquo;Ugh, this is too much!&rdquo;</p><p>Your thought process:</p><ul><li>Base Case (Simplest Job): &ldquo;Is there just ONE toy left on the floor?&rdquo; If yes, you pick it up. Done! Easy.</li><li>Recursive Step (Making it Simpler): &ldquo;Okay, there&rsquo;s more than one toy. What if I pick up just one toy and put it away? Now the room is slightly cleaner. The remaining mess is a smaller version of the original problem.&rdquo;</li><li>The &ldquo;Call a Mini-Me&rdquo;: &ldquo;Hey, Mini-Me (you call yourself again), can you clean this slightly cleaner room?&rdquo;
Trusting Mini-Me: You assume Mini-Me will somehow get the job done.
What you do after Mini-Me is done: Nothing! You already did your one piece of work (picking up one toy).</li></ul><p><strong>Why is recursion useful?</strong></p><ul><li>When the input itself is recursive (like file system directories, or a computer grammar).</li><li>For problems like searching, enumeration (listing all possibilities), and divide-and-conquer.</li></ul><p><strong>Divide-and-Conquer vs. Recursion:</strong></p><ul><li>Divide-and-Conquer: A strategy. It breaks a problem into independent smaller subproblems of the same type, solves them, and combines their solutions. Merge Sort is a classic.</li><li>Recursion: A technique. It&rsquo;s how you often implement divide-and-conquer. But recursion is more general. You might have only one subproblem (like binary search or factorial), or the subproblems might not be independent (hello, Dynamic Programming!).</li></ul><hr><p><strong>Example: Counting Down</strong></p><p>Let&rsquo;s say you want to write a function that prints numbers from N down to 1.
countdown(N):</p><p>Job: Print N, then N-1, then N-2, &mldr;, down to 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>countdown</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># Base case: stop when we reach 0 (or 1, if you prefer to print 1)</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Blast off!&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>      <span style=color:#75715e># This is important! Stop the recursion.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    print(n)          <span style=color:#75715e># Do a small piece of work</span>
</span></span><span style=display:flex><span>    countdown(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># Ask a &#34;mini-me&#34; to do the rest (a smaller version)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>countdown(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Output:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Blast off!</span>
</span></span></code></pre></div><hr><h1 id=1-recursion-boot-camp>1. Recursion boot camp</h1><ol><li><p>Euclidean Algorithm for GCD (Greatest Common Divisor)</p><ul><li>Problem: Find the largest number that divides both x and y without a remainder.</li><li>Core Idea (from the book): GCD(x, y) is the same as GCD(y, x % y). (Assuming x > y, initially it might be GCD(x-y, y) repeatedly, which simplifies to GCD(x % y, y) and then swapping to keep the first argument larger or just using GCD(y, x%y)).</li></ul></li></ol><p>Let&rsquo;s think recursively:
def gcd(x, y):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gcd</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Base case: if y is 0, then x is the GCD.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Think: GCD(12, 0) -&gt; what&#39;s the largest number that divides 12 and 0? It&#39;s 12.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#66d9ef>if</span> y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> gcd(y, x <span style=color:#f92672>%</span> y)
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><ul><li><strong>The &ldquo;Work&rdquo;</strong>: The % (modulo) operation is the work that makes the problem smaller.</li><li><strong>&ldquo;Smaller&rdquo;</strong>: The numbers y and x % y are generally smaller than x and y. Specifically, x % y is guaranteed to be less than y.</li><li><strong>Base Case</strong>: y == 0. When the second number is zero, the first number is the GCD. GCD(12, 0) = 12.</li></ul><hr><h1 id=2-mutilated-chessboard-page-218>2. Mutilated Chessboard (Page 218)</h1><p>This is a fantastic example of <strong>divide-and-conquer</strong>.</p><h3 id=-problem>üß© Problem</h3><p>Cover an <code>8x8</code> board with <strong>one square missing</strong> (mutilated) using <strong>L-shaped triominoes</strong> (3 squares each).</p><ul><li>Total squares: 63</li><li>Required triominoes: 21</li></ul><h3 id=-epis-reasoning>üí° EPI&rsquo;s Reasoning</h3><blockquote><p>Don‚Äôt think <code>n ‚Üí n+1</code>. That‚Äôs a dead end.<br>Instead, think:<br><strong>If I can solve for an <code>n x n</code> Mboard, can I solve for a <code>2n x 2n</code> Mboard?</strong></p></blockquote><h3 id=-the-aha-insight-figure-151b>‚ú® The &ldquo;Aha!&rdquo; Insight (Figure 15.1(b))</h3><ol><li><strong>Imagine a <code>2n x 2n</code> board</strong>.</li><li><strong>Divide it into four <code>n x n</code> quadrants</strong>.</li><li>One quadrant <strong>contains the original missing square</strong>.<ul><li>This is already an <code>n x n</code> <strong>Mboard</strong> (mutilated board) ‚Äî by hypothesis, we can tile it!</li></ul></li><li>The <strong>other three quadrants</strong> are not Mboards yet.</li></ol><h3 id=-clever-step>üß† Clever Step</h3><ul><li><strong>Place one triomino</strong> in the <strong>center of the <code>2n x 2n</code> board</strong>.</li><li>Align it such that it <strong>covers one corner square from each of the three &ldquo;full&rdquo; <code>n x n</code> quadrants</strong>.</li><li>This action <strong>creates a new missing square in each of the three quadrants</strong>, turning them into Mboards!</li></ul><p>By hypothesis, we can now <strong>tile all four <code>n x n</code> Mboards</strong> ‚Äî problem solved!</p><hr><h1 id=3--table-151-top-tips-for-recursion-page-219>3. üìò Table 15.1: Top Tips for Recursion <em>(Page 219)</em></h1><h3 id=1---recursive-rules-input>1. üîÅ <strong>Recursive Rules Input</strong></h3><p>If the <strong>problem description sounds recursive</strong>, then recursion is a natural fit.</p><blockquote><p>Example: <em>&ldquo;A directory contains files and other directories.&rdquo;</em></p></blockquote><h3 id=2--search-enumerate-divide-and-conquer>2. üß≠ <strong>Search, Enumerate, Divide-and-Conquer</strong></h3><p>These problem types are <strong>prime candidates</strong> for recursion:</p><ul><li><p><strong>üîç Search:</strong><br>&ldquo;Is the item in the left half? Or the right half?&rdquo;<br><em>‚Üí Example: Binary Search</em></p></li><li><p><strong>üìã Enumerate:</strong><br>&ldquo;What if I pick this? What are the options then? What if I don‚Äôt pick this?&rdquo;<br><em>‚Üí Example: Generating all subsets</em></p></li><li><p><strong>üß© Divide-and-Conquer:</strong><br>Break the problem into smaller subproblems of the same type.</p></li></ul><h3 id=3--alternative-to-nested-loops-of-undefined-depth>3. üîÑ <strong>Alternative to Nested Loops (of Undefined Depth)</strong></h3><p>When you <strong>don‚Äôt know how many nested loops</strong> you‚Äôll need (e.g., problems with variable segments like IP address parsing),<br>recursion <strong>gracefully handles varying depth</strong>.</p><h3 id=4--removing-recursion-mimic-the-call-stack>4. üß± <strong>Removing Recursion (Mimic the Call Stack)</strong></h3><p>If you&rsquo;re asked to <strong>make a recursive solution iterative</strong>:</p><blockquote><p>Use your own <strong>stack data structure</strong> to keep track of ‚Äúwhat to do next.‚Äù</p></blockquote><h3 id=5--tail-recursion>5. üéØ <strong>Tail Recursion</strong></h3><p>If the <strong>recursive call is the last operation</strong> in the function, it can often be <strong>converted into a loop</strong>.</p><blockquote><p>Note: <strong>Python does not optimize tail recursion</strong>, but understanding it is still valuable.</p></blockquote><h3 id=6--caching-repeated-calls-memoization>6. üíæ <strong>Caching Repeated Calls (Memoization)</strong></h3><p>If your recursive function <strong>recomputes the same result</strong> multiple times:</p><ul><li><strong>Store the result</strong> (e.g., <code>fib(3)</code> is needed by both <code>fib(5)</code> and <code>fib(4)</code>)</li><li>This is the <strong>gateway to Dynamic Programming</strong>!</li></ul></div></div></article></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer></body></html>