<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#system-prompt>System Prompt</a></li><li><a href=#tier-1-absolutely-essential-high-frequency-broad-applicability>Tier 1: Absolutely Essential (High Frequency, Broad Applicability)</a><ul><li><a href=#arrays--strings>Arrays & Strings</a></li><li><a href=#hash-maps-hash-tables--dictionaries>Hash Maps (Hash Tables / Dictionaries)</a></li><li><a href=#trees-especially-binary-trees--binary-search-trees>Trees (especially Binary Trees & Binary Search Trees)</a></li><li><a href=#graphs>Graphs</a></li><li><a href=#sorting--searching>Sorting & Searching</a></li></ul></li><li><a href=#tier-2-very-important-high-frequency-for-optimal-solutions-differentiators>Tier 2: Very Important (High Frequency for Optimal Solutions, Differentiators)</a><ul><li><a href=#dynamic-programming-dp>Dynamic Programming (DP)</a></li><li><a href=#heaps-priority-queues>Heaps (Priority Queues)</a></li><li><a href=#backtracking>Backtracking</a></li></ul></li><li><a href=#how-to-study>How to study</a><ul><li><a href=#example-towers-of-hanoi-from-recursion-chapter>Example: Towers of Hanoi (from Recursion chapter)</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Elements of Programming interviews in python</h1><span class=reading-time><em>10 min read</em></span><h2>by Tsung-hsien Lee, Adnan Aziz, Amit Prakash</h2><div class=book-details><div class=book-cover><img src=https://m.media-amazon.com/images/W/MEDIAX_1215821-T1/images/I/61BTafHPRAL._SY522_.jpg alt="Cover of Elements of Programming interviews in python"></div><div class=book-content><p><a href="https://www.amazon.in/Elements-Programming-Interviews-Python-Insiders/dp/1537713949/ref=sr_1_2?crid=2TBQUDIPN77XD&amp;dib=eyJ2IjoiMSJ9.OxfkdxBfVgAYNeG7n3slhWigySJkQT_8ht1ceb0MSHRrwcrzkyEA4ZKxl6fK9LLCCxYMatNIL5zwXZtp7w6HlWLfV6toFrwWvQEPpCYtO7H78F48OG9YtqJ8SbCOigEn7KCqBfiWBzUAsIaUcMFkJYnd4sg0YdIs1TkP-oGQHkzMPGFewjNf064dM0bo5vgwemKZGU-pFD0GiaLE2vcSwmKB7ZoUBA6mEmFbjx2qMaQ.pfJ_3oiMh0LX8kAZ65ej23EldyB__0vKI1OMvJ0i08E&amp;dib_tag=se&amp;keywords=elements+of+programming+interviews&amp;qid=1747800501&amp;sprefix=elements+of+pr%2Caps%2C239&amp;sr=8-2" target=_blank rel="noopener noreferrer" class=purchase-link>View/Purchase Link</a></p><h3>Notes / Summary</h3><h1 id=system-prompt>System Prompt</h1><p><code>you are an expert DSA expert who specializes in teaching how to track coding problems you have written books and specializes in coaching those students who run away from DSA. Your ability to boil down even complex problems and concepts into very simple intuitive first principals based explanation makes you the best in the trade . You are starting a new course based on the book elements of programming interview in python. You will cover each chapters core topics and also cover each section and the core problems in that chapter.</code></p><hr><h1 id=tier-1-absolutely-essential-high-frequency-broad-applicability>Tier 1: Absolutely Essential (High Frequency, Broad Applicability)</h1><h2 id=arrays--strings>Arrays & Strings</h2><p><strong>Why:</strong><br>The most fundamental data structures. Almost every problem involves them in some way. Crucial for data manipulation, which is core to ML.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Two pointers</li><li>Sliding window</li><li>Prefix sums</li><li>Manipulating characters</li><li>Searching</li><li>Sorting within arrays</li></ul><p><strong>Example Problems:</strong></p><ul><li>Two Sum</li><li>Longest Substring Without Repeating Characters</li><li>Container With Most Water</li><li>3Sum</li><li>Product of Array Except Self</li></ul><hr><h2 id=hash-maps-hash-tables--dictionaries>Hash Maps (Hash Tables / Dictionaries)</h2><p><strong>Why:</strong><br>The workhorse for optimizing time complexity. Essential for lookups, counting frequencies, grouping items. Extensively used in ML for feature encoding, caching, etc.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Efficient lookups</li><li>Storing counts</li><li>Grouping anagrams</li><li>Finding duplicates</li></ul><p><strong>Example Problems:</strong></p><ul><li>Group Anagrams</li><li>Valid Anagram</li><li>Subarray Sum Equals K</li></ul><hr><h2 id=trees-especially-binary-trees--binary-search-trees>Trees (especially Binary Trees & Binary Search Trees)</h2><p><strong>Why:</strong><br>Very common in interviews. They test your understanding of recursion, traversals, and structured data. Decision trees are a basic ML concept.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Traversal algorithms (BFS, DFS - Inorder, Preorder, Postorder)</li><li>Validating BSTs</li><li>Finding LCA (Lowest Common Ancestor)</li><li>Path sums</li><li>Tree construction</li></ul><p><strong>Example Problems:</strong></p><ul><li>Binary Tree Inorder Traversal</li><li>Validate Binary Search Tree</li><li>Lowest Common Ancestor of a Binary Tree</li><li>Maximum Depth of Binary Tree</li><li>Kth Smallest Element in a BST</li></ul><hr><h2 id=graphs>Graphs</h2><p><strong>Why:</strong><br>Many real-world problems (and ML problems like recommendation systems, knowledge graphs, network analysis) can be modeled as graphs.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Traversal algorithms (BFS, DFS)</li><li>Connected components</li><li>Cycle detection</li><li>Topological sort</li><li>Shortest path (Dijkstra&rsquo;s, Bellman-Ford for conceptual understanding)</li></ul><p><strong>Example Problems:</strong></p><ul><li>Number of Islands</li><li>Clone Graph</li><li>Course Schedule</li><li>Word Ladder</li><li>Rotting Oranges</li></ul><hr><h2 id=sorting--searching>Sorting & Searching</h2><p><strong>Why:</strong><br>Fundamental algorithmic concepts. Often a pre-processing step or part of a more complex algorithm. Binary search is key for optimizing search in sorted data.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Standard sorting algorithms (understand their complexities, even if using built-in sort)</li><li>Binary search on arrays</li><li>Binary search for finding answers within a range</li></ul><p><strong>Example Problems:</strong></p><ul><li>Merge Intervals</li><li>Search in Rotated Sorted Array</li><li>Find Minimum in Rotated Sorted Array</li><li>Kth Largest Element in an Array (can also use heaps)</li></ul><h1 id=tier-2-very-important-high-frequency-for-optimal-solutions-differentiators>Tier 2: Very Important (High Frequency for Optimal Solutions, Differentiators)</h1><h2 id=dynamic-programming-dp>Dynamic Programming (DP)</h2><p><strong>Why:</strong><br>Google loves DP. It&rsquo;s a strong indicator of problem-solving ability and thinking about overlapping subproblems. Many optimization problems in ML can have DP-like structures.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>1D DP</li><li>2D DP</li><li>Identifying overlapping subproblems and optimal substructure</li><li>Memoization vs. Tabulation</li></ul><p><strong>Example Problems:</strong></p><ul><li>Climbing Stairs</li><li>Longest Increasing Subsequence</li><li>Coin Change</li><li>Word Break</li><li>Unique Paths</li></ul><hr><h2 id=heaps-priority-queues>Heaps (Priority Queues)</h2><p><strong>Why:</strong><br>Excellent for problems involving &ldquo;top K&rdquo; elements, finding medians in a stream, scheduling, or anytime you need efficient access to min/max elements.</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Min-heaps</li><li>Max-heaps</li><li>Using heaps for sorting (HeapSort concept)</li><li>Finding Kth largest/smallest</li></ul><p><strong>Example Problems:</strong></p><ul><li>Top K Frequent Elements</li><li>Find Median from Data Stream</li><li>Merge K Sorted Lists</li><li>K Closest Points to Origin</li></ul><hr><h2 id=backtracking>Backtracking</h2><p><strong>Why:</strong><br>For problems requiring exploration of all possible solutions in a search space (e.g., permutations, combinations, solving puzzles).</p><p><strong>Specific Sub-topics:</strong></p><ul><li>Recursive construction of solutions</li><li>Pruning the search space</li></ul><p><strong>Example Problems:</strong></p><ul><li>Subsets</li><li>Permutations</li><li>Combination Sum</li><li>N-Queens</li></ul><h1 id=how-to-study>How to study</h1><p>This is an incredibly important concern, especially with DSA, and particularly with topics like recursion. It&rsquo;s often about finding the right &ldquo;click&rdquo; and the right practice methodology.</p><p>Your current approach has many good elements, but we can definitely refine it to bridge that gap between understanding the idea and being able to code it.</p><p><strong>Why the Gap Exists (Especially with Recursion):</strong></p><ol><li><strong>Abstract to Concrete:</strong> Recursion is an abstract way of thinking (&ldquo;solve a smaller version of myself&rdquo;). Translating that into concrete code (base cases, parameters, return values, how the recursive call uses its own result) is a skill.</li><li><strong>The &ldquo;Leap of Faith&rdquo;:</strong> You have to trust that if your base case is correct and your recursive step correctly makes the problem smaller and combines results, it <em>will</em> work. This can feel like magic until you&rsquo;ve seen it work many times.</li><li><strong>State Management (Implicit):</strong> The call stack manages a lot of state for you in recursion. Visualizing this implicit state (what are the values of parameters in <em>this</em> call vs. the <em>next</em> call vs. the <em>previous</em> call?) is hard.</li><li><strong>Small Errors, Big Problems:</strong> A slightly off base case or a recursive call that doesn&rsquo;t quite make progress correctly can lead to infinite loops or wrong answers, which can be demoralizing.</li><li><strong>Passive vs. Active Learning:</strong> Reading solutions and understanding them is passive. Implementing them yourself, hitting roadblocks, debugging, and finally getting it right is active learning â€“ and that&rsquo;s where true understanding is forged.</li></ol><p><strong>Suggestions to Bridge the Gap (Using Recursion as our Example):</strong></p><p>Let&rsquo;s refine your approach. &ldquo;Understanding the approach&rdquo; is good, but we need to make it more active <em>earlier</em>.</p><p><strong>Phase 1: Deep Dive into ONE Problem (Not the whole chapter at once)</strong></p><p>Instead of finishing the whole chapter&rsquo;s notes first, let&rsquo;s focus on <em>mastering one problem at a time</em>, especially initially.</p><h2 id=example-towers-of-hanoi-from-recursion-chapter>Example: Towers of Hanoi (from Recursion chapter)</h2><ol><li><p><strong>Your Current Step 1: Go through my teaching / EPI explanation.</strong></p><ul><li>Understand the high-level idea: &ldquo;To move N disks, I need to move N-1 out of the way, move the Nth, then move the N-1 back on top.&rdquo;</li><li>Identify the parameters of the recursive function: What information does it need to do its job? (<code>num_disks</code>, <code>source_peg</code>, <code>destination_peg</code>, <code>auxiliary_peg</code>).</li><li><strong>Crucially, identify the Base Case:</strong> What&rsquo;s the absolute simplest version of this problem I can solve directly? (Moving 0 disks, or moving 1 disk). Write this down.</li></ul></li><li><p><strong>Step 2 (NEW - Before looking at full code): Try to &ldquo;Hand-Simulate&rdquo; with Pen and Paper FOR A SMALL CASE.</strong></p><ul><li>Take <code>N=2</code> disks.</li><li>Literally write out the steps <em>you</em> would take, following the high-level idea.<ul><li>&ldquo;To move 2 disks P1->P2 (using P3):&rdquo;<ul><li>&ldquo;Need to move 1 disk P1->P3 (using P2).&rdquo;<ul><li>&ldquo;Move disk 1 P1->P3.&rdquo; (This is a base case for the subproblem)</li></ul></li><li>&ldquo;Now, move disk 2 P1->P2.&rdquo;</li><li>&ldquo;Need to move 1 disk P3->P2 (using P1).&rdquo;<ul><li>&ldquo;Move disk 1 P3->P2.&rdquo; (Base case for subproblem)</li></ul></li></ul></li></ul></li><li>Now, try <code>N=3</code>. This will be more involved.<ul><li><code>hanoi(3, P1, P2, P3)</code><ul><li>Requires <code>hanoi(2, P1, P3, P2)</code><ul><li>This sub-call itself requires <code>hanoi(1, P1, P2, P3)</code></li><li>Then move disk 2 (from P1 to P3)</li><li>Then <code>hanoi(1, P2, P3, P1)</code></li></ul></li><li>Then move disk 3 (from P1 to P2)</li><li>Then <code>hanoi(2, P3, P2, P1)</code></li></ul></li></ul></li><li><strong>This hand-simulation helps you internalize the flow and how the roles of pegs change.</strong> You&rsquo;re &ldquo;being&rdquo; the recursive function.</li></ul></li><li><p><strong>Step 3 (NEW - Pseudocode/Skeleton Code):</strong></p><ul><li>Based on your hand-simulation and understanding, try to write a <em>skeleton</em> of the recursive function. Don&rsquo;t worry about perfect Python syntax yet.<pre tabindex=0><code>function solve_hanoi(number_of_disks, source, destination, auxiliary):
    if number_of_disks == 1 (or 0):
        print &#34;Move disk from source to destination&#34;
        return

    // 1. Move N-1 disks from source to auxiliary
    solve_hanoi(number_of_disks - 1, source, auxiliary, destination) 
                                // ^ notice how dest and aux swapped roles

    // 2. Move the Nth disk from source to destination
    print &#34;Move largest disk from source to destination&#34;

    // 3. Move N-1 disks from auxiliary to destination
    solve_hanoi(number_of_disks - 1, auxiliary, destination, source)
                                // ^ notice roles swapped again
</code></pre></li><li>Getting these parameter swaps correct is often the key.</li></ul></li><li><p><strong>Step 4: Translate to Actual Code (Referencing EPI if needed, but try first).</strong></p><ul><li>Now, try to write the Python code.</li><li>You might get stuck on:<ul><li>Exact base case condition (<code>>0</code> vs <code>==1</code> vs <code>==0</code>).</li><li>How to represent pegs/moves if not just printing.</li></ul></li><li><strong>This is where you look at the EPI code snippet for <em>that specific part</em> where you&rsquo;re stuck.</strong> Don&rsquo;t just read the whole solution. Focus on your roadblock.</li><li>For Towers of Hanoi, the EPI code also manages the state of the pegs in lists. If that&rsquo;s too much, initially just focus on a version that <em>prints</em> the moves. You can add peg state management later.</li></ul></li><li><p><strong>Step 5 (CRUCIAL - Debug and Test):</strong></p><ul><li>Run your code with <code>N=1</code>, <code>N=2</code>, <code>N=3</code>.</li><li>This tracing helps you see the flow of calls, the values of parameters, and where it might be going wrong. This is how you &ldquo;see&rdquo; the recursion happening.</li><li>Compare your output to your hand-simulation or known correct sequences.</li></ul></li><li><p><strong>Step 6: Reflect and Solidify.</strong></p><ul><li>Once it works, ask yourself:<ul><li>&ldquo;What was the exact base case?&rdquo;</li><li>&ldquo;How did I make the problem smaller in the recursive call?&rdquo;</li><li>&ldquo;How did the arguments change for the recursive call(s)?&rdquo; (e.g., source became auxiliary).</li><li>&ldquo;If there were multiple recursive calls, what did each one achieve?&rdquo;</li></ul></li><li>Now, make your notes, focusing on these key insights for <em>this one problem</em>.</li></ul></li></ol><p><strong>Generalizing this Process:</strong></p><ul><li><strong>One Problem at a Time:</strong> Especially for recursion and DP, don&rsquo;t try to absorb the whole chapter. Master one problem, then the next. The understanding from one will help with the next.</li><li><strong>Active Engagement Before Looking at Solutions:</strong> The hand-simulation and pseudocode steps are <em>active</em>. This forces your brain to grapple with the logic.</li><li><strong>Targeted Solution-Checking:</strong> Only look at the solution code to overcome specific hurdles, not as a first step.</li><li><strong>&ldquo;Code Aloud&rdquo; / Rubber Ducking:</strong> Explain the problem and your approach to someone else, or even to a rubber duck. Articulating it helps clarify your thoughts.</li><li><strong>Visualize the Call Stack (Simple Cases):</strong> For very simple recursion (like factorial or sum of an array), draw the call stack:<ul><li><code>sum([1,2,3])</code> calls <code>sum([2,3])</code> which calls <code>sum([3])</code> which calls <code>sum([])</code> (base case).</li><li>How do the return values combine? <code>0</code> returns, then <code>3+0</code> returns, then <code>2+3</code> returns, then <code>1+5</code> returns.</li></ul></li><li><strong>Don&rsquo;t Aim for &ldquo;No Code&rdquo; Initially:</strong> It&rsquo;s okay to look at the code <em>after</em> you&rsquo;ve struggled and formed your own mental model. The goal of &ldquo;no code&rdquo; is for the <em>re-solving</em> phase later. For initial learning, use the provided code as a guide <em>after</em> your own attempt.</li><li><strong>For Dutch National Flag (Arrays):</strong> That&rsquo;s a pointer manipulation problem. The &ldquo;trick&rdquo; is understanding what each section of the array (low, mid, high) represents and ensuring loop invariants. Again, hand-simulate with a small array <code>[0,1,2,0,1,2]</code> and manually move the pointers and swap elements. Then try to code that logic. If stuck, see what the solution does for the <em>specific situation</em> you&rsquo;re stuck on.</li></ul><p><strong>Your Feeling: &ldquo;It makes me feel as if I didn&rsquo;t get the problem or intuition in the first place.&rdquo;</strong></p><p>This is common because seeing a clean, elegant recursive solution makes it look &ldquo;obvious&rdquo; in hindsight. But the process of <em>arriving</em> at that solution is often messy, involves trial and error, and requires patiently building up the recursive structure from the base case and the &ldquo;how to make it smaller&rdquo; step.</p><p><strong>Your current approach of &ldquo;notes, understand, then attempt to solve later&rdquo; is good for <em>review</em>. For <em>initial learning</em> of a tricky concept like recursion, you need more immediate, active grappling with each individual problem.</strong></p><p><strong>What to do after this chapter (Recursion):</strong></p><ol><li>Pick ONE problem from the chapter (e.g., Generate Permutations, or N-Queens again).</li><li>Apply the detailed 6-step process above to it.</li><li><strong>Do not move to the next problem until you can code that one problem, test it, and explain its recursive structure (base case, recursive step, how arguments change).</strong></li><li>Then, pick the next problem from the chapter.</li></ol><p>This might feel slower initially, but each problem you conquer this way builds a much stronger foundation. The &ldquo;aha!&rdquo; moments for recursion often come from this kind of focused, active struggle with individual problems, rather than a broad overview.</p><p>Be patient with yourself. This is a marathon, not a sprint. The fact that you&rsquo;re identifying this gap and asking for help is a huge step in the right direction! You <em>can</em> bridge this gap.</p><div class=chapter-notes><h3>Chapter Notes</h3><ul><li><a href=/bookshelf/elements-of-programming/chapter-1/>Chapter 5: Arrays</a></li><li><a href=/bookshelf/elements-of-programming/chapter-6/>Chapter 6: Strings</a></li><li><a href=/bookshelf/elements-of-programming/chapter-9/>Chapter 9: Binary Trees</a></li><li><a href=/bookshelf/elements-of-programming/chapter-12/>Chapter 12: Hash Tables</a></li><li><a href=/bookshelf/elements-of-programming/chapter-15/>Chapter 15: Recursion</a></li></ul></div></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>