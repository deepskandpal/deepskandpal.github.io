<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404EngineerNotFound</title>
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
</head>
<body>
    
        \
<header>
    <nav>
        <div class="logo"><a href="/">404EngineerNotFound</a></div>
        <ul class="main-nav">
            
            
                
                
                    
                    <li class="nav-item has-dropdown">
                        
                        <a href="#">
                            Writings <i class="fas fa-caret-down fa-xs"></i>
                        </a>
                        <ul class="dropdown-menu">
                            
                            
                                <li class="dropdown-item">
                                    <a href="/stories/">Stories</a>
                                </li>
                            
                                <li class="dropdown-item">
                                    <a href="/thoughts/">Thoughts</a>
                                </li>
                            
                                <li class="dropdown-item">
                                    <a href="/fitness-log/">Fitness Log</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                
                    
                    <li class="nav-item has-dropdown">
                        
                        <a href="#">
                            Tech Lab <i class="fas fa-caret-down fa-xs"></i>
                        </a>
                        <ul class="dropdown-menu">
                            
                            
                                <li class="dropdown-item">
                                    <a href="/papershelf/">Papershelf</a>
                                </li>
                            
                                <li class="dropdown-item">
                                    <a href="/creations/">Creations</a>
                                </li>
                            
                                <li class="dropdown-item">
                                    <a href="/dsa-log/">DSA Log</a>
                                </li>
                            
                                <li class="dropdown-item">
                                    <a href="/tech-writings/">Technical Writings</a>
                                </li>
                            
                        </ul>
                    </li>
                
            
                
                
                    
                    <li class="nav-item">
                        <a href="/bookshelf/">Bookshelf</a>
                    </li>
                
            
                
                
                    
                    <li class="nav-item">
                        <a href="/about/">About</a>
                    </li>
                
            
        </ul>
    </nav>
</header> 
    

    <main>
        
    <article class="book-single">
        <h1>Chapter 0: Arrays notes</h1>
        
 

  
    <span class="reading-time"><em>12 min read</em></span>
  
 
        
        
        <div class="book-details">
            
            
            <div class="book-content">
                
                
                
                
                <p><strong>Chapter 5: Arrays - Comprehensive Revision (Intuition, Patterns, Implementation &amp; Interview Value) - <em>Revised &amp; Expanded</em></strong></p>
<p><strong>Core Interview Themes for Arrays (Recap):</strong></p>
<ul>
<li>In-Place Manipulation (<code>O(1)</code> space).</li>
<li>Pointer Techniques (1, 2, or 3 pointers).</li>
<li>Edge Cases.</li>
<li>Time Complexity Optimization (<code>O(n^2)</code> -&gt; <code>O(n)</code>).</li>
<li>Understanding Data Movement (Shift vs. Overwrite).</li>
<li>Problem Decomposition.</li>
</ul>
<p>Okay, excellent idea! Let&rsquo;s do a focused revision of <strong>Chapter 5: Arrays</strong>, going problem by problem, and for each one, identify:</p>
<ol>
<li><strong>The Core Problem Statement (Simplified)</strong></li>
<li><strong>The Key Intuition / Analogy that helps &ldquo;get it&rdquo;</strong></li>
<li><strong>The Underlying Algorithmic Pattern(s)</strong></li>
<li><strong>Main Implementation Steps (Conceptual, not code)</strong></li>
<li><strong>Why it&rsquo;s an Interview Question (What it Tests)</strong></li>
</ol>
<p>This will help solidify the connection between the problem, the solution strategy, and its relevance.</p>
<hr>
<p><strong>Chapter 5: Arrays - Focused Revision</strong></p>
<hr>
<p><strong>1. Array Boot Camp: <code>even_odd</code> (Reorder evens before odds)</strong>
*   <strong>Problem:</strong> Put all even numbers to the left of all odd numbers in an array, in-place.
*   <strong>Intuition/Analogy:</strong> Two &ldquo;fingers&rdquo; moving from opposite ends of the array. Left finger looks for misplaced odds, right finger marks the boundary for odds. When left finger finds an odd, swap it with what the right finger points to.
*   <strong>Pattern(s):</strong> Two-Pointer Partitioning (Opposite Ends).
*   <strong>Implementation Steps:</strong>
1.  <code>left = 0</code>, <code>right = len(A)-1</code>.
2.  Loop while <code>left &lt; right</code>:
*   If <code>A[left]</code> is EVEN, <code>left++</code> (it&rsquo;s good).
*   Else (if <code>A[left]</code> is ODD), swap <code>A[left]</code> with <code>A[right]</code>, then <code>right--</code>. (Don&rsquo;t advance <code>left</code> yet, new <code>A[left]</code> needs checking).
*   <strong>Tests:</strong> In-place manipulation, basic partitioning, pointer logic.</p>
<hr>
<p><strong>2. Section 5.1: The Dutch National Flag Problem</strong>
*   <strong>Problem:</strong> Given a pivot value, partition an array into three sections: elements <code>&lt; pivot</code>, then <code>== pivot</code>, then <code>&gt; pivot</code>, in-place.
*   <strong>Intuition/Analogy:</strong> Four conceptual regions in the array (Less, Equal, Unclassified, Greater) managed by three pointers. <code>current_checker</code> pointer processes the Unclassified region, moving elements to Less, Equal, or Greater regions.
*   <strong>Pattern(s):</strong> Three-Pointer Partitioning (Single Pass), Invariant Maintenance.
*   <strong>Implementation Steps:</strong>
1.  <code>low_boundary = 0</code>, <code>current_checker = 0</code>, <code>high_boundary = len(A)</code>. Pick <code>pivot_val</code>.
2.  Loop while <code>current_checker &lt; high_boundary</code>:
*   If <code>A[current_checker] &lt; pivot_val</code>: Swap with <code>A[low_boundary]</code>. <code>low_boundary++</code>, <code>current_checker++</code>.
*   If <code>A[current_checker] == pivot_val</code>: <code>current_checker++</code>.
*   If <code>A[current_checker] &gt; pivot_val</code>: <code>high_boundary--</code>. Swap with <code>A[high_boundary]</code>. (Don&rsquo;t advance <code>current_checker</code>).
*   <strong>Tests:</strong> Advanced in-place partitioning, multiple pointer management, handling conditional logic carefully (especially not advancing <code>current_checker</code> in one case). Core to Quicksort.</p>
<hr>
<p><strong>3. Section 5.2: Increment an Arbitrary-Precision Integer</strong>
*   <strong>Problem:</strong> Array <code>[1,2,9]</code> (is 129). Update to <code>[1,3,0]</code>. Handle <code>[9,9]</code> -&gt; <code>[1,0,0]</code>.
*   <strong>Intuition/Analogy:</strong> Grade-school addition: add 1 to the rightmost digit, propagate carries to the left.
*   <strong>Pattern(s):</strong> Array as Large Number, Right-to-Left Processing, Carry Propagation.
*   <strong>Implementation Steps:</strong>
1.  <code>A[last_idx] += 1</code>.
2.  Loop <code>i</code> from <code>last_idx</code> down to <code>1</code>: If <code>A[i] == 10</code>, set <code>A[i]=0</code>, <code>A[i-1]++</code>. Else break.
3.  If <code>A[0] == 10</code>: Set <code>A[0]=1</code>, append <code>0</code>.
*   <strong>Tests:</strong> Simulating arithmetic, edge case of increasing length.</p>
<hr>
<p><strong>4. Section 5.3: Multiply Two Arbitrary-Precision Integers</strong>
*   <strong>Problem:</strong> Multiply two numbers given as arrays of digits.
*   <strong>Intuition/Analogy:</strong> Grade-school long multiplication. Result array is sum of partial products.
*   <strong>Pattern(s):</strong> Array as Large Number, Nested Right-to-Left Processing, Place Value Arithmetic.
*   <strong>Implementation Steps:</strong>
1.  Handle signs. Make digit arrays positive.
2.  <code>result</code> array (size <code>len1+len2</code>) of zeros.
3.  For <code>d1</code> in <code>num1</code> (right-to-left, index <code>i</code>):
For <code>d2</code> in <code>num2</code> (right-to-left, index <code>j</code>):
<code>result[i+j+1] += d1 * d2</code>.
<code>result[i+j] += result[i+j+1] // 10</code> (carry).
<code>result[i+j+1] %= 10</code>.
4.  Remove leading zeros from <code>result</code>. Apply sign.
*   <strong>Tests:</strong> Complex arithmetic simulation, index management, carry logic.</p>
<hr>
<p><strong>5. Section 5.4: Advancing Through an Array</strong>
*   <strong>Problem:</strong> Can you reach the last index of an array, where <code>A[i]</code> is the max jump from <code>i</code>?
*   <strong>Intuition/Analogy:</strong> &ldquo;Hopping Stones.&rdquo; Keep track of the &ldquo;furthest stone I could possibly reach&rdquo; from any stone visited so far. If current stone <code>i</code> is beyond this, I&rsquo;m stuck.
*   <strong>Pattern(s):</strong> Greedy, Max Reach Tracking.
*   <strong>Implementation Steps:</strong>
1.  <code>max_reach = 0</code>.
2.  Loop <code>i</code> from <code>0</code> to <code>len(A)-1</code>:
*   If <code>i &gt; max_reach</code>: Return <code>False</code>.
*   <code>max_reach = max(max_reach, i + A[i])</code>.
*   If <code>max_reach &gt;= last_index</code>: Return <code>True</code>.
3.  Return <code>max_reach &gt;= last_index</code>. (Book&rsquo;s loop condition <code>i &lt;= max_reach &amp;&amp; max_reach &lt; last_index</code> is a compact way).
*   <strong>Tests:</strong> Greedy logic, single-pass optimization.</p>
<hr>
<p><strong>6. Section 5.5: Delete Duplicates from a Sorted Array</strong>
*   <strong>Problem:</strong> Given sorted <code>A</code>, remove duplicates in-place. Return count of unique elements.
*   <strong>Intuition/Analogy:</strong> Two &ldquo;fingers.&rdquo; One (<code>read_finger</code>) scans the array. The other (<code>write_finger</code>) points to where the next unique element should be written.
*   <strong>Pattern(s):</strong> Two-Pointer (Read &amp; Write) In-Place Filtering.
*   <strong>Implementation Steps:</strong>
1.  If empty, return 0. <code>write_idx = 1</code>.
2.  Loop <code>read_idx</code> from <code>1</code> to <code>len(A)-1</code>:
*   If <code>A[read_idx]</code> is different from <code>A[write_idx - 1]</code>:
<code>A[write_idx] = A[read_idx]</code>. <code>write_idx++</code>.
3.  Return <code>write_idx</code>.
*   <strong>Tests:</strong> Common in-place modification, leveraging &ldquo;sorted&rdquo; property.</p>
<hr>
<p><strong>7. Section 5.6: Buy and Sell a Stock Once</strong>
*   <strong>Problem:</strong> Max profit from one buy and one later sell from <code>prices</code> array.
*   <strong>Intuition/Analogy:</strong> To maximize profit <em>if I sell today</em>, I must have bought at the absolute lowest price seen <em>before today</em>.
*   <strong>Pattern(s):</strong> Iterative State Update (Track Min Seen, Max Profit).
*   <strong>Implementation Steps:</strong>
1.  <code>min_price = infinity</code>, <code>max_profit = 0</code>.
2.  For each <code>price</code> in <code>prices</code>:
<code>max_profit = max(max_profit, price - min_price)</code>.
<code>min_price = min(min_price, price)</code>.
3.  Return <code>max_profit</code>.
*   <strong>Tests:</strong> Simple DP-like thinking, single-pass optimization.</p>
<hr>
<p><strong>8. Section 5.7: Buy and Sell a Stock Twice</strong>
*   <strong>Problem:</strong> Max profit from at most two transactions (second buy after first sell).
*   <strong>Intuition/Analogy:</strong> Split the timeline. Best 2 Txs = (Best 1st Tx ending by day <code>i</code>) + (Best 2nd Tx starting after day <code>i</code>), maximized over all <code>i</code>.
*   <strong>Pattern(s):</strong> Dynamic Programming (Two Passes: Forward, then Backward &amp; Combine).
*   <strong>Implementation Steps:</strong>
1.  <strong>Forward Pass:</strong> <code>first_profits[i]</code> = max profit from 1 Tx in <code>prices[0...i]</code>.
2.  <strong>Backward Pass &amp; Combine:</strong>
<code>max_price_later = 0</code>. <code>max_total_profit = first_profits[last_idx]</code>.
Loop <code>i</code> from <code>len-1</code> down to <code>1</code>:
<code>max_price_later = max(max_price_later, prices[i])</code>.
<code>profit_from_second_tx = max_price_later - prices[i]</code>.
<code>max_total_profit = max(max_total_profit, first_profits[i-1] + profit_from_second_tx)</code>.
3.  Return <code>max_total_profit</code>.
*   <strong>Tests:</strong> More complex DP, problem decomposition, reusing subproblem solutions.</p>
<hr>
<p><strong>9. Section 5.8: Computing an Alternation</strong>
*   <strong>Problem:</strong> Rearrange <code>A</code> so <code>A[0]&lt;=A[1]&gt;=A[2]&lt;=A[3]...</code>
*   <strong>Intuition/Analogy:</strong> The desired pattern is local. Fix violations pair by pair. &ldquo;Smoothing out bumps&rdquo; locally.
*   <strong>Pattern(s):</strong> Local Condition Enforcement.
*   <strong>Implementation Steps:</strong>
1.  Loop <code>i</code> from <code>0</code> to <code>len(A)-2</code>:
*   If <code>i</code> is EVEN and <code>A[i] &gt; A[i+1]</code>: Swap <code>A[i], A[i+1]</code>.
*   If <code>i</code> is ODD and <code>A[i] &lt; A[i+1]</code>: Swap <code>A[i], A[i+1]</code>.
*   <strong>Tests:</strong> Finding simple local solutions over global ones.</p>
<hr>
<p><strong>10. Section 5.9: Enumerate All Primes to n (Sieve of Eratosthenes)</strong>
*   <strong>Problem:</strong> List all primes up to <code>n</code>.
*   <strong>Intuition/Analogy:</strong> Start with all numbers as potential primes. When a prime <code>p</code> is found, &ldquo;cross out&rdquo; all its multiples as they can&rsquo;t be prime.
*   <strong>Pattern(s):</strong> Sieving.
*   <strong>Implementation Steps:</strong>
1.  <code>is_prime</code> boolean list (size <code>n+1</code>), all <code>True</code> (0,1 <code>False</code>).
2.  Loop <code>p</code> from <code>2</code> up to <code>sqrt(n)</code>:
If <code>is_prime[p]</code>: Mark multiples of <code>p</code> (from <code>p*p</code> to <code>n</code>) as <code>False</code>.
3.  Collect <code>i</code> where <code>is_prime[i]</code> is <code>True</code>.
*   <strong>Tests:</strong> Classic algorithm, efficient prime generation.</p>
<hr>
<p><strong>11. Section 5.10: Permute the Elements of an Array</strong>
*   <strong>Problem:</strong> Apply permutation <code>P</code> to array <code>A</code> in-place. (<code>A[i]</code> moves to <code>P[i]</code>).
*   <strong>Intuition/Analogy:</strong> &ldquo;Follow the cycle.&rdquo; Pick an element, move it to its target, pick up the displaced element, move <em>it</em> to <em>its</em> target, and so on, until you return to the start. Mark elements/indices in <code>P</code> as processed to avoid redoing cycles.
*   <strong>Pattern(s):</strong> Cycle Decomposition in Permutations, In-Place Tracking.
*   <strong>Implementation Steps:</strong>
1.  Loop <code>i</code> from <code>0</code> to <code>len(A)-1</code>:
If <code>P[i]</code> is not &ldquo;marked as done&rdquo; (e.g., not negative):
<code>current_idx_in_cycle = i</code>.
<code>value_to_move = A[current_idx_in_cycle]</code>.
Loop:
<code>target_for_value = P[current_idx_in_cycle]</code>.
<code>value_at_target = A[target_for_value]</code>.
<code>A[target_for_value] = value_to_move</code>.
Mark <code>P[current_idx_in_cycle]</code> as done.
<code>current_idx_in_cycle = target_for_value</code>.
<code>value_to_move = value_at_target</code>.
If <code>current_idx_in_cycle == i</code>, break inner loop.
*   <strong>Tests:</strong> Permutation logic, in-place modification with cycle following.</p>
<hr>
<p><strong>12. Section 5.11: Compute the Next Permutation</strong>
*   <strong>Problem:</strong> Find the lexicographically next greater permutation.
*   <strong>Intuition/Analogy:</strong> Smallest increase from the right, like an odometer but with reordering.
*   <strong>Pattern(s):</strong> Lexicographical Logic, Pivot &amp; Suffix.
*   <strong>Implementation Steps:</strong>
1.  Find rightmost <code>k</code> where <code>perm[k] &lt; perm[k+1]</code>. If none, last perm.
2.  Find rightmost <code>l &gt; k</code> where <code>perm[l] &gt; perm[k]</code>.
3.  Swap <code>perm[k], perm[l]</code>.
4.  Reverse <code>perm[k+1:]</code>.
*   <strong>Tests:</strong> Careful logic, understanding lexicographical order.</p>
<hr>
<p><strong>13. Section 5.12: Sample Offline Data (Fisher-Yates for <code>k</code> items)</strong>
*   <strong>Problem:</strong> Get a uniform random subset of <code>k</code> items from array <code>A</code>. Result in <code>A[0...k-1]</code>.
*   <strong>Intuition/Analogy:</strong> &ldquo;Picking Players for a Team.&rdquo; For each team slot <code>i</code> (from <code>0</code> to <code>k-1</code>), randomly pick a player from the &ldquo;available pool&rdquo; (those at index <code>i</code> to <code>n-1</code>) and swap them into slot <code>i</code>.
*   <strong>Pattern(s):</strong> Fisher-Yates Shuffle.
*   <strong>Implementation Steps:</strong>
1.  Loop <code>i</code> from <code>0</code> to <code>k-1</code>:
<code>rand_idx = random.randrange(i, len(A))</code>.
Swap <code>A[i], A[rand_idx]</code>.
*   <strong>Tests:</strong> Standard uniform sampling, in-place array modification.</p>
<hr>
<p><strong>14. Section 5.13: Sample Online Data (Reservoir Sampling)</strong>
*   <strong>Problem:</strong> Uniform random sample of size <code>k</code> from a stream (unknown total length <code>n</code>).
*   <strong>Intuition/Analogy:</strong> &ldquo;New Guy vs. Old Guys Lottery.&rdquo; Fill reservoir with first <code>k</code>. For <code>m</code>-th item (<code>m&gt;k</code>), give it a <code>k/m</code> chance to get in. If it gets in, it randomly replaces one of the <code>k</code> already in the reservoir.
*   <strong>Pattern(s):</strong> Reservoir Sampling.
*   <strong>Implementation Steps:</strong>
1.  <code>reservoir = first k items</code>. <code>items_seen = k</code>.
2.  For each <code>new_item</code> in stream:
<code>items_seen++</code>.
<code>rand_num = random.randrange(items_seen)</code>. (0 to <code>items_seen-1</code>)
If <code>rand_num &lt; k</code>: <code>reservoir[rand_num] = new_item</code>.
*   <strong>Tests:</strong> Probabilistic reasoning, handling streams.</p>
<hr>
<p><strong>15. Section 5.15: Compute a Random Subset (of <code>{0..n-1}</code> size <code>k</code>)</strong>
*   <strong>Problem:</strong> Generate random subset of size <code>k</code> from <code>{0..n-1}</code>.
*   <strong>Intuition/Analogy:</strong> Simulate Fisher-Yates on <code>[0..n-1]</code> but only track <em>changes</em> from the identity using a hash map (&ldquo;List of Exceptions&rdquo;) if <code>k &lt;&lt; n</code>.
*   <strong>Pattern(s):</strong> Fisher-Yates Simulation with Space Optimization.
*   <strong>Implementation Steps (for <code>k &lt;&lt; n</code>):</strong>
1.  <code>changed_elements = {}</code> (map <code>idx:val</code> if <code>val != idx</code>).
2.  Loop <code>i</code> from <code>0</code> to <code>k-1</code>:
<code>rand_idx = random.randrange(i, n)</code>.
<code>val_at_i = changed_elements.get(i, i)</code>.
<code>val_at_rand_idx = changed_elements.get(rand_idx, rand_idx)</code>.
<code>changed_elements[i] = val_at_rand_idx</code>.
<code>changed_elements[rand_idx] = val_at_i</code>.
3.  Result: <code>[changed_elements.get(j,j) for j in range(k)]</code>.
*   <strong>Tests:</strong> Algorithm choice based on constraints (<code>k</code> vs <code>n</code>), hash map usage.</p>
<hr>
<p><strong>16. Section 5.16: Generate Nonuniform Random Numbers</strong>
*   <strong>Problem:</strong> Pick numbers from a list based on given unequal probabilities.
*   <strong>Intuition/Analogy:</strong> &ldquo;Ruler with Unequal Segments.&rdquo; Divide the <code>[0,1)</code> interval into segments whose lengths match probabilities. A random dart throw into <code>[0,1)</code> determines the chosen segment.
*   <strong>Pattern(s):</strong> Cumulative Probability Mapping.
*   <strong>Implementation Steps:</strong>
1.  Compute <code>cumulative_probs</code> array.
2.  <code>rand_val = random.random()</code>.
3.  Find <code>idx</code> such that <code>cumulative_probs[idx-1] &lt;= rand_val &lt; cumulative_probs[idx]</code> (using binary search / <code>bisect_left</code>).
4.  Return <code>values[idx]</code>.
*   <strong>Tests:</strong> Mapping probabilities, using cumulative sums, binary search.</p>
<hr>
<p><strong>17. Section 5.17: The Sudoku Checker Problem</strong>
*   <strong>Problem:</strong> Is a 9x9 Sudoku grid valid (no duplicates 1-9 in rows, cols, 3x3 boxes)?
*   <strong>Intuition/Analogy:</strong> &ldquo;Checking Attendance Sheets.&rdquo; For each row, column, and box, use a temporary &ldquo;checklist&rdquo; (set or boolean array) to see if any number (1-9) appears more than once.
*   <strong>Pattern(s):</strong> Constraint Checking, Set for Uniqueness.
*   <strong>Implementation Steps:</strong>
1.  Helper <code>is_unit_valid(unit_list)</code>: uses a <code>set</code> to check for duplicates in <code>unit_list</code> (ignoring 0s).
2.  Loop through rows: call <code>is_unit_valid</code>. If <code>False</code>, return <code>False</code>.
3.  Loop through columns: extract column, call <code>is_unit_valid</code>. If <code>False</code>, return <code>False</code>.
4.  Loop through 3x3 boxes: extract box elements, call <code>is_unit_valid</code>. If <code>False</code>, return <code>False</code>.
5.  Return <code>True</code>.
*   <strong>Tests:</strong> Systematic checking, 2D array access (rows, cols, boxes), helper function use.</p>
<hr>
<p><strong>18. Section 5.18: Compute the Spiral Ordering of a 2D Array</strong>
*   <strong>Problem:</strong> Return elements of an <code>n x n</code> matrix in spiral order.
*   <strong>Intuition/Analogy:</strong> &ldquo;Robot Walk.&rdquo; Simulate a robot walking along the edges, turning clockwise when it hits a wall or an already visited path.
*   <strong>Pattern(s):</strong> 2D Traversal, State Management (position, direction).
*   <strong>Implementation Steps (Simulation):</strong>
1.  <code>result=[]</code>. <code>(r,c)=(0,0)</code>. <code>dir_idx=0</code> (Right). <code>SHIFT</code> array for <code>(dr,dc)</code>. Visited mechanism.
2.  Loop <code>n*n</code> times:
Add <code>matrix[r][c]</code> to <code>result</code>. Mark <code>(r,c)</code> visited.
<code>next_r, next_c = r + SHIFT[dir_idx][0], c + SHIFT[dir_idx][1]</code>.
If <code>(next_r, next_c)</code> is invalid (off-grid/visited):
<code>dir_idx = (dir_idx + 1) % 4</code>. (Turn)
Recalculate <code>next_r, next_c</code> with new direction.
<code>r, c = next_r, next_c</code>.
*   <strong>Tests:</strong> 2D index management, boundary conditions, state changes.</p>
<hr>
<p><strong>19. Section 5.19: Rotate a 2D Array (90 degrees clockwise, in-place)</strong>
*   <strong>Problem:</strong> Rotate an <code>n x n</code> matrix 90 degrees clockwise, in-place.
*   <strong>Intuition/Analogy:</strong> &ldquo;Layer by Layer Rotation.&rdquo; Outermost layer elements move in cycles of 4. Then process inner layer.
*   <strong>Pattern(s):</strong> In-Place 2D Transformation, Layered Processing, Cyclic Swaps.
*   <strong>Implementation Steps:</strong>
1.  Loop <code>layer</code> from <code>0</code> to <code>n//2 - 1</code>.
2.  <code>first = layer</code>, <code>last = n - 1 - layer</code>.
3.  Loop <code>offset</code> (or element index <code>j</code> along the side of the layer) from <code>first</code> to <code>last - 1</code>.
Identify the 4 elements in a cycle:
<code>P1=(first, first+offset)</code>
<code>P2=(first+offset, last)</code>
<code>P3=(last, last-offset)</code>
<code>P4=(last-offset, first)</code>
Perform 4-way circular swap: <code>Val(P4)-&gt;P1, Val(P1)-&gt;P2, Val(P2)-&gt;P3, Val(P3)-&gt;P4</code>.
*   <strong>Tests:</strong> Complex in-place 2D index manipulation.</p>
<hr>
<p><strong>20. Section 5.20: Compute Rows in Pascal&rsquo;s Triangle</strong>
*   <strong>Problem:</strong> Generate the first <code>n</code> rows of Pascal&rsquo;s Triangle.
*   <strong>Intuition/Analogy:</strong> Each number is sum of two above it. Build row by row.
*   <strong>Pattern(s):</strong> Iterative Generation based on Recurrence, Basic DP.
*   <strong>Implementation Steps:</strong>
1.  <code>result = []</code>.
2.  Loop <code>i</code> from <code>0</code> to <code>n-1</code> (for <code>n</code> rows):
<code>current_row</code> of size <code>i+1</code>.
<code>current_row[0]=1</code>, <code>current_row[i]=1</code>.
For <code>j</code> from <code>1</code> to <code>i-1</code>:
<code>current_row[j] = result[i-1][j-1] + result[i-1][j]</code>.
Add <code>current_row</code> to <code>result</code>.
*   <strong>Tests:</strong> Translating rule to code, list of lists, simple DP.</p>
<hr>


                
                
            </div>
        </div>

    </article>

    </main>

    
        <footer>
    
    <p>&copy; 2025 Deepanshu Kandpal</p>
</footer> 
    
</body>
</html> 