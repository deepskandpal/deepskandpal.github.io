<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#the-vanishingexploding-gradients-problems>The Vanishing/Exploding Gradients Problems</a></li><li><a href=#nonsaturating-activation-functions>Nonsaturating Activation Functions</a></li><li><a href=#batch-normalization---the-concept>Batch Normalization - The Concept</a></li><li><a href=#gradient-clipping>Gradient Clipping</a></li><li><a href=#reusing-pretrained-layers---the-concept-of-transfer-learning>Reusing Pretrained Layers - The Concept of Transfer Learning</a></li><li><a href=#faster-optimizers>Faster Optimizers</a></li><li><a href=#learning-rate-scheduling---the-why-and-how>Learning Rate Scheduling - The Why and How</a></li><li><a href=#avoiding-overfitting-through-regularization---introduction>Avoiding Overfitting Through Regularization - Introduction</a></li><li><a href=#dropout>Dropout</a></li><li><a href=#summary-and-practical-guidelines>Summary and Practical Guidelines</a></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 11: Training Deep Neural Networks</h1><span class=reading-time><em>1 hour read</em></span><div class=book-details><div class=book-content><p>Link to the conversation with <a href=https://aistudio.google.com/prompts/1bO4Mc-_wnw9swIgVzKyYO2F1z9iNqKJN>LLM</a></p><p>Chapter 10 introduced ANNs, and we even notionally &ldquo;trained&rdquo; some (though they were relatively shallow, with just a few hidden layers). But what happens when you need to tackle really complex problems, like detecting hundreds of object types in high-resolution images?</p><ul><li>You might need a much <strong>deeper DNN</strong> (10+ layers, hundreds of neurons per layer, hundreds of thousands or millions of connections).</li><li>Training such a deep DNN is <strong>not a walk in the park</strong>.</li></ul><p>The chapter immediately highlights several common problems you could run into:</p><ol><li><p><strong>Vanishing or Exploding Gradients:</strong></p><ul><li>This is a critical issue. As gradients flow backward through the network during backpropagation (from the output layer to the input layer), they can either:<ul><li><strong>Vanish:</strong> Get smaller and smaller, until the gradients for the lower layers (those closer to the input) are tiny. This means the weights of these lower layers barely get updated, and the network effectively stops learning in those early layers.</li><li><strong>Explode:</strong> Get larger and larger, until the weight updates for lower layers become insanely huge, causing the training algorithm to diverge.</li></ul></li><li>Both make lower layers very hard to train effectively.</li></ul></li><li><p><strong>Not Enough Training Data:</strong></p><ul><li>Large, deep networks have many parameters (weights and biases).</li><li>They often require vast amounts of training data to learn these parameters well and generalize without overfitting.</li><li>Getting enough <em>labeled</em> data can be very costly and time-consuming.</li></ul></li><li><p><strong>Extremely Slow Training:</strong></p><ul><li>More layers, more neurons, more connections, more data = much more computation per epoch. Training can take days, weeks, or even longer.</li></ul></li><li><p><strong>Risk of Overfitting:</strong></p><ul><li>A model with millions of parameters can easily memorize the training set (especially if the dataset isn&rsquo;t proportionally huge or is noisy), leading to poor performance on new, unseen data.</li></ul></li></ol><p><strong>Chapter Goals:</strong>
This chapter will go through each of these problems and present techniques to solve them:</p><ul><li><strong>Vanishing/Exploding Gradients:</strong> We&rsquo;ll look at their causes and popular solutions (like better weight initialization, non-saturating activation functions, Batch Normalization, Gradient Clipping).</li><li><strong>Lack of Labeled Data / Complex Tasks:</strong> We&rsquo;ll explore <strong>transfer learning</strong> and <strong>unsupervised pretraining</strong>.</li><li><strong>Slow Training:</strong> We&rsquo;ll discuss various <strong>faster optimizers</strong>.</li><li><strong>Overfitting:</strong> We&rsquo;ll cover popular <strong>regularization techniques</strong> for large neural networks.</li></ul><hr><h2 id=the-vanishingexploding-gradients-problems>The Vanishing/Exploding Gradients Problems</h2><p>This is a fundamental challenge in training deep networks.</p><ul><li><p><strong>The Core Issue:</strong></p><ul><li>Backpropagation involves propagating the error gradient backward from the output layer to the input layer.</li><li>As these gradients are passed from layer to layer, they are multiplied by the weights of those layers (and the derivatives of activation functions).</li><li>If weights (or activation function derivatives) are consistently small, the gradients shrink exponentially as they go backward -> <strong>Vanishing Gradients</strong>. The lower layers learn very slowly or not at all.</li><li>If weights (or derivatives) are consistently large, the gradients grow exponentially -> <strong>Exploding Gradients</strong>. Training becomes unstable and diverges.</li><li>More generally, deep networks suffer from <strong>unstable gradients</strong>, where different layers may learn at vastly different speeds.</li></ul></li><li><p><strong>Historical Context:</strong></p><ul><li>This unstable gradient behavior was observed long ago and was a key reason deep NNs were largely abandoned in the early 2000s.</li><li>The cause wasn&rsquo;t entirely clear until a landmark 2010 paper by <strong>Xavier Glorot and Yoshua Bengio</strong>.</li></ul></li><li><p><strong>Glorot and Bengio&rsquo;s Findings (2010 Paper - Footnote 1):</strong>
They identified key culprits:</p><ol><li><strong>Logistic Sigmoid Activation Function:</strong><ul><li><strong>Figure 11-1</strong> shows the logistic sigmoid. When its inputs become large (positive or negative), the function <strong>saturates</strong> at 0 or 1.<figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-1.png alt="Figure 11-1. Logistic activation function saturation" width=700></figure></li><li>In these saturated regions, the <strong>derivative of the sigmoid function is extremely close to 0.</strong></li><li>During backpropagation, when gradients are passed through a saturated sigmoid neuron, they get multiplied by this near-zero derivative, effectively getting squashed.</li><li>If many layers have saturated sigmoids, the gradient can get diluted to almost nothing by the time it reaches the lower layers.</li></ul></li><li><strong>Traditional Weight Initialization:</strong> At the time, weights were often initialized from a normal distribution with mean 0 and standard deviation 1.</li></ol><ul><li><strong>Variance Imbalance:</strong> Glorot and Bengio showed that with this combination (sigmoid activation + standard normal initialization), the <strong>variance of the outputs of each layer is much greater than the variance of its inputs.</strong></li><li>As the signal flows forward, the variance keeps increasing layer by layer. This pushes the inputs to the activation functions of the upper layers into their saturated regions (where derivatives are ~0).</li><li>The problem is worsened because the logistic function has a mean of 0.5, not 0 (tanh, with mean 0, behaves slightly better).</li></ul></li><li><p><strong>The Goal for Proper Signal Flow (Glorot & Bengio&rsquo;s Insight - Page 333):</strong>
For a signal (activations forward, gradients backward) to flow properly without dying out or exploding:</p><ol><li>The <strong>variance of the outputs</strong> of each layer should be (roughly) equal to the <strong>variance of its inputs</strong>.</li><li>The <strong>gradients</strong> should have (roughly) equal variance <em>before</em> and <em>after</em> flowing through a layer in the reverse direction.</li></ol><ul><li>The analogy (footnote 2) is excellent: a chain of microphone amplifiers. Each needs to be set correctly so your voice comes out clearly at the end, with consistent amplitude through the chain.</li></ul><p>It&rsquo;s hard to guarantee both conditions 1 & 2 simultaneously unless a layer has an equal number of inputs (<strong>fan-in</strong>) and outputs/neurons (<strong>fan-out</strong>).</p></li><li><p><strong>Xavier/Glorot Initialization (Equation 11-1, Page 334):</strong>
Glorot and Bengio proposed a practical compromise for weight initialization that works well:</p><ul><li>Initialize connection weights randomly.</li><li>The distribution should have a mean of 0.</li><li>The variance <code>σ²</code> should depend on <code>fan_in</code> and <code>fan_out</code>:
<code>σ² = 1 / fan_avg</code> where <code>fan_avg = (fan_in + fan_out) / 2</code>.
(For a uniform distribution between <code>-r</code> and <code>r</code>, <code>r = sqrt(3 / fan_avg)</code>).</li><li><em>What this initialization is ultimately trying to achieve:</em> It aims to keep the variance of activations and backpropagated gradients roughly constant across layers, preventing them from vanishing or exploding. It helps the signal propagate properly.</li><li>This significantly speeds up training and was a key factor in the success of Deep Learning.</li></ul></li><li><p><strong>LeCun Initialization (Page 334):</strong></p><ul><li>An earlier strategy by Yann LeCun (1990s). If you replace <code>fan_avg</code> with just <code>fan_in</code> in Equation 11-1, you get LeCun initialization.</li><li>Equivalent to Glorot when <code>fan_in = fan_out</code>.</li></ul></li><li><p><strong>He Initialization (Kaiming He et al., 2015 - Footnote 3, Page 334):</strong></p><ul><li>Glorot initialization works well for sigmoid, tanh, and softmax.</li><li>For <strong>ReLU</strong> and its variants (which became very popular), a different initialization is needed because ReLU behaves differently (it kills half the activations, which changes variance).</li><li><strong>He Initialization</strong> uses:
<code>σ² = 2 / fan_in</code>
(For a uniform distribution, <code>r = sqrt(6 / fan_in)</code>).</li></ul></li><li><p><strong>Table 11-1</strong> summarizes initialization strategies for different activation functions:<figure><img src=/bookshelf/hands-on-ml/ch-11-tbl-11-1.png alt="Table 11-1. Initialization parameters for each type of activation function" width=700></figure></p><ul><li><strong>Glorot:</strong> For None (linear output), tanh, logistic, softmax. Variance <code>1 / fan_avg</code>.</li><li><strong>He:</strong> For ReLU and variants. Variance <code>2 / fan_in</code>.</li><li><strong>LeCun:</strong> For SELU (we&rsquo;ll see this soon). Variance <code>1 / fan_in</code>.</li></ul></li><li><p><strong>Keras Implementation (Page 334):</strong></p><ul><li>Keras uses Glorot initialization with a uniform distribution by default for its <code>Dense</code> layers.</li><li>You can change it using <code>kernel_initializer</code>:
<code>keras.layers.Dense(10, activation="relu", kernel_initializer="he_normal")</code>
<code>keras.layers.Dense(10, activation="relu", kernel_initializer="he_uniform")</code></li><li>For He initialization with uniform distribution based on <code>fan_avg</code> (instead of <code>fan_in</code>):
<code>he_avg_init = keras.initializers.VarianceScaling(scale=2., mode='fan_avg', distribution='uniform')</code>
<code>keras.layers.Dense(..., kernel_initializer=he_avg_init)</code></li></ul></li></ul><p>These initialization strategies are crucial first steps to combat unstable gradients. <strong>They are all trying to set the initial weights to a &ldquo;sensible&rdquo; scale so that the signal (activations and gradients) can propagate through many layers without becoming too small or too large too quickly.</strong></p><hr><h2 id=nonsaturating-activation-functions>Nonsaturating Activation Functions</h2><p>We&rsquo;ve seen that a poor choice of activation function (like the traditional sigmoid) combined with older initialization methods was a major cause of unstable gradients. The Glorot & Bengio paper highlighted this.</p><p><strong>The Problem with Saturating Activation Functions (like Sigmoid/Tanh):</strong></p><ul><li><strong>Saturation:</strong> Functions like sigmoid and tanh &ldquo;saturate&rdquo; – their output flattens out and approaches a fixed value (0 or 1 for sigmoid, -1 or 1 for tanh) when the input <code>z</code> becomes very large (positive or negative).</li><li><strong>Vanishing Gradients:</strong> In these saturated regions, the <strong>derivative of the activation function is extremely close to zero.</strong> (Look at Figure 11-1 again for sigmoid).</li><li><strong>Impact on Backpropagation:</strong> During backpropagation, the error gradient from the layer above gets multiplied by the local derivative of the activation function. If this derivative is tiny (due to saturation), the gradient being passed back is also tiny.</li><li><strong>Chain Reaction:</strong> If many layers have neurons operating in their saturated regions, this &ldquo;gradient squashing&rdquo; effect compounds as it goes backward through the network. The gradients reaching the early layers become vanishingly small, and those layers learn very slowly or not at all.</li></ul><p><strong>The Solution: Nonsaturating Activation Functions</strong></p><p>The insight was to use activation functions that don&rsquo;t saturate as easily, especially for positive input values.</p><ol><li><p><strong>ReLU (Rectified Linear Unit) (Page 335):</strong></p><ul><li><code>ReLU(z) = max(0, z)</code></li><li><strong>Key Property:</strong> For positive values (<code>z > 0</code>), ReLU <em>does not saturate</em>. Its output is just <code>z</code>, and its derivative is 1.</li><li>This means if a neuron is active (its input <code>z > 0</code>), the gradient can pass through it backward <em>unchanged</em> (multiplied by 1). This greatly helps prevent the vanishing gradient problem for positive activations.</li><li>It&rsquo;s also very fast to compute.</li><li><strong>The &ldquo;Dying ReLUs&rdquo; Problem:</strong><ul><li>ReLU is not perfect. If a neuron&rsquo;s weights get adjusted such that the weighted sum of its inputs (<code>z</code>) becomes negative for <em>all instances in the training set</em>, that neuron will always output 0.</li><li>Since the derivative of ReLU is 0 for <code>z &lt; 0</code>, no gradient will flow back through this &ldquo;dead&rdquo; neuron, and its weights will never be updated again. It effectively dies.</li><li>This can happen if the learning rate is too large or due to poor initialization.</li><li>Footnote 4 mentions a dead neuron <em>might</em> sometimes come back to life if neurons in <em>previous</em> layers change their outputs enough to make its input <code>z</code> positive again, but it&rsquo;s not guaranteed.</li></ul></li></ul></li><li><p><strong>Leaky ReLU and its Variants (Page 335):</strong></p><ul><li><strong>Goal:</strong> To solve the &ldquo;dying ReLUs&rdquo; problem.</li><li><strong>Leaky ReLU:</strong><figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-2.png alt="Figure 11-2. Leaky ReLU: like ReLU, but with a small slope for negative values" width=700></figure><code>LeakyReLU_α(z) = max(αz, z)</code><ul><li><code>α</code> (alpha) is a small hyperparameter (e.g., 0.01 or 0.2) that defines the slope for <code>z &lt; 0</code>.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> It allows a small, non-zero gradient to flow back even when the unit is not active (i.e., <code>z &lt; 0</code>). This ensures the neuron never truly &ldquo;dies&rdquo; – it can always recover.</li><li>A 2015 paper (footnote 5) found that leaky variants always outperformed strict ReLU, and a larger &ldquo;leak&rdquo; (<code>α = 0.2</code>) was better than a small one (<code>α = 0.01</code>).</li></ul></li><li><strong>Randomized Leaky ReLU (RReLU):</strong> <code>α</code> is picked randomly from a given range during training and fixed to an average value during testing. Acted as a regularizer.</li><li><strong>Parametric Leaky ReLU (PReLU):</strong> <code>α</code> is <em>learned</em> during training (it becomes another parameter of the network, updated by backpropagation) instead of being a fixed hyperparameter. Reported to outperform ReLU on large image datasets but risks overfitting on smaller ones.</li></ul></li><li><p><strong>ELU (Exponential Linear Unit) (Page 336):</strong></p><ul><li>Proposed in a 2015 paper by Clevert et al. (footnote 6).</li><li><strong>Equation 11-2 & Figure 11-3:</strong><figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-3.png alt="Figure 11-3. ELU activation function" width=700></figure><code>ELU_α(z) = { α(exp(z) - 1) if z &lt; 0 }</code>
<code>{ z if z ≥ 0 }</code></li><li>Reported to outperform all ReLU variants in their experiments: reduced training time and better test set performance.</li><li><strong>Key Differences/Advantages over ReLU (Page 337):</strong><ol><li><strong>Takes on negative values when <code>z &lt; 0</code>:</strong> This allows the units to have an average output closer to 0, which can help alleviate the vanishing gradients problem (similar to how <code>tanh</code> is sometimes better than <code>sigmoid</code> because its outputs are centered around 0). The hyperparameter <code>α</code> defines the value ELU approaches for large negative <code>z</code> (usually <code>α=1</code>).</li><li><strong>Nonzero gradient for <code>z &lt; 0</code>:</strong> Avoids the dying neurons problem. The derivative for <code>z&lt;0</code> is <code>α*exp(z)</code>.</li><li><strong>Smooth everywhere (if <code>α=1</code>):</strong> Including around <code>z=0</code>. This helps Gradient Descent converge faster as it doesn&rsquo;t &ldquo;bounce&rdquo; as much around <code>z=0</code> compared to ReLU/Leaky ReLU whose slope changes abruptly.</li></ol></li><li><strong>Main Drawback:</strong> Slower to compute than ReLU (due to the <code>exp(z)</code> function). However, its faster convergence rate during training often compensates for this. At test time, an ELU network will be slower than a ReLU network.</li></ul></li><li><p><strong>SELU (Scaled ELU) (Page 337):</strong></p><ul><li>Introduced in a 2017 paper by Klambauer et al. (footnote 7).</li><li>A scaled variant of ELU.</li><li><strong>Amazing Property: Self-Normalization!</strong> If you build a network composed <em>exclusively of a stack of dense layers</em>, and <em>all hidden layers use SELU activation</em>, and a few other conditions are met, the network will <strong>self-normalize</strong>.<ul><li><em>What self-normalization achieves:</em> The output of each layer will tend to preserve a mean of 0 and standard deviation of 1 during training. This solves the vanishing/exploding gradients problem!</li><li>SELU often significantly outperforms other activation functions for such deep, dense networks.</li></ul></li><li><strong>Conditions for Self-Normalization:</strong><ol><li><strong>Input features must be standardized</strong> (mean 0, std dev 1).</li><li><strong>Every hidden layer&rsquo;s weights must be initialized with LeCun normal initialization</strong> (in Keras: <code>kernel_initializer="lecun_normal"</code>).</li><li><strong>Network architecture must be sequential.</strong> Does not guarantee self-normalization for non-sequential architectures (like RNNs or networks with skip connections like Wide & Deep).</li><li>The paper guarantees it if all layers are dense, but some researchers note it can improve performance in CNNs too.</li></ol></li></ul></li></ol><ul><li><p><strong>Which Activation Function to Use for Hidden Layers? (General Guideline - Lizard Icon, page 338):</strong></p><ul><li><strong>General Order of Preference:</strong> SELU > ELU > Leaky ReLU (and its variants) > ReLU > tanh > logistic.</li><li><strong>If network architecture prevents self-normalization (e.g., RNNs, skip connections):</strong> ELU might perform better than SELU (since SELU isn&rsquo;t smooth at <code>z=0</code>).</li><li><strong>Runtime Latency is Critical:</strong> Leaky ReLU might be preferred (simpler to compute than ELU/SELU).</li><li><strong>Simplicity/Don&rsquo;t want to tune <code>α</code>:</strong> Use default <code>α</code> values (Keras uses 0.3 for Leaky ReLU).</li><li><strong>Spare Time/Compute for CV:</strong> Evaluate RReLU (if overfitting) or PReLU (if huge training set).</li><li><strong>Absolute Speed Priority:</strong> ReLU is the most used, so many libraries and hardware have specific optimizations for it. It might still be the best choice if raw speed is paramount.</li></ul></li><li><p><strong>Keras Implementation (Page 338):</strong></p><ul><li><strong>Leaky ReLU:</strong> Add a <code>keras.layers.LeakyReLU(alpha=0.2)</code> layer <em>after</em> the <code>Dense</code> layer (if the <code>Dense</code> layer doesn&rsquo;t have an activation specified).<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>model<span style=color:#f92672>.</span>add(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>10</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>)) <span style=color:#75715e># No activation here</span>
</span></span><span style=display:flex><span>model<span style=color:#f92672>.</span>add(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>LeakyReLU(alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>))
</span></span></code></pre></div></li><li><strong>PReLU:</strong> <code>keras.layers.PReLU()</code> (can be added similarly).</li><li><strong>SELU:</strong> Set directly in the Dense layer:
<code>keras.layers.Dense(10, activation="selu", kernel_initializer="lecun_normal")</code></li></ul></li></ul><p><strong>Key Takeaway from this Section:</strong>
The choice of activation function is critical for mitigating unstable gradients in deep networks.</p><ul><li><strong>Saturating functions (sigmoid, tanh)</strong> are generally problematic for deep hidden layers due to vanishing gradients when neurons saturate.</li><li><strong>ReLU</strong> was a big step forward because it doesn&rsquo;t saturate for positive inputs, but it can suffer from &ldquo;dying neurons.&rdquo;</li><li><strong>Leaky ReLU, PReLU, ELU</strong> address the dying ReLU problem by allowing a small gradient for negative inputs. ELU also offers smoothness and outputs closer to zero mean.</li><li><strong>SELU</strong> offers self-normalization under specific conditions, often leading to the best performance for deep stacks of dense layers.</li><li><em>What all these newer activation functions are ultimately trying to achieve:</em> Maintain a healthy flow of gradients during backpropagation, allowing all layers in a deep network to learn effectively.</li></ul><p>This understanding of activation functions and their impact on gradients, combined with proper weight initialization, forms the first line of defense against the vanishing/exploding gradients problem.</p><hr><h2 id=batch-normalization---the-concept>Batch Normalization - The Concept</h2><p>Even with good initialization and activation functions, the vanishing/exploding gradients problem might not be completely solved, or it might reappear <em>during</em> training as weights get updated.</p><ul><li><p><strong>The Problem Batch Normalization (BN) Addresses:</strong></p><ul><li><strong>Internal Covariate Shift:</strong> As the parameters of preceding layers change during training, the distribution of each layer&rsquo;s inputs also changes. This makes it harder for the current layer to learn, as it&rsquo;s constantly adapting to a moving target.</li><li>Vanishing/Exploding Gradients (still a concern).</li></ul></li><li><p><strong>Batch Normalization (BN) - Proposed by Ioffe and Szegedy (2015 - Footnote 8):</strong></p><ul><li><strong>What it is:</strong> A technique that adds an operation in the model, typically just <em>before or after</em> the activation function of each hidden layer.</li><li><strong>What it does at each layer during training (for each mini-batch):</strong><ol><li><strong>Zero-centers and normalizes</strong> its inputs (makes them have mean 0 and standard deviation 1).</li><li>Then, it <strong>scales and shifts</strong> the result using two new <em>learnable</em> parameter vectors per layer:<ul><li><code>γ</code> (gamma): for scaling.</li><li><code>β</code> (beta): for shifting.</li></ul></li></ol></li><li><em>What Batch Normalization is ultimately trying to achieve (the high-level goals):</em><ol><li><strong>Reduce Internal Covariate Shift:</strong> By normalizing the inputs to each layer, it ensures that the distribution of these inputs is more stable throughout training, making it easier for each layer to learn.</li><li><strong>Combat Vanishing/Exploding Gradients:</strong> By keeping the inputs to activation functions in a more controlled range (around mean 0, std dev 1 before scaling/shifting), it helps prevent them from saturating (for sigmoid/tanh) or dying (for ReLU, by potentially shifting inputs to be positive more often).</li><li><strong>Allow higher learning rates:</strong> Training becomes more stable, often permitting the use of larger learning rates, which speeds up convergence.</li><li><strong>Act as a regularizer:</strong> It adds a bit of noise to each layer&rsquo;s inputs (due to mini-batch statistics varying), which can have a slight regularizing effect, sometimes reducing the need for other regularization like dropout.</li><li><strong>Reduce sensitivity to weight initialization.</strong></li></ol></li></ul></li><li><p><strong>How BN Works - The Algorithm (Equation 11-3, Page 339):</strong>
For each input feature (or activation from a previous neuron) within a mini-batch <code>B</code>:</p><ol><li><strong><code>μ_B = (1/m_B) * Σᵢ x⁽ⁱ⁾</code></strong>: Calculate the mean (<code>μ_B</code>) of that input feature over the current mini-batch <code>B</code> (which has <code>m_B</code> instances).</li><li><strong><code>σ_B² = (1/m_B) * Σᵢ (x⁽ⁱ⁾ - μ_B)²</code></strong>: Calculate the variance (<code>σ_B²</code>) of that input feature over the current mini-batch.</li><li><strong><code>x̂⁽ⁱ⁾ = (x⁽ⁱ⁾ - μ_B) / sqrt(σ_B² + ε)</code></strong>: Normalize the input <code>x⁽ⁱ⁾</code> for each instance. <code>ε</code> (epsilon) is a small smoothing term to avoid division by zero (e.g., 10⁻⁵). Now <code>x̂⁽ⁱ⁾</code> has mean ~0 and std dev ~1 <em>over this mini-batch</em>.</li><li><strong><code>z⁽ⁱ⁾ = γ ⊗ x̂⁽ⁱ⁾ + β</code></strong>: Scale (<code>γ</code>) and shift (<code>β</code>) the normalized input.<ul><li><code>γ</code> (gamma) and <code>β</code> (beta) are <strong>learnable parameters</strong> for this BN layer (one <code>γ</code> and one <code>β</code> per input feature to the layer). They are learned via backpropagation just like weights and biases of dense layers.</li><li><em>What <code>γ</code> and <code>β</code> are ultimately trying to achieve:</em> They allow the network to learn the optimal scale and mean for the inputs to the <em>next</em> layer. While the previous steps normalize to mean 0 / std dev 1, maybe the next activation function performs better if its inputs have, say, mean 0.5 and std dev 2. <code>γ</code> and <code>β</code> let the network learn this. If <code>γ = sqrt(σ_B² + ε)</code> and <code>β = μ_B</code>, the BN layer effectively undoes the normalization for that batch.</li></ul></li></ol></li><li><p><strong>BN at Test Time (Inference) (Page 340):</strong></p><ul><li>During training, <code>μ_B</code> and <code>σ_B</code> are computed per mini-batch.</li><li>At test time, you might be making predictions for individual instances, so there&rsquo;s no mini-batch to compute a mean/std dev from. Even with a batch, it might be too small or not representative.</li><li><strong>Solution:</strong> During training, BN layers estimate the &ldquo;final&rdquo; population mean <code>μ</code> and standard deviation <code>σ</code> for each input feature using an <strong>exponential moving average</strong> of the mini-batch <code>μ_B</code>&rsquo;s and <code>σ_B</code>&rsquo;s.</li><li>At test time, these final <code>μ</code> and <code>σ</code> are used in step 3 instead of batch-specific <code>μ_B</code> and <code>σ_B</code>. The learned <code>γ</code> and <code>β</code> are always used.</li><li>Keras handles this automatically.</li></ul></li><li><p><strong>Benefits Demonstrated by Ioffe and Szegedy (Page 340):</strong></p><ul><li>BN considerably improved all deep networks they experimented with.</li><li>Huge improvement on ImageNet classification.</li><li>Vanishing gradients problem strongly reduced, allowing use of saturating activations like tanh/sigmoid.</li><li>Less sensitive to weight initialization.</li><li>Able to use much larger learning rates, significantly speeding up learning.</li><li>Acts as a regularizer, reducing need for other methods like dropout.</li></ul></li><li><p><strong>Complexity and Runtime Penalty (Page 341):</strong></p><ul><li>BN adds complexity to the model.</li><li>There&rsquo;s a runtime penalty during inference due to extra computations at each layer.</li><li><strong>Optimization:</strong> It&rsquo;s often possible to <strong>fuse the BN layer with the preceding Dense layer</strong> <em>after training</em>. The weights and biases of the Dense layer are updated to directly produce outputs of the appropriate scale and offset, effectively incorporating the BN operation. TFLite&rsquo;s optimizer can do this automatically.</li><li><strong>Training Time (Wall Clock):</strong> Although each epoch takes longer with BN, convergence is much faster (fewer epochs needed), so overall &ldquo;wall clock&rdquo; training time is usually shorter.</li></ul></li></ul><p><strong>(Page 341-344: Implementing Batch Normalization with Keras)</strong></p><ul><li><p><strong>Simple Implementation:</strong></p><ul><li>Add a <code>keras.layers.BatchNormalization()</code> layer before or after each hidden layer&rsquo;s activation function.</li><li>Optionally, add a BN layer as the very first layer (after Flatten, if using Flatten). If you do this, you might not need to standardize your input data with <code>StandardScaler</code>, as the BN layer will handle normalization (approximately, as it uses mini-batch stats).</li><li><strong>Example with BN <em>after</em> activation (page 342):</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>model <span style=color:#f92672>=</span> keras<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Flatten(input_shape<span style=color:#f92672>=</span>[<span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>28</span>]),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>BatchNormalization(), <span style=color:#75715e># As first layer</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>300</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>BatchNormalization(), <span style=color:#75715e># After first hidden layer&#39;s activation</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>100</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>BatchNormalization(), <span style=color:#75715e># After second hidden layer&#39;s activation</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>10</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;softmax&#34;</span>)
</span></span><span style=display:flex><span>])
</span></span></code></pre></div></li><li>For shallow networks, BN might not have a huge impact, but for deeper ones, it can be a game-changer.</li></ul></li><li><p><strong>Parameters Added by BN Layer (Page 342):</strong></p><ul><li>Each BN layer adds 4 parameters per input feature it processes:<ol><li><code>γ</code> (gamma - scale): Trainable (learned by backprop).</li><li><code>β</code> (beta - shift): Trainable.</li><li><code>μ</code> (moving_mean): Non-trainable (estimated using moving average).</li><li><code>σ</code> (moving_variance): Non-trainable (estimated using moving average).</li></ol></li><li>So, if a BN layer receives 784 inputs, it adds <code>4 * 784 = 3136</code> parameters. <code>2 * 784</code> are trainable (<code>γ</code>, <code>β</code>), <code>2 * 784</code> are non-trainable (<code>μ</code>, <code>σ</code>).</li></ul></li><li><p><strong>BN Before or After Activation? (Page 343):</strong></p><ul><li>The original BN paper suggested adding BN <em>before</em> the activation function. The example above added it <em>after</em>.</li><li>There&rsquo;s some debate; what&rsquo;s preferable seems to depend on the task and dataset. Experiment to see what works best.</li><li><strong>To add BN <em>before</em> activation:</strong><ol><li>Remove the activation from the <code>Dense</code> layer (<code>activation=None</code> or just omit it).</li><li>Add the <code>BatchNormalization</code> layer.</li><li>Add an <code>keras.layers.Activation("elu")</code> layer separately.</li><li>Also, since BN includes a shift parameter <code>β</code> per input, you can remove the bias term from the preceding <code>Dense</code> layer by setting <code>use_bias=False</code>. This is slightly more efficient.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>model<span style=color:#f92672>.</span>add(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>300</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>, use_bias<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>))
</span></span><span style=display:flex><span>model<span style=color:#f92672>.</span>add(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>BatchNormalization())
</span></span><span style=display:flex><span>model<span style=color:#f92672>.</span>add(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Activation(<span style=color:#e6db74>&#34;elu&#34;</span>))
</span></span></code></pre></div></li></ul></li><li><p><strong><code>BatchNormalization</code> Hyperparameters (Page 343):</strong></p><ul><li><code>momentum</code>: Used for updating the exponential moving averages for <code>μ</code> and <code>σ</code>. Given new batch stats <code>v_batch</code>, running average <code>v̂</code> is updated as: <code>v̂ ← v̂ * momentum + v_batch * (1 - momentum)</code>.<ul><li>A good value is typically close to 1 (e.g., 0.9, 0.99, 0.999). More 9s for larger datasets/smaller mini-batches. Default is 0.99.</li></ul></li><li><code>axis</code>: Determines which axis should be normalized. Defaults to -1 (last axis).<ul><li>For a <code>Dense</code> layer, inputs are usually <code>(batch_size, features)</code>. <code>axis=-1</code> normalizes each feature independently across the batch.</li><li>If BN is applied to 3D inputs like <code>(batch_size, height, width)</code> (e.g., before Flatten, or in CNNs), <code>axis=-1</code> would normalize along the <code>width</code> dimension. If you want to normalize each of the <code>height*width</code> pixels independently, you might set <code>axis=[1,2]</code>.</li></ul></li></ul></li><li><p><strong><code>call()</code> Method and <code>training</code> Argument (Page 344):</strong></p><ul><li>The <code>BatchNormalization</code> layer&rsquo;s <code>call()</code> method has a <code>training</code> argument.</li><li><code>model.fit()</code> automatically sets this to <code>True</code> during training (so BN uses mini-batch stats and updates moving averages).</li><li><code>model.evaluate()</code> and <code>model.predict()</code> automatically set it to <code>False</code> (so BN uses the final moving averages).</li><li>This is important if you write custom layers that need to behave differently during training vs. inference.</li></ul></li><li><p><strong>BN as a Standard (Page 344):</strong></p><ul><li>BN became so popular that it&rsquo;s often assumed to be used after every (or most) layers in deep networks, sometimes even omitted in diagrams.</li><li>However, recent research (e.g., &ldquo;Fixup Initialization&rdquo; by Zhang et al., 2019 - footnote 11) has shown it&rsquo;s possible to train very deep networks <em>without</em> BN by using novel weight initialization techniques. This is bleeding-edge, so for now, BN remains a very strong default.</li></ul></li></ul><p><strong>Key Takeaway for Batch Normalization:</strong>
BN is a powerful technique that normalizes the inputs to each layer during training, then scales/shifts them with learnable parameters.</p><ul><li><strong>Ultimately, it aims to:</strong><ul><li>Stabilize and speed up training (allowing higher learning rates).</li><li>Reduce the vanishing/exploding gradient problem.</li><li>Make the network less sensitive to weight initialization.</li><li>Provide a slight regularization effect.
It&rsquo;s a very common and effective component in modern deep neural networks.</li></ul></li></ul><p>Great! Batch Normalization is indeed a very impactful technique.</p><hr><h2 id=gradient-clipping>Gradient Clipping</h2><p>While Batch Normalization helps with unstable gradients generally, sometimes gradients can still become excessively large, especially in certain types of networks like Recurrent Neural Networks (RNNs, Chapter 15). This is the <strong>exploding gradients</strong> problem.</p><ul><li><p><strong>The Problem:</strong> If gradients become huge, the parameter updates during Gradient Descent will also be huge (<code>θ ← θ - η * large_gradient</code>). This can cause the algorithm to overshoot the optimal solution wildly, leading to divergence (loss goes to infinity) or very unstable training.</p></li><li><p><strong>Gradient Clipping - The Technique:</strong></p><ul><li>A popular technique to mitigate exploding gradients.</li><li><strong>What it&rsquo;s ultimately trying to achieve:</strong> To prevent the gradients from becoming too large by imposing a threshold on them during backpropagation. If a gradient exceeds this threshold, it&rsquo;s &ldquo;clipped&rdquo; (scaled down) to the threshold value.</li><li>This is most often used in RNNs, as Batch Normalization can be tricky to apply effectively in those architectures. For other types of networks (like the MLPs we&rsquo;ve been discussing), Batch Normalization is usually sufficient to handle unstable gradients.</li></ul></li><li><p><strong>Implementing Gradient Clipping in Keras:</strong>
It&rsquo;s done by setting an argument when creating an <strong>optimizer</strong>. Keras supports two main types of clipping:</p><ol><li><p><strong>Clipping by Value:</strong>
<code>optimizer = keras.optimizers.SGD(clipvalue=1.0)</code></p><ul><li>This will clip <em>every component</em> (each partial derivative) of the gradient vector to be within a specific range. In this example, between -1.0 and +1.0.</li><li>So, if any <code>∂Loss/∂wᵢⱼ</code> is, say, 3.5, it will be clipped to 1.0. If it&rsquo;s -2.0, it will be clipped to -1.0.</li><li><strong>Caveat:</strong> Clipping each component individually <em>may change the orientation (direction)</em> of the overall gradient vector. For instance, if the original gradient was <code>[0.9, 100.0]</code> (pointing mostly along the second axis), after clipping by value to 1.0, it becomes <code>[0.9, 1.0]</code> (pointing roughly diagonally).</li><li>Despite this, it often works well in practice. The <code>clipvalue</code> is a hyperparameter you can tune.</li></ul></li><li><p><strong>Clipping by Norm:</strong>
<code>optimizer = keras.optimizers.SGD(clipnorm=1.0)</code></p><ul><li>This method ensures that the <em>direction</em> of the gradient vector is preserved.</li><li>It calculates the <strong>ℓ₂ norm</strong> of the <em>entire</em> gradient vector <code>||∇Loss||₂</code>.</li><li>If this norm is greater than the <code>clipnorm</code> threshold (e.g., 1.0), the <em>entire gradient vector</em> is scaled down so that its norm equals the threshold.
<code>gradient ← gradient * (clipnorm / ||gradient||₂)</code></li><li>For example, if <code>clipnorm=1.0</code> and the original gradient is <code>[0.9, 100.0]</code> (whose norm is <code>sqrt(0.9² + 100.0²) ≈ 100.004</code>), it will be scaled down to something like <code>[0.00899964, 0.9999595]</code>. The direction is preserved, but the magnitude is reduced to 1.0.</li><li>This can be gentler as it doesn&rsquo;t distort the gradient direction, but it might almost eliminate components that were originally small if one component was huge.</li></ul></li></ol></li><li><p><strong>When to Use:</strong></p><ul><li>If you observe that gradients are exploding during training (you can track gradient norms using TensorBoard, for example, or just see your loss skyrocket), you might want to try gradient clipping.</li><li>Experiment with both clipping by value and clipping by norm, and different threshold values, to see which works best for your specific problem and network.</li></ul></li></ul><p><strong>Key Takeaway for Gradient Clipping:</strong>
It&rsquo;s a straightforward technique primarily used to prevent the exploding gradients problem by limiting the maximum size of the gradients used in the parameter updates. While BN is often preferred for feedforward networks, clipping is a valuable tool, especially for RNNs.</p><p>This technique directly addresses one of the &ldquo;pain points&rdquo; of training deep networks. Next, the chapter moves on to strategies for dealing with another major challenge: not having enough labeled training data, by discussing <strong>Reusing Pretrained Layers (Transfer Learning)</strong>.</p><p>Sounds good! Gradient clipping is indeed a practical fix for a very real problem.</p><p>Now, let&rsquo;s move on to a very powerful and widely used set of techniques for training deep neural networks, especially when you don&rsquo;t have massive amounts of labeled data: <strong>Reusing Pretrained Layers</strong>, which is the core idea behind <strong>Transfer Learning</strong> (Pages 345-349).</p><hr><h2 id=reusing-pretrained-layers---the-concept-of-transfer-learning>Reusing Pretrained Layers - The Concept of Transfer Learning</h2><ul><li><p><strong>The Problem:</strong> Training a very large Deep Neural Network (DNN) from scratch generally requires a huge amount of training data. What if you don&rsquo;t have that much data for your specific task?</p></li><li><p><strong>The Solution: Transfer Learning</strong></p><ul><li><strong>Core Idea:</strong> It&rsquo;s generally <em>not</em> a good idea to train a very large DNN from scratch if you can avoid it. Instead, you should almost always try to find an <strong>existing neural network that was trained on a large dataset to accomplish a task <em>similar</em> to yours</strong>. Then, you reuse the lower layers of this pretrained network for your own new model.</li><li><em>What transfer learning is ultimately trying to achieve:</em><ol><li><strong>Speed up training considerably:</strong> Your model doesn&rsquo;t have to learn low-level features from scratch.</li><li><strong>Require significantly less training data for your specific task:</strong> The pretrained layers have already learned general features from a large dataset, which are often useful for your new task.</li><li>Often achieve <strong>better performance</strong> than training from scratch, especially with limited data.</li></ol></li></ul></li><li><p><strong>Why it Works (Hierarchical Feature Learning):</strong></p><ul><li>As we discussed in Chapter 10 (and mentioned in this chapter on page 323), deep neural networks learn features in a hierarchical fashion.<ul><li><strong>Lower layers</strong> (closer to the input) tend to learn low-level features (e.g., edges, corners, simple textures in images; basic phonetic sounds in speech). These low-level features are often generic and useful across many different tasks.</li><li><strong>Upper hidden layers</strong> learn more complex, task-specific features by combining the low-level features from earlier layers (e.g., parts of objects like &ldquo;wheel&rdquo; or &ldquo;eye&rdquo; in images; words or phrases in speech).</li><li><strong>Output layer</strong> learns to combine these high-level features to make the final prediction for the original task.</li></ul></li></ul></li><li><p><strong>Applying Transfer Learning (Figure 11-4):</strong><figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-4.png alt="Figure 11-4. Reusing pretrained layers" width=700></figure></p><ul><li>Suppose you have a DNN (Model A) pretrained on a large dataset for a general task (e.g., classifying images into 100 categories like animals, plants, vehicles).</li><li>You now want to train a DNN (Model B) for a new, more specific task (e.g., classifying only specific types of vehicles), and you have limited data for this new task.</li><li><strong>Steps:</strong><ol><li><strong>Reuse Lower Layers:</strong> Take the lower layers from Model A (which learned general features) and use them as the initial layers for your Model B.</li><li><strong>Replace or Retrain Upper Layers:</strong> The upper hidden layers and the output layer of Model A are more specific to its original task.<ul><li>The <strong>output layer</strong> of Model A must usually be replaced because it&rsquo;s likely not useful for Model B (e.g., different number of classes, different types of outputs).</li><li>The <strong>upper hidden layers</strong> of Model A <em>might</em> be useful, or they might be too specific. You need to decide how many of these to reuse.</li></ul></li><li><strong>Train Model B:</strong> Train your new model (with the reused lower layers and new/modified upper layers) on your smaller dataset for Task B.</li></ol></li></ul></li><li><p><strong>Preprocessing Input (Bird Icon, page 346):</strong></p><ul><li>If the input data for your new task (Task B) doesn&rsquo;t have the same size/format as the data Model A was trained on, you&rsquo;ll usually need to add a preprocessing step to resize/reformat your new data to match what the pretrained layers expect.</li><li>Transfer learning works best when the inputs for the new task have similar low-level features to the original task.</li></ul></li><li><p><strong>How Many Layers to Reuse? (Page 346 & Snake Icon, page 347):</strong></p><ul><li><strong>The more similar the tasks are, the more layers you can (and probably should) reuse.</strong> For very similar tasks, you might reuse all hidden layers and just replace the output layer.</li><li><strong>Strategy for Fine-Tuning:</strong><ol><li><strong>Freeze Reused Layers Initially:</strong> When you first start training Model B, it&rsquo;s often a good idea to <strong>freeze</strong> the weights of the reused layers (make them non-trainable so Gradient Descent won&rsquo;t modify them).<ul><li><em>Why?</em> Your new output layer (and any new upper hidden layers) will have randomly initialized weights. If you train everything at once, the large error gradients from these random layers could propagate back and wreck the carefully tuned weights of the pretrained lower layers.</li><li>Train the model for a few epochs with the reused layers frozen. This allows the new layers to learn reasonable weights without damaging the pretrained ones.</li></ul></li><li><strong>Unfreeze Some Layers and Fine-Tune:</strong> After the new layers have settled a bit, you can <strong>unfreeze</strong> some or all of the reused layers (typically starting with the upper ones) and continue training. This allows backpropagation to fine-tune these reused weights for your specific new task.<ul><li><strong>Reduce Learning Rate:</strong> When you unfreeze reused layers, it&rsquo;s usually beneficial to use a <em>much smaller learning rate</em>. This is to make only small adjustments to the already good pretrained weights, rather than drastically changing them.</li></ul></li><li><strong>Iterate:</strong> If you still can&rsquo;t get good performance and have little data, try dropping some of the top reused hidden layers and freezing all remaining reused layers again. If you have plenty of training data, you might try replacing the top hidden layers or even adding more new hidden layers on top of the reused ones.</li></ol></li></ul></li><li><p><strong>Transfer Learning with Keras (Page 347-348):</strong>
The book gives an example:</p><ul><li>Model A: Trained on Fashion MNIST for 8 classes (excluding sandal and shirt). Achieved >90% accuracy.</li><li>Task B: Binary classifier for shirt (positive) vs. sandal (negative). Small dataset (200 labeled images).</li><li>Training a new model (same architecture as A) from scratch on Task B gets ~97.2% accuracy. Can transfer learning do better?</li></ul><ol><li><strong>Load Model A and Create Model B:</strong>
<code>model_A = keras.models.load_model("my_model_A.h5")</code>
<code>model_B_on_A = keras.models.Sequential(model_A.layers[:-1]) # Reuse all layers except output</code>
<code>model_B_on_A.add(keras.layers.Dense(1, activation="sigmoid")) # New binary output layer</code></li><li><strong>Cloning (Important!):</strong><ul><li>The code above makes <code>model_B_on_A</code> <em>share</em> layers with <code>model_A</code>. If you train <code>model_B_on_A</code>, it will change the weights in <code>model_A</code> as well!</li><li>To avoid this, <strong>clone</strong> <code>model_A</code> first if you want to keep <code>model_A</code> intact:
<code>model_A_clone = keras.models.clone_model(model_A)</code>
<code>model_A_clone.set_weights(model_A.get_weights())</code>
Then build <code>model_B_on_A</code> using <code>model_A_clone.layers[:-1]</code>.</li></ul></li><li><strong>Freeze Reused Layers:</strong>
<code>for layer in model_B_on_A.layers[:-1]:</code>
<code>layer.trainable = False</code>
<code>model_B_on_A.compile(...)</code> (You <em>must</em> recompile after changing <code>trainable</code> status).</li><li><strong>Train the New Layer(s):</strong>
<code>history = model_B_on_A.fit(X_train_B, y_train_B, epochs=4, ...)</code> (Train for a few epochs).</li><li><strong>Unfreeze and Fine-Tune:</strong>
<code>for layer in model_B_on_A.layers[:-1]:</code>
<code>layer.trainable = True</code>
<code>optimizer = keras.optimizers.SGD(learning_rate=1e-4) # Use a lower learning rate</code>
<code>model_B_on_A.compile(..., optimizer=optimizer, ...)</code>
<code>history = model_B_on_A.fit(X_train_B, y_train_B, epochs=16, ...)</code></li></ol><ul><li><strong>Result:</strong> The example shows the transfer learning model achieved 99.25% accuracy, reducing the error rate from 2.8% (model from scratch) to ~0.7% – a factor of four improvement!</li><li><strong>Caveat (&ldquo;Torturing the Data&rdquo;):</strong> The author admits to &ldquo;cheating&rdquo; a bit by trying many configurations to find one that showed a strong improvement for this specific example. Transfer learning doesn&rsquo;t always give such dramatic gains for small dense networks (they learn few, specific patterns). It works best with <strong>deep convolutional neural networks (CNNs)</strong> which learn more general feature detectors, especially in lower layers. (This will be revisited in Chapter 14).</li></ul></li></ul><p><strong>(Page 349-350: Unsupervised Pretraining)</strong></p><p>What if you want to tackle a complex task, you don&rsquo;t have much <em>labeled</em> data, AND you can&rsquo;t find a pretrained model trained on a similar task?</p><ul><li><strong>The Idea:</strong> If you can gather plenty of <em>unlabeled</em> training data (which is often cheap and easy), you can use it to train an <strong>unsupervised model</strong> first.<ul><li>Examples of unsupervised models: Autoencoders, Generative Adversarial Networks (GANs) (Chapter 17).</li></ul></li><li><strong>The Process (Figure 11-5, page 350):</strong><ol><li>Train an unsupervised model (e.g., an autoencoder) on your large unlabeled dataset.<ul><li><em>What this unsupervised training is trying to achieve:</em> The lower layers of this model will learn to detect useful low-level features and patterns present in your unlabeled data.</li></ul></li><li>Reuse the lower layers of this pretrained unsupervised model.</li><li>Add an output layer suitable for your actual <em>supervised</em> task on top.</li><li>Fine-tune this final network using your small amount of <em>labeled</em> training data.</li></ol></li><li><strong>Historical Significance:</strong> This technique (often with Restricted Boltzmann Machines - RBMs, Appendix E) was crucial for the revival of neural networks and the success of Deep Learning from 2006 until around 2010. After the vanishing gradients problem was better understood and mitigated (with better initializers, activations, etc.), purely supervised training of DNNs became more common when large labeled datasets were available.</li><li><strong>Modern Relevance:</strong> Unsupervised pretraining (now typically using autoencoders or GANs) is still a very good option when:<ul><li>You have a complex task.</li><li>No similar pretrained model is available.</li><li>You have little labeled data but plenty of unlabeled data.</li></ul></li><li><strong>Greedy Layer-Wise Pretraining (Old Technique - Figure 11-5, top part):</strong><ul><li>In the early days, training deep models was very hard. So, people would train one unsupervised layer (e.g., RBM) at a time, freeze it, add another on top, train that new layer, freeze it, and so on.</li><li>Nowadays, things are simpler: people generally train the full unsupervised model (e.g., a deep autoencoder) in one shot (Figure 11-5, starting at step three).</li></ul></li></ul><p><strong>(Page 350-351: Pretraining on an Auxiliary Task)</strong></p><p>One last option if you don&rsquo;t have much labeled data for your main task:</p><ul><li><strong>The Idea:</strong> Find an <strong>auxiliary task</strong> for which you <em>can</em> easily obtain or generate a lot of labeled training data.</li><li>Train a first neural network on this auxiliary task.</li><li>Reuse the lower layers of this network (which learned feature detectors relevant to the auxiliary task) for your actual main task.</li><li><em>What this is ultimately trying to achieve:</em> Hope that the features learned for the auxiliary task are also somewhat relevant and useful for your main task.</li><li><strong>Examples:</strong><ul><li><strong>Face Recognition:</strong> If you have few pictures of each specific person you want to recognize (main task), you could first gather lots of pictures of random people from the web and train a network to detect whether <em>two different pictures feature the same person</em> (auxiliary task – a &ldquo;Siamese network&rdquo; setup). This network would learn good general face feature detectors.</li><li><strong>Natural Language Processing (NLP):</strong> Download millions of text documents. Automatically generate labeled data by, for example, randomly masking out some words and training a model to predict the missing words (this is a form of <strong>self-supervised learning</strong>). A model that performs well on this task (like BERT or GPT) learns a lot about language structure. Its lower layers can then be reused and fine-tuned for a specific NLP task (like sentiment analysis) for which you might have less labeled data. (More in Chapter 15).</li></ul></li><li><strong>Self-Supervised Learning (Bird Icon, page 351):</strong> When you automatically generate labels from the data itself (like masking words), it&rsquo;s called self-supervised learning. Since no human labeling is needed, it&rsquo;s often classified as a form of unsupervised learning.</li></ul><p><strong>Key Takeaway for Reusing Layers/Pretraining:</strong>
These techniques are all about <strong>leveraging knowledge learned from one task/dataset to help with another</strong>, especially when labeled data for the target task is scarce.</p><ul><li><strong>Transfer Learning:</strong> Reuse layers from a model trained on a similar supervised task.</li><li><strong>Unsupervised Pretraining:</strong> Train on unlabeled data first to learn general features, then fine-tune for a supervised task.</li><li><strong>Pretraining on an Auxiliary Task:</strong> Train on a related task where labeled data is abundant, then transfer.</li></ul><p>These are powerful strategies to build effective deep learning models more efficiently.</p><hr><h2 id=faster-optimizers>Faster Optimizers</h2><p>The book states, &ldquo;Training a very large deep neural network can be painfully slow.&rdquo; So far, we&rsquo;ve seen four ways to speed up training (and potentially reach a better solution):</p><ol><li>Applying a good <strong>initialization strategy</strong> for connection weights (Glorot, He).</li><li>Using a good <strong>activation function</strong> (ReLU, ELU, SELU).</li><li>Using <strong>Batch Normalization</strong>.</li><li><strong>Reusing parts of a pretrained network</strong> (transfer learning).</li></ol><p>Another huge speed boost comes from using a <strong>faster optimizer</strong> than the regular (Mini-batch) Gradient Descent optimizer we&rsquo;ve mostly considered so far. This section presents the most popular advanced optimization algorithms.</p><p><em>What all these faster optimizers are ultimately trying to achieve:</em> They aim to converge to a good solution more quickly than standard Gradient Descent by being smarter about the direction and size of the steps taken in the parameter space to minimize the loss function. They often do this by incorporating information about past gradients or by adapting the learning rate for different parameters.*</p><ol><li><p><strong>Momentum Optimization (Page 351-352):</strong></p><ul><li>Proposed by Boris Polyak in 1964.</li><li><strong>Analogy:</strong> Imagine a bowling ball rolling down a gentle slope. It starts slowly but picks up momentum and reaches a terminal velocity. Regular Gradient Descent (GD) just takes small, regular steps, like someone carefully walking down.</li><li><strong>Core Idea:</strong> Momentum optimization cares a great deal about <em>previous gradients</em>.<ul><li>At each iteration, it subtracts the current local gradient from a <strong>momentum vector <code>m</code></strong>.</li><li>It then updates the weights <code>θ</code> by adding this momentum vector <code>m</code>.</li><li>The gradient is used for <em>acceleration</em>, not directly for speed.</li></ul></li><li><strong>Friction Mechanism:</strong> To prevent momentum from growing too large, a hyperparameter <code>β</code> (beta), called the <strong>momentum</strong>, is introduced (between 0 for high friction and 1 for no friction). A typical value is 0.9.</li><li><strong>Equation 11-4: Momentum algorithm</strong><ol><li><code>m ← βm - η∇_θJ(θ)</code> (Update momentum vector: previous momentum is decayed by <code>β</code>, and then the current negative gradient scaled by learning rate <code>η</code> is added/subtracted).</li><li><code>θ ← θ + m</code> (Update parameters using the momentum vector).</li></ol></li><li><strong>Benefits:</strong><ul><li><strong>Faster Convergence:</strong> If the gradient remains constant, the terminal velocity (max update size) is <code>η * gradient / (1-β)</code>. If <code>β=0.9</code>, this is 10 times faster than standard GD!</li><li><strong>Escapes Plateaus Faster:</strong> Standard GD moves very slowly on flat regions. Momentum helps &ldquo;roll&rdquo; through them.</li><li><strong>Helps with Elongated Bowls:</strong> In cost functions that look like elongated bowls (common when input features have different scales and no Batch Norm), GD goes down the steep slope quickly but then slowly navigates the valley. Momentum helps roll down the valley faster.</li><li><strong>Can Roll Past Local Optima:</strong> The momentum can sometimes carry the optimization past small local optima.</li></ul></li><li><strong>Drawback (Bird Icon, page 352):</strong><ul><li>May overshoot the minimum, then come back, oscillate a few times before stabilizing. The friction <code>β</code> helps dampen these oscillations.</li><li>Adds another hyperparameter (<code>β</code>) to tune (though 0.9 often works well).</li></ul></li><li><strong>Keras Implementation:</strong> Use the <code>SGD</code> optimizer and set its <code>momentum</code> hyperparameter:
<code>optimizer = keras.optimizers.SGD(learning_rate=0.001, momentum=0.9)</code></li></ul></li><li><p><strong>Nesterov Accelerated Gradient (NAG) (Page 353):</strong></p><ul><li>Proposed by Yurii Nesterov in 1983. Almost always faster than vanilla momentum optimization.</li><li><strong>Core Idea:</strong> Instead of calculating the gradient at the current position <code>θ</code> (like vanilla momentum), NAG calculates the gradient slightly <em>ahead</em> in the direction of the momentum, at <code>θ + βm</code>.</li><li><strong>Equation 11-5: Nesterov Accelerated Gradient algorithm</strong><ol><li><code>m ← βm - η∇_θJ(θ + βm)</code> (Calculate gradient at the &ldquo;look-ahead&rdquo; position).</li><li><code>θ ← θ + m</code></li></ol></li><li><strong>Why it&rsquo;s better (Figure 11-6):</strong><figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-6.png alt="Figure 11-6. Regular versus Nesterov momentum optimization: the former applies the gradients computed before the momentum step, while the latter applies the gradients computed after" width=700></figure><ul><li>The momentum vector <code>m</code> generally points towards the optimum. So, the gradient measured slightly ahead in that direction (<code>∇₂</code> in the figure) is a more accurate estimate of the &ldquo;true&rdquo; gradient towards the optimum than the gradient at the original position (<code>∇₁</code>).</li><li>When momentum pushes weights across a valley, <code>∇₁</code> (original gradient) might continue to push it further across. <code>∇₂</code> (look-ahead gradient) will start to push back towards the bottom of the valley sooner. This helps reduce oscillations and converge faster.</li></ul></li><li><strong>Keras Implementation:</strong> Set <code>nesterov=True</code> in the <code>SGD</code> optimizer:
<code>optimizer = keras.optimizers.SGD(learning_rate=0.001, momentum=0.9, nesterov=True)</code></li></ul></li><li><p><strong>AdaGrad (Adaptive Gradient Algorithm) (Page 354-355):</strong></p><ul><li>Addresses the &ldquo;elongated bowl&rdquo; problem differently. GD goes down steep slopes quickly but then slows down in gentle-sloped valleys. AdaGrad tries to correct its direction earlier to point more towards the global optimum.</li><li><strong>Core Idea:</strong> It scales down the gradient vector along the steepest dimensions (i.e., it &ldquo;dampens&rdquo; movement in directions where the gradient has been consistently large). This is an <strong>adaptive learning rate</strong> method – different learning rates for different parameters.</li><li><strong>Equation 11-6: AdaGrad algorithm</strong><ol><li><code>s ← s + ∇_θJ(θ) ⊗ ∇_θJ(θ)</code> (Accumulate the <em>square</em> of the gradients into vector <code>s</code>. <code>⊗</code> is element-wise multiplication. So <code>sᵢ ← sᵢ + (∂J/∂θᵢ)²</code>).</li><li><code>θ ← θ - η ∇_θJ(θ) ⊘ sqrt(s + ε)</code> (<code>⊘</code> is element-wise division, <code>ε</code> is a small smoothing term to avoid division by zero).</li></ol></li><li><strong>How it works:</strong><ul><li>If the cost function is steep along dimension <code>i</code>, <code>(∂J/∂θᵢ)²</code> will be large, so <code>sᵢ</code> will accumulate quickly.</li><li>In step 2, the update for <code>θᵢ</code> is divided by <code>sqrt(sᵢ + ε)</code>. If <code>sᵢ</code> is large, this division scales down the learning rate specifically for <code>θᵢ</code>.</li><li>So, learning rate decays faster for steep dimensions and slower for dimensions with gentler slopes.</li></ul></li><li><strong>Benefits (Figure 11-7):</strong> Points updates more directly towards the global optimum. Requires less tuning of the learning rate <code>η</code>.<figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-7.png alt="Figure 11-7. AdaGrad versus Gradient Descent: the former can correct its direction earlier to point to the optimum" width=700></figure></li><li><strong>Drawback:</strong> Often stops too early when training neural networks. The learning rate gets scaled down so much (as <code>s</code> keeps accumulating) that the algorithm halts before reaching the global optimum.</li><li><strong>Keras:</strong> <code>keras.optimizers.Adagrad()</code>. Not recommended for deep neural networks due to premature stopping, but understanding it helps with RMSProp and Adam.</li></ul></li><li><p><strong>RMSProp (Root Mean Square Propagation) (Page 355-356):</strong></p><ul><li>Addresses AdaGrad&rsquo;s problem of stopping too early.</li><li><strong>Core Idea:</strong> Instead of accumulating <em>all</em> past squared gradients in <code>s</code>, RMSProp accumulates only the gradients from the <em>most recent iterations</em> by using an <strong>exponential decay</strong> in the first step.</li><li><strong>Equation 11-7: RMSProp algorithm</strong><ol><li><code>s ← βs + (1-β)∇_θJ(θ) ⊗ ∇_θJ(θ)</code> (Exponentially decaying average of squared gradients. <code>β</code> is a decay rate, e.g., 0.9).</li><li><code>θ ← θ - η ∇_θJ(θ) ⊘ sqrt(s + ε)</code> (Same update rule as AdaGrad, using the new <code>s</code>).</li></ol></li><li>The decay rate <code>β</code> (typically 0.9) is a new hyperparameter, but the default often works well.</li><li><strong>Performance:</strong> Almost always performs much better than AdaGrad. It was a preferred optimizer until Adam came along.</li><li><strong>Keras:</strong> <code>keras.optimizers.RMSprop(learning_rate=0.001, rho=0.9)</code> (where <code>rho</code> corresponds to <code>β</code>).</li></ul></li><li><p><strong>Adam (Adaptive Moment Estimation) and Nadam (Page 356-358):</strong></p><ul><li><p><strong>Adam (Kingma & Ba, 2014 - Footnote 17):</strong> Combines the ideas of <strong>Momentum optimization</strong> and <strong>RMSProp</strong>.</p><ul><li>Keeps an exponentially decaying average of <em>past gradients</em> (like momentum, this is the &ldquo;first moment,&rdquo; <code>m</code>).</li><li>Keeps an exponentially decaying average of <em>past squared gradients</em> (like RMSProp, this is the &ldquo;second moment,&rdquo; <code>s</code>).</li></ul></li><li><p><strong>Equation 11-8: Adam algorithm</strong></p><ol><li><code>m ← β₁m + (1-β₁)∇_θJ(θ)</code> (Update biased first moment estimate)</li><li><code>s ← β₂s + (1-β₂)∇_θJ(θ) ⊗ ∇_θJ(θ)</code> (Update biased second moment estimate)</li><li><code>m̂ ← m / (1 - β₁ᵗ)</code> (Bias-corrected first moment estimate, <code>t</code> is iteration number)</li><li><code>ŝ ← s / (1 - β₂ᵗ)</code> (Bias-corrected second moment estimate)</li><li><code>θ ← θ - η m̂ ⊘ (sqrt(ŝ) + ε)</code> (Update parameters)</li></ol></li><li><p>Steps 3 & 4 are technical details to correct for the fact that <code>m</code> and <code>s</code> are initialized at 0 and would be biased towards 0 early in training.</p></li><li><p><strong>Hyperparameters:</strong></p><ul><li><code>η</code> (learning rate): Typically 0.001.</li><li><code>β₁</code> (momentum decay): Typically 0.9.</li><li><code>β₂</code> (scaling decay for squared gradients): Typically 0.999.</li><li><code>ε</code> (smoothing term): Typically 10⁻⁷.</li></ul></li><li><p><strong>Performance:</strong> Adam is an adaptive learning rate algorithm, so it often requires less tuning of the learning rate <code>η</code>. Often very easy to use and a good default.</p></li><li><p><strong>Keras:</strong> <code>keras.optimizers.Adam(learning_rate=0.001, beta_1=0.9, beta_2=0.999)</code></p></li><li><p><strong>AdaMax (Variant of Adam - Page 357):</strong></p><ul><li>Instead of using the ℓ₂ norm (square root of sum of squares) of time-decayed gradients to scale updates (like Adam effectively does via <code>sqrt(ŝ)</code>), AdaMax uses the ℓ∞ norm (the maximum value).</li><li>Can be more stable than Adam in some cases, but Adam generally performs better.</li></ul></li><li><p><strong>Nadam (Page 358):</strong></p><ul><li>Adam optimization + Nesterov trick (calculates gradient using the &ldquo;look-ahead&rdquo; momentum <code>m̂</code>).</li><li>Often converges slightly faster than Adam.</li><li>Timothy Dozat&rsquo;s report (footnote 19) found Nadam generally outperforms Adam but can sometimes be outperformed by RMSProp.</li></ul></li><li><p><strong>Caveat for Adaptive Optimizers (Scorpion Icon, page 358):</strong></p><ul><li>Adaptive methods (RMSProp, Adam, Nadam) are often great and converge fast.</li><li>However, a 2017 paper (Wilson et al. - footnote 20) showed they can generalize <em>poorly</em> on some datasets compared to simpler methods like SGD with Nesterov momentum.</li><li><strong>Practical Advice:</strong> If disappointed by your model&rsquo;s performance with an adaptive optimizer, try plain Nesterov Accelerated Gradient. Your dataset might be &ldquo;allergic&rdquo; to adaptive gradients. Research is ongoing and moving fast.</li></ul></li></ul></li></ol><ul><li><p><strong>Second-Order Partial Derivatives (Hessians - Page 358):</strong></p><ul><li>All optimizers discussed so far use first-order partial derivatives (Jacobians/gradients).</li><li>Optimization literature also has algorithms using second-order partial derivatives (Hessians – derivatives of the gradients).</li><li>These are very hard to apply to DNNs because the number of Hessians is huge (<code>n²</code> per output, where <code>n</code> is number of parameters), so they often don&rsquo;t fit in memory, and computing them is too slow.</li></ul></li><li><p><strong>Training Sparse Models (Sidebar, page 359):</strong></p><ul><li>If you need a fast model at runtime or one that uses less memory, you might want a <strong>sparse model</strong> (most parameters are zero).</li><li>Optimizers discussed produce dense models.</li><li><strong>Achieving sparsity:</strong><ol><li>Train as usual, then set tiny weights to zero (pruning). Often doesn&rsquo;t lead to very sparse models and can degrade performance.</li><li>Apply strong <strong>ℓ₁ regularization</strong> during training (pushes optimizer to zero out weights, like Lasso).</li><li>Use tools like <strong>TensorFlow Model Optimization Toolkit (TF-MOT)</strong>, which has pruning APIs.</li></ol></li></ul></li><li><p><strong>Table 11-2: Optimizer Comparison (Page 359):</strong>
A nice summary table rating convergence speed and quality for SGD, SGD with momentum, Adagrad, RMSProp, Adam, Nadam, AdaMax.</p><ul><li><strong>SGD:</strong> Slow, but can reach good quality.</li><li><strong>Momentum/NAG:</strong> Faster convergence, good quality.</li><li><strong>Adagrad:</strong> Fast convergence, but often stops too early (poor quality for DNNs).</li><li><strong>RMSProp, Adam, Nadam, AdaMax:</strong> Generally fast convergence and good quality. Adam/Nadam are often excellent starting points.</li></ul></li></ul><p><strong>Key Takeaway for Faster Optimizers:</strong>
Standard Gradient Descent can be slow. Advanced optimizers use techniques like momentum, adaptive learning rates per parameter, or a combination, to navigate the loss landscape more efficiently and converge faster to a good solution. Adam or Nadam are often good defaults, but if they don&rsquo;t generalize well, try SGD with Nesterov momentum.</p><p>This section provides a fantastic toolkit of optimizers beyond basic SGD. They are essential for training deep networks in a reasonable amount of time.</p><p>Alright, let&rsquo;s keep the momentum going! We&rsquo;ve covered optimizers that try to take smarter <em>steps</em>. Now, let&rsquo;s talk about how to adjust the <em>size</em> of those steps during training: <strong>Learning Rate Scheduling</strong> (Pages 359-363).</p><hr><h2 id=learning-rate-scheduling---the-why-and-how>Learning Rate Scheduling - The Why and How</h2><p>We know that finding a good learning rate <code>η</code> is crucial:</p><ul><li><p><strong>Too high:</strong> Training may diverge (loss explodes).</p></li><li><p><strong>Too low:</strong> Training converges eventually, but takes a very long time.</p></li><li><p><strong>Slightly too high:</strong> May make quick initial progress but then dance around the optimum, never settling. (See Figure 11-8).<figure><img src=/bookshelf/hands-on-ml/ch-11-fig-11-8.png alt="Figure 11-8. Learning curves for various learning rates η" width=700></figure></p></li><li><p><strong>Finding a Good Constant Learning Rate (Recap from Chapter 10):</strong></p><ul><li>Train for a few hundred iterations, starting with a very small <code>η</code> and exponentially increasing it.</li><li>Plot loss vs. <code>η</code> (log scale for <code>η</code>).</li><li>Pick a learning rate slightly lower than where the loss starts shooting back up.</li><li>Reinitialize and train with this constant <code>η</code>.</li></ul></li><li><p><strong>Doing Better Than a Constant Learning Rate:</strong></p><ul><li>If you start with a large learning rate and then <em>reduce it</em> once training stops making fast progress, you can often reach a good solution <em>faster</em> than with the single best constant learning rate.</li><li>These strategies to reduce the learning rate during training are called <strong>learning schedules</strong>.</li><li>It can also be beneficial to start with a low learning rate, increase it (warm-up), then drop it again.</li></ul></li></ul><p><em>What learning rate scheduling is ultimately trying to achieve:</em> To speed up convergence and potentially reach a better final solution by dynamically adjusting the step size of the optimizer during training. Large steps early on can help navigate flat regions or escape poor local minima quickly, while smaller steps later can help fine-tune the solution around the optimum.*</p><p><strong>Commonly Used Learning Schedules (Page 360-361):</strong></p><ol><li><p><strong>Power Scheduling:</strong></p><ul><li><code>η(t) = η₀ / (1 + t/s)ᶜ</code><ul><li><code>t</code>: Iteration number.</li><li><code>η₀</code>: Initial learning rate.</li><li><code>s</code>: A hyperparameter determining how many steps it takes for <code>η</code> to drop significantly.</li><li><code>c</code>: Power (typically set to 1).</li></ul></li><li><strong>Behavior:</strong> Learning rate drops at each step. After <code>s</code> steps, <code>η ≈ η₀ / 2</code>. After another <code>s</code> steps, <code>η ≈ η₀ / 3</code>, then <code>η₀ / 4</code>, etc.</li><li>Drops quickly at first, then more and more slowly.</li><li>Requires tuning <code>η₀</code> and <code>s</code> (and possibly <code>c</code>).</li><li><strong>Keras Implementation (Easiest - Page 362):</strong> Set the <code>decay</code> hyperparameter when creating an <code>SGD</code> optimizer. <code>decay</code> is the inverse of <code>s</code> (and <code>c</code> is assumed to be 1).
<code>optimizer = keras.optimizers.SGD(learning_rate=0.01, decay=1e-4)</code>
(This means <code>s = 1 / 1e-4 = 10000</code>. So after 10000 steps, <code>η</code> will be roughly <code>0.01/2</code>).</li></ul></li><li><p><strong>Exponential Scheduling:</strong></p><ul><li><code>η(t) = η₀ * 0.1^(t/s)</code></li><li><strong>Behavior:</strong> Learning rate drops by a factor of 10 every <code>s</code> steps.</li><li>More aggressive reduction than power scheduling (keeps slashing by a constant factor).</li><li><strong>Keras Implementation (Page 362):</strong><ul><li>Define a function that takes the current epoch and returns the learning rate:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>exponential_decay_fn</span>(epoch):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.01</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span><span style=color:#f92672>**</span>(epoch <span style=color:#f92672>/</span> <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Or a configurable one:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># def exponential_decay(lr0, s):</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     def exponential_decay_fn(epoch):</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#         return lr0 * 0.1**(epoch / s)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     return exponential_decay_fn</span>
</span></span><span style=display:flex><span><span style=color:#75715e># exponential_decay_fn = exponential_decay(lr0=0.01, s=20)</span>
</span></span></code></pre></div></li><li>Create a <code>LearningRateScheduler</code> callback and pass it to <code>fit()</code>:
<code>lr_scheduler = keras.callbacks.LearningRateScheduler(exponential_decay_fn)</code>
<code>history = model.fit(..., callbacks=[lr_scheduler])</code></li><li>This updates <code>η</code> at the <em>beginning of each epoch</em>.</li><li>If you want updates at every <em>step</em> (more frequent), you can write a custom callback.</li><li>The schedule function can optionally take the current <code>lr</code> as a second argument if it needs to know the previous learning rate.</li><li><strong>Important if using epoch in schedule function:</strong> If you save and then continue training, the <code>epoch</code> argument resets to 0. You might need to set <code>fit()</code>&rsquo;s <code>initial_epoch</code> argument to avoid this.</li></ul></li></ul></li><li><p><strong>Piecewise Constant Scheduling:</strong></p><ul><li>Use a constant <code>η₀</code> for <code>e₀</code> epochs, then a smaller <code>η₁</code> for <code>e₁</code> epochs, and so on.</li><li>Can work very well but requires fiddling to find the right sequence of rates and durations.</li><li><strong>Keras Implementation (Page 363):</strong> Use a schedule function with <code>LearningRateScheduler</code> callback, similar to exponential scheduling:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>piecewise_constant_fn</span>(epoch):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> epoch <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.01</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> epoch <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>15</span>: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.005</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.001</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>Performance Scheduling:</strong></p><ul><li>Measure validation error every <code>N</code> steps (like early stopping).</li><li>Reduce <code>η</code> by a factor <code>λ</code> when the error stops dropping.</li><li><strong>Keras Implementation (Page 363):</strong> Use the <code>ReduceLROnPlateau</code> callback.
<code>lr_scheduler = keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=5)</code><ul><li>This will multiply <code>η</code> by 0.5 whenever the best validation loss does not improve for 5 consecutive epochs.</li></ul></li></ul></li><li><p><strong>1cycle Scheduling (Leslie Smith, 2018 - Footnote 21, Page 361):</strong>
A more recent and often very effective schedule.</p><ul><li><strong>Behavior:</strong><ol><li>Start with an initial learning rate <code>η₀</code>.</li><li>Linearly <em>increase</em> <code>η</code> up to a maximum <code>η₁</code> about halfway through training.</li><li>Linearly <em>decrease</em> <code>η</code> back down to <code>η₀</code> during the second half.</li><li>In the last few epochs, drop <code>η</code> by several orders of magnitude (still linearly).</li></ol></li><li><code>η₁</code> (max rate) is chosen using the &ldquo;find optimal LR&rdquo; method (like in Chapter 10). <code>η₀</code> is often set ~10x lower.</li><li><strong>Momentum with 1cycle:</strong> Often, momentum is also varied: start high (e.g., 0.95), drop to lower (e.g., 0.85) during first half, then back up to high (0.95) for second half.</li><li><strong>Benefits:</strong> Smith showed this can significantly speed up training and achieve better performance. (e.g., CIFAR10: 91.9% accuracy in 100 epochs vs. 90.3% in 800 epochs with standard approach).</li><li><strong>Keras Implementation (Page 364):</strong> Requires a custom callback to modify <code>self.model.optimizer.learning_rate</code> (or <code>.lr</code> for older Keras/TF) at each iteration.</li></ul></li></ol><ul><li><strong>tf.keras Schedulers (Page 363):</strong><ul><li><code>tf.keras</code> (but not the standalone Keras API) offers an alternative: define <code>learning_rate</code> using schedules from <code>keras.optimizers.schedules</code>.</li><li>Example: <code>keras.optimizers.schedules.ExponentialDecay(0.01, s, 0.1)</code> (where <code>s</code> is number of steps for decay).</li><li>Pass this <code>learning_rate</code> object directly to an optimizer: <code>optimizer = keras.optimizers.SGD(learning_rate=learning_rate_schedule_object)</code>.</li><li><strong>Advantage:</strong> Updates <code>η</code> at <em>each step</em> (not just epoch). The schedule state is saved with the model.</li></ul></li></ul><p><strong>Summary (Page 364):</strong>
Exponential decay, performance scheduling, and 1cycle can considerably speed up convergence. They are worth trying!</p><p><strong>Key Takeaway for Learning Rate Scheduling:</strong>
A constant learning rate is often suboptimal. Dynamically adjusting the learning rate during training—starting larger for faster initial progress and exploration, then reducing it for finer convergence—can lead to faster training and better final models. Many schedules exist, with 1cycle being a particularly promising recent one.</p><p>Great! It&rsquo;s good that the concept of dynamically adjusting the learning rate makes sense – it&rsquo;s a very practical and effective way to improve training.</p><p>Now, let&rsquo;s shift our focus from <em>speeding up training</em> and <em>stabilizing gradients</em> to another critical challenge in deep learning: <strong>Avoiding Overfitting Through Regularization</strong> (Pages 364-371).</p><hr><h2 id=avoiding-overfitting-through-regularization---introduction>Avoiding Overfitting Through Regularization - Introduction</h2><p>The chapter opens with a famous quote often attributed to John von Neumann: &ldquo;With four parameters I can fit an elephant and with five I can make him wiggle his trunk.&rdquo;</p><ul><li><strong>The Problem with Deep Neural Networks:</strong> They typically have <em>tens of thousands</em>, sometimes <em>millions</em>, of parameters. This gives them incredible flexibility to fit a huge variety of complex datasets.</li><li><strong>The Downside of Flexibility:</strong> This same flexibility makes them very prone to <strong>overfitting</strong> the training set, especially if the amount of training data isn&rsquo;t proportionally massive or if the data is noisy. The model might learn the noise and specific quirks of the training data instead of the underlying generalizable patterns.</li></ul><p>We <em>need</em> regularization.</p><ul><li><strong>Techniques Already Covered:</strong><ul><li><strong>Early Stopping (Chapter 10):</strong> A very effective regularization technique.</li><li><strong>Batch Normalization:</strong> While designed to solve unstable gradients, it also acts as a pretty good regularizer (due to the slight noise from mini-batch statistics).</li></ul></li></ul><p>This section will explore other popular regularization techniques specifically for neural networks:</p><ul><li>ℓ₁ and ℓ₂ regularization (which we saw for linear models in Chapter 4).</li><li>Dropout.</li><li>Max-norm regularization.</li></ul><p><em>What all these regularization techniques are ultimately trying to achieve:</em> To constrain the learning algorithm in some way to prevent it from fitting the training data <em>too</em> perfectly, thereby improving its ability to generalize to new, unseen data.*</p><p><strong>(Page 364-365: ℓ₁ and ℓ₂ Regularization)</strong></p><p>These are familiar from linear models and can be applied to neural network connection weights.</p><ul><li><p><strong>ℓ₂ Regularization (Weight Decay):</strong></p><ul><li><strong>How it works:</strong> Adds a penalty term to the loss function proportional to the sum of the squares of the connection weights (usually excluding biases). For a Keras layer, you&rsquo;d apply it to the <code>kernel</code> (weights).
<code>J_regularized(W,b) = J_original(W,b) + λ * (1/2) * Σ w²</code></li><li><em>What it&rsquo;s ultimately trying to achieve:</em> It encourages the network to learn smaller weights. Smaller weights generally lead to simpler, smoother functions that are less likely to overfit by fitting the noise in the training data. It &ldquo;decays&rdquo; the weights towards zero unless the data strongly justifies a larger weight.</li><li><strong>Keras Implementation:</strong>
<code>layer = keras.layers.Dense(100, activation="elu",</code>
<code>kernel_initializer="he_normal",</code>
<code>kernel_regularizer=keras.regularizers.l2(0.01))</code><ul><li><code>keras.regularizers.l2(0.01)</code> creates a regularizer object with a regularization factor (lambda <code>λ</code>) of 0.01.</li><li>This regularizer is called at each step during training to compute the regularization loss, which is then added to the main loss.</li></ul></li></ul></li><li><p><strong>ℓ₁ Regularization:</strong></p><ul><li><strong>How it works:</strong> Adds a penalty term proportional to the sum of the absolute values of the weights.
<code>J_regularized(W,b) = J_original(W,b) + λ * Σ |w|</code></li><li><em>What it&rsquo;s ultimately trying to achieve:</em> It also encourages smaller weights, but it has the added property of tending to drive many weights to <em>exactly zero</em>. This results in a <strong>sparse model</strong> (many connections are effectively removed). This can be useful for feature selection or creating more compact models.</li><li><strong>Keras Implementation:</strong> Use <code>keras.regularizers.l1(0.01)</code>.</li></ul></li><li><p><strong>ℓ₁ and ℓ₂ Regularization (Elastic Net):</strong></p><ul><li>You can use both simultaneously with <code>keras.regularizers.l1_l2(l1=0.01, l2=0.01)</code>.</li></ul></li><li><p><strong>Applying to Multiple Layers (Page 365):</strong></p><ul><li>You typically want to apply the same regularizer, activation function, and initialization strategy to all hidden layers. Repeating these arguments makes code ugly and error-prone.</li><li><strong>Solution:</strong> Use Python&rsquo;s <code>functools.partial()</code> to create a &ldquo;pre-configured&rdquo; layer type:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> partial
</span></span><span style=display:flex><span>RegularizedDense <span style=color:#f92672>=</span> partial(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense,
</span></span><span style=display:flex><span>                           activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>,
</span></span><span style=display:flex><span>                           kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>,
</span></span><span style=display:flex><span>                           kernel_regularizer<span style=color:#f92672>=</span>keras<span style=color:#f92672>.</span>regularizers<span style=color:#f92672>.</span>l2(<span style=color:#ae81ff>0.01</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>model <span style=color:#f92672>=</span> keras<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Flatten(input_shape<span style=color:#f92672>=</span>[<span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>28</span>]),
</span></span><span style=display:flex><span>    RegularizedDense(<span style=color:#ae81ff>300</span>),
</span></span><span style=display:flex><span>    RegularizedDense(<span style=color:#ae81ff>100</span>),
</span></span><span style=display:flex><span>    RegularizedDense(<span style=color:#ae81ff>10</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;softmax&#34;</span>, <span style=color:#75715e># Override for output</span>
</span></span><span style=display:flex><span>                     kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;glorot_uniform&#34;</span>) <span style=color:#75715e># Override for output</span>
</span></span><span style=display:flex><span>])
</span></span></code></pre></div></li><li>This makes the code cleaner and easier to manage.</li></ul></li></ul><h2 id=dropout>Dropout</h2><p>This is one of the most popular and effective regularization techniques for deep neural networks.</p><ul><li><p>Proposed by Geoffrey Hinton et al. (2012) and detailed by Srivastava et al. (2014).</p></li><li><p>Even state-of-the-art networks often get a 1-2% accuracy boost from adding dropout. This is significant when accuracy is already high (e.g., 95% -> 97% is a 40% reduction in error rate).</p></li><li><p><strong>The Algorithm (Fairly Simple - Figure 11-9, page 366):</strong></p><ol><li>At <strong>every training step</strong>:<ul><li>Every neuron (including input neurons, but <em>always excluding output neurons</em>) has a probability <code>p</code> (the <strong>dropout rate</strong>) of being temporarily &ldquo;dropped out.&rdquo;</li><li>&ldquo;Dropped out&rdquo; means the neuron is entirely ignored during this training step – it doesn&rsquo;t produce any output (or its output is considered to be 0).</li><li>This means for each training step, a different, thinned version of the network is effectively being trained.</li></ul></li><li><strong>After training (at test/inference time):</strong><ul><li>Neurons are <strong>no longer dropped</strong>. All neurons are active.</li></ul></li></ol><ul><li><strong>Typical Dropout Rate <code>p</code>:</strong> Between 10% and 50%.<ul><li>20-30% for Recurrent Neural Networks.</li><li>40-50% for Convolutional Neural Networks.</li></ul></li></ul></li><li><p><strong>Why Does This Destructive Technique Work? (Page 366):</strong>
It&rsquo;s surprising at first!</p><ol><li><strong>Forces Neurons to Be More Robust:</strong><ul><li>Neurons trained with dropout cannot co-adapt too much with their neighboring neurons (because those neighbors might be dropped out at any time).</li><li>Each neuron has to learn to be as useful as possible <em>on its own</em>.</li><li>They cannot rely excessively on just a few input neurons (as those inputs might be dropped). They must pay attention to each of their inputs more broadly.</li><li>This makes them less sensitive to slight changes in the inputs.</li><li>The result is a more robust network that generalizes better.</li></ul></li><li><strong>Ensemble of Smaller Networks:</strong><ul><li>Another way to understand dropout is to realize that at each training step, a unique neural network architecture is generated (since each neuron can be present or absent).</li><li>With <code>N</code> droppable neurons, there are <code>2^N</code> possible networks – a huge number!</li><li>After, say, 10,000 training steps, you&rsquo;ve essentially trained 10,000 different (though overlapping, as they share weights) neural networks, each on a single training instance (or batch).</li><li>The resulting final network (used at test time with no dropout) can be seen as an <strong>averaging ensemble</strong> of all these thinned networks.</li></ul></li></ol></li><li><p><strong>Important Technical Detail (Scaling - Page 367):</strong></p><ul><li>Suppose <code>p = 50%</code> (dropout rate). During training, a neuron is connected (on average) to half as many input neurons as it will be during testing (when no neurons are dropped).</li><li>To compensate for this, so that the total input signal to a neuron at test time is roughly the same scale as it was during training, we need to adjust. Two ways:<ol><li>Multiply each neuron&rsquo;s input connection weights by the <strong>keep probability (1-p)</strong> <em>after training</em>.</li><li><strong>Or (more commonly):</strong> Divide each neuron&rsquo;s output by the <strong>keep probability (1-p)</strong> <em>during training</em> (only for the neurons that were not dropped).</li></ol></li><li>Keras (and most libraries) use the second method.</li></ul></li><li><p><strong>Implementing Dropout in Keras (Page 367):</strong></p><ul><li>Use the <code>keras.layers.Dropout</code> layer.</li><li>During training, it randomly drops some inputs (sets them to 0) and scales the remaining inputs by <code>1 / (1 - rate)</code>.</li><li>After training (during inference), it does nothing; it just passes the inputs through.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>model <span style=color:#f92672>=</span> keras<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Flatten(input_shape<span style=color:#f92672>=</span>[<span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>28</span>]),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dropout(rate<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>), <span style=color:#75715e># Dropout after flatten</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>300</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dropout(rate<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>), <span style=color:#75715e># Dropout after first hidden</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>100</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>, kernel_initializer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;he_normal&#34;</span>),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dropout(rate<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>), <span style=color:#75715e># Dropout after second hidden</span>
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>10</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;softmax&#34;</span>)
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><ul><li>The bird icon (page 367) mentions you can usually apply dropout only to neurons in the top 1-3 hidden layers (excluding output).</li></ul></li><li><p><strong>Impact on Training/Validation Loss (Scorpion Icon, page 367):</strong></p><ul><li>Since dropout is only active during training, comparing training loss and validation loss directly can be misleading. A model might be overfitting, yet training and validation losses appear similar because training loss is &ldquo;artificially inflated&rdquo; by dropout.</li><li>To get a true sense of training loss, evaluate the model on the training set <em>with dropout turned off</em> (e.g., after training is complete).</li></ul></li><li><p><strong>Tuning Dropout Rate (Page 367):</strong></p><ul><li>If model is overfitting: Increase dropout rate.</li><li>If model is underfitting: Decrease dropout rate.</li><li>Can also use higher rates for large layers, lower for small ones.</li><li>Many state-of-the-art architectures only use dropout <em>after the last hidden layer</em>.</li></ul></li><li><p><strong>Dropout and Convergence Speed (Page 368):</strong></p><ul><li>Dropout tends to significantly slow down convergence. But it usually results in a much better model if tuned properly. It&rsquo;s often worth the extra time.</li></ul></li><li><p><strong>AlphaDropout (Page 368):</strong></p><ul><li>If regularizing a self-normalizing network using SELU activation, use <strong>AlphaDropout</strong>.</li><li>Regular dropout would break self-normalization. AlphaDropout is a variant that preserves the mean and standard deviation of its inputs.</li></ul></li><li><p><strong>Monte Carlo (MC) Dropout (Yarin Gal & Zoubin Ghahramani, 2016 - Page 368-370):</strong>
A powerful technique that gives dropout even more utility.</p><ol><li><strong>Bayesian Connection:</strong> Established a profound link between dropout networks and approximate Bayesian inference, giving dropout a solid mathematical justification.</li><li><strong>MC Dropout Technique:</strong><ul><li>Boosts performance of <em>any trained dropout model</em> without retraining.</li><li>Provides better measures of model <em>uncertainty</em>.</li><li>Simple to implement:<ul><li>To make a prediction for a new instance (or batch), run the instance through the trained model <em>multiple times</em> (e.g., 100 times), but this time, <strong>keep dropout active</strong> (i.e., set <code>training=True</code> when calling the model or its layers).</li><li>Each of these 100 predictions will be slightly different because different neurons are dropped each time.</li><li>Average these 100 predictions to get the final MC Dropout prediction.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Assuming X_test_scaled is your test data</span>
</span></span><span style=display:flex><span>y_probas_mc <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>stack([model(X_test_scaled, training<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>) 
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>for</span> sample <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>)])
</span></span><span style=display:flex><span>y_proba_mc_avg <span style=color:#f92672>=</span> y_probas_mc<span style=color:#f92672>.</span>mean(axis<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>) <span style=color:#75715e># Average over the 100 samples</span>
</span></span></code></pre></div></li><li><em>What MC Dropout is ultimately trying to achieve:</em> By averaging predictions from many slightly different &ldquo;thinned&rdquo; versions of the network (created by active dropout), it&rsquo;s performing a form of ensemble prediction. This often leads to more robust and accurate predictions than a single pass with dropout turned off.</li><li><strong>Uncertainty Estimation:</strong><ul><li>The predictions <code>y_probas_mc</code> will vary across the 100 samples. The average <code>y_proba_mc_avg</code> gives the final probability (e.g., for classification).</li><li>The <strong>standard deviation</strong> of these probabilities across the samples (<code>y_probas_mc.std(axis=0)</code>) gives an estimate of the model&rsquo;s uncertainty for each prediction. If the standard deviation is high, the model is very uncertain.</li><li>This is incredibly useful for risk-sensitive applications (e.g., medical, finance). If the model is 99% confident but has high uncertainty (large std dev from MC Dropout), you should treat the prediction with caution.</li></ul></li><li>The example on page 369 shows a model being 99% sure about an ankle boot with dropout off, but MC Dropout reveals only 62% confidence with significant variance, suggesting hesitation with &ldquo;sandal&rdquo; or &ldquo;sneaker.&rdquo;</li><li>MC Dropout can also give a small accuracy boost.</li></ul></li></ol><ul><li><strong>Using MCDropout class (page 370):</strong> If your model has other layers that behave differently during training (like Batch Normalization), you shouldn&rsquo;t force the whole model into <code>training=True</code> mode for MC Dropout. Instead, you should replace <code>Dropout</code> layers with a custom <code>MCDropout</code> layer that <em>always</em> keeps dropout active.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MCDropout</span>(keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dropout):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>call</span>(self, inputs):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> super()<span style=color:#f92672>.</span>call(inputs, training<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div></li><li>In short: MC Dropout is fantastic for boosting performance and getting uncertainty estimates from already trained dropout models. It acts like a regularizer during training (because it <em>is</em> regular dropout then) and an ensemble/uncertainty tool at inference.</li></ul></li></ul><p><strong>(Page 370-371: Max-Norm Regularization)</strong></p><p>Another regularization technique popular for neural networks.</p><ul><li><strong>The Idea:</strong> For each neuron, constrain the ℓ₂ norm of the vector of its incoming connection weights <code>w</code> such that <code>||w||₂ ≤ r</code>.<ul><li><code>r</code> is the <strong>max-norm hyperparameter</strong>.</li></ul></li><li><strong>How it&rsquo;s Implemented:</strong><ul><li>It does <em>not</em> add a regularization loss term to the overall loss function.</li><li>Instead, after each training step (after weights are updated by the optimizer), it computes <code>||w||₂</code> for each neuron.</li><li>If <code>||w||₂ > r</code>, the weight vector <code>w</code> for that neuron is rescaled: <code>w ← w * (r / ||w||₂)</code>.</li></ul></li><li><em>What max-norm regularization is ultimately trying to achieve:</em> It keeps the incoming weights for each neuron bounded, preventing them from growing too large. This helps reduce overfitting. It can also help alleviate unstable gradients if you&rsquo;re not using Batch Normalization.</li><li>Reducing <code>r</code> increases the amount of regularization.</li><li><strong>Keras Implementation:</strong><ul><li>Set the <code>kernel_constraint</code> argument of a <code>Dense</code> layer (or other weight-bearing layers) to <code>keras.constraints.max_norm(r)</code>.
<code>keras.layers.Dense(..., kernel_constraint=keras.constraints.max_norm(1.0))</code></li><li>After each training iteration, Keras will call this constraint object, which rescales the weights if necessary.</li><li><code>max_norm()</code> has an <code>axis</code> argument (defaults to 0 for <code>Dense</code> layers, meaning it constrains the weights of each neuron&rsquo;s input vector independently). For convolutional layers (Chapter 14), you&rsquo;d set <code>axis</code> appropriately (e.g., ``).</li></ul></li></ul><p>Excellent! We&rsquo;re on the home stretch for Chapter 11. We&rsquo;ve covered the major challenges in training deep neural networks: unstable gradients, lack of data, slow training, and overfitting, along with a powerful toolkit of solutions like smart initializations, non-saturating activations, Batch Normalization, faster optimizers, learning rate scheduling, transfer learning, and regularization techniques like Dropout and Max-Norm.</p><p>Now, let&rsquo;s look at the <strong>Summary and Practical Guidelines</strong> (Pages 371-372) this chapter offers, which attempt to distill all this information into actionable advice.</p><h2 id=summary-and-practical-guidelines>Summary and Practical Guidelines</h2><p>The chapter acknowledges that we&rsquo;ve covered a wide range of techniques, and you might be wondering which ones to use. The answer depends on the specific task, and there&rsquo;s no single clear consensus for every situation. However, the book provides a <strong>default DNN configuration</strong> that it has found to work well in most cases, without requiring excessive hyperparameter tuning.</p><p><strong>Table 11-3: Default DNN Configuration (General Purpose)</strong></p><ul><li><strong>Kernel Initializer:</strong> <strong>He initialization</strong> (This is a good default, especially if using ReLU-family activations).</li><li><strong>Activation Function:</strong> <strong>ELU</strong> (Generally performs well, smoother than ReLU, avoids dying neurons, outputs closer to zero mean).</li><li><strong>Normalization:</strong><ul><li><strong>None if shallow</strong> (few hidden layers).</li><li><strong>Batch Norm if deep</strong>. (BN adds a lot of stability for deeper networks).</li></ul></li><li><strong>Regularization:</strong><ul><li><strong>Early stopping</strong> (Almost always a good idea).</li><li><strong>ℓ₂ regularization</strong> if needed (can add a bit more control over overfitting if early stopping isn&rsquo;t quite enough or if you want to encourage smaller weights generally).</li></ul></li><li><strong>Optimizer:</strong> <strong>Momentum optimization</strong> (e.g., Nesterov) or <strong>RMSProp</strong> or <strong>Nadam/Adam</strong>. (Adam/Nadam are often good starting points due to their adaptive nature, but as noted, plain Nesterov Momentum can sometimes generalize better).</li><li><strong>Learning Rate Schedule:</strong> <strong>1cycle</strong> (This is a strong recommendation from recent research for fast convergence and good performance).</li></ul><p><em>What this default configuration is ultimately trying to achieve:</em> It provides a robust and high-performing starting point for many deep learning tasks. It incorporates solutions for unstable gradients (He init, ELU, BN for deep nets), ways to speed up training (good optimizer, 1cycle LR schedule), and basic regularization (early stopping, optional ℓ₂).</p><p><strong>Table 11-4: DNN Configuration for a Self-Normalizing Net (Page 372)</strong></p><p>If your network architecture meets the specific conditions for self-normalization (a simple stack of dense layers):</p><ul><li><strong>Kernel Initializer:</strong> <strong>LeCun initialization</strong> (Required for SELU).</li><li><strong>Activation Function:</strong> <strong>SELU</strong> (The key to self-normalization).</li><li><strong>Normalization:</strong> <strong>None</strong> (because the network self-normalizes; Batch Norm would interfere).</li><li><strong>Regularization:</strong> <strong>Alpha Dropout</strong> if needed (Regular dropout breaks SELU&rsquo;s self-normalization properties).</li><li><strong>Optimizer:</strong> Momentum optimization (or RMSProp/Nadam).</li><li><strong>Learning Rate Schedule:</strong> <strong>1cycle</strong>.</li></ul><p><em>What this self-normalizing configuration is ultimately trying to achieve:</em> To create a network where the activations in each layer automatically maintain a mean of 0 and standard deviation of 1 throughout training, thus alleviating vanishing/exploding gradients without needing Batch Normalization, and often leading to excellent performance for suitable architectures.</p><p><strong>General Advice (Page 372):</strong></p><ol><li><strong>Normalize Input Features!</strong> Don&rsquo;t forget this crucial preprocessing step.</li><li><strong>Try to Reuse Pretrained Layers (Transfer Learning):</strong> If you can find a network trained on a similar task, reuse its parts.</li><li><strong>Unsupervised Pretraining / Auxiliary Task Pretraining:</strong> Good options if you have lots of unlabeled data (or can generate labeled data for an auxiliary task) but little labeled data for your main task.</li></ol><p><strong>Exceptions and Specific Cases (Page 372):</strong></p><p>While the default guidelines cover most cases, there are exceptions:</p><ul><li><strong>Need a Sparse Model?</strong><ul><li>Use <strong>ℓ₁ regularization</strong> (and optionally zero out tiny weights after training).</li><li>For even sparser models, use <strong>TensorFlow Model Optimization Toolkit (TF-MOT)</strong> for pruning.</li><li>If you use ℓ₁ or TF-MOT, self-normalization (SELU) will likely be broken, so revert to the general default configuration (Table 11-3 with ELU, Batch Norm if deep, etc.).</li></ul></li><li><strong>Need a Low-Latency Model (Lightning-Fast Predictions)?</strong><ul><li>Use <strong>fewer layers</strong>.</li><li><strong>Fold Batch Normalization layers</strong> into the previous Dense layers after training (some tools like TFLite optimizer do this automatically). This removes the BN computation at inference time.</li><li>Possibly use a faster activation function like <strong>Leaky ReLU or just ReLU</strong> (they are computationally cheaper than ELU/SELU).</li><li>Having a sparse model also helps.</li><li>Consider reducing float precision (e.g., 32-bit to 16-bit or even 8-bit) for deployment on mobile/embedded devices (more on this in Chapter 19 under &ldquo;Deploying a Model to a Mobile or Embedded Device&rdquo;). Check out TF-MOT for quantization tools.</li></ul></li><li><strong>Building a Risk-Sensitive Application / Inference Latency Not Critical?</strong><ul><li>Use <strong>MC Dropout</strong> to:<ul><li>Boost performance.</li><li>Get more reliable probability estimates.</li><li>Get uncertainty estimates for predictions.</li></ul></li></ul></li></ul><p><strong>Final Words of the Chapter (Page 372):</strong></p><ul><li>With these guidelines and techniques, you should be ready to train very deep nets.</li><li>Keras provides a lot of power and flexibility.</li><li>However, there might be times when you need even more control (e.g., custom loss functions, tweaking the training algorithm itself). For such cases, you&rsquo;ll need to use TensorFlow&rsquo;s lower-level API, which is the topic of the next chapter (Chapter 12).</li></ul><p><strong>Key Takeaway from the Summary and Guidelines:</strong>
This chapter provides a powerful set of tools and strategies to overcome the main difficulties in training deep neural networks. There&rsquo;s no one-size-fits-all recipe, but the provided default configurations (especially the one in Table 11-3) are excellent starting points. The process often involves experimentation, understanding the trade-offs of different techniques, and iteratively refining your approach based on the specific problem and dataset.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>