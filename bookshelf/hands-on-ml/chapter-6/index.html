<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#introduction-to-decision-trees>Introduction to Decision Trees</a><ul><li><a href=#page-175-176-training-and-visualizing-a-decision-tree>(Page 175-176: Training and Visualizing a Decision Tree)</a></li><li><a href=#page-176-177-making-predictions>(Page 176-177: Making Predictions)</a></li><li><a href=#page-178-decision-boundaries--model-interpretation>(Page 178: Decision Boundaries & Model Interpretation)</a></li><li><a href=#page-178-179-estimating-class-probabilities>(Page 178-179: Estimating Class Probabilities)</a></li><li><a href=#page-179-the-cart-training-algorithm>(Page 179: The CART Training Algorithm)</a></li><li><a href=#page-180-181-computational-complexity--gini-vs-entropy>(Page 180-181: Computational Complexity & Gini vs. Entropy)</a></li><li><a href=#page-181-182-regularization-hyperparameters>(Page 181-182: Regularization Hyperparameters)</a></li><li><a href=#page-183-184-regression-with-decision-trees>(Page 183-184: Regression with Decision Trees)</a></li><li><a href=#page-185-186-instability-of-decision-trees>(Page 185-186: Instability of Decision Trees)</a></li></ul></li><li><a href=#glossary>Glossary</a><ul><li><a href=#q-is-backtracking-used-while-training-decision-trees-using-cart-algorithm-in-machine-learning>Q. Is backtracking used while training decision trees using CART algorithm in machine learning?</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 6: Decision Trees</h1><span class=reading-time><em>18 min read</em></span><div class=book-details><div class=book-content><h1 id=introduction-to-decision-trees>Introduction to Decision Trees</h1><p>Alright class, settle in! After exploring the world of Support Vector Machines, we&rsquo;re now turning our attention to another incredibly versatile and powerful family of algorithms: <strong>Decision Trees</strong>.</p><ul><li><strong>Versatility:</strong> Like SVMs, Decision Trees can perform both <strong>classification</strong> and <strong>regression</strong> tasks. They can even handle <strong>multioutput tasks</strong> (where each instance can have multiple output labels or values).</li><li><strong>Power:</strong> They are capable of fitting complex datasets. You might recall from Chapter 2, when we looked at the California housing data, a <code>DecisionTreeRegressor</code> was able to fit the training data perfectly (though, as we noted, it was actually overfitting).</li><li><strong>Fundamental Building Blocks:</strong> Decision Trees are also the core components of <strong>Random Forests</strong> (which we&rsquo;ll see in Chapter 7). Random Forests are among the most powerful and widely used ML algorithms today. So, understanding Decision Trees is crucial for understanding Random Forests.</li></ul><p><strong>What this chapter will cover:</strong></p><ol><li>How to train, visualize, and make predictions with Decision Trees.</li><li>The <strong>CART (Classification and Regression Tree) training algorithm</strong>, which Scikit-Learn uses.</li><li>How to <strong>regularize</strong> Decision Trees (to prevent overfitting).</li><li>How they&rsquo;re used for regression tasks.</li><li>Some of their limitations.</li></ol><h2 id=page-175-176-training-and-visualizing-a-decision-tree>(Page 175-176: Training and Visualizing a Decision Tree)</h2><p>Let&rsquo;s start by building one to see how it works. We&rsquo;ll use the Iris dataset (which we&rsquo;ve seen before, for example, with Logistic Regression in Chapter 4).</p><ul><li><p><strong>The Code:</strong>
<code>from sklearn.datasets import load_iris</code>
<code>from sklearn.tree import DecisionTreeClassifier</code></p><p><code>iris = load_iris()</code>
<code>X = iris.data[:, 2:] # petal length and width only</code>
<code>y = iris.target # species (0: setosa, 1: versicolor, 2: virginica)</code></p><p><code>tree_clf = DecisionTreeClassifier(max_depth=2)</code>
<code>tree_clf.fit(X, y)</code></p><ul><li>We&rsquo;re only using two features: petal length and petal width, to make it easy to visualize.</li><li><code>max_depth=2</code>: This is a crucial hyperparameter. We are telling the tree not to grow beyond a depth of 2 levels. This is a form of regularization to prevent it from becoming too complex and overfitting. If we didn&rsquo;t set this, the tree might grow very deep to try and perfectly classify every single training instance.</li></ul></li><li><p><strong>Visualizing the Tree (Page 176):</strong>
One of the great things about Decision Trees is that they are very intuitive and easy to visualize. Scikit-Learn provides a function <code>export_graphviz</code> to help with this.
<code>from sklearn.tree import export_graphviz</code>
<code>export_graphviz(</code>
<code>tree_clf,</code>
<code>out_file="iris_tree.dot",</code>
<code>feature_names=iris.feature_names[2:],</code>
<code>class_names=iris.target_names,</code>
<code>rounded=True,</code>
<code>filled=True</code>
<code>)</code>
This creates a <code>.dot</code> file. You then use the <code>dot</code> command-line tool (from the Graphviz package, which you&rsquo;d need to install separately) to convert this into an image, like a PNG:
<code>$ dot -Tpng iris_tree.dot -o iris_tree.png</code></p><p><strong>Figure 6-1 (Iris Decision Tree):</strong> This is the visual representation of our trained tree. It&rsquo;s a flowchart-like structure. Let&rsquo;s understand its components:<figure><img src=/bookshelf/hands-on-ml/ch-6-fig-6-1.png alt="Figure 6-1. Iris Decision Tree" width=700></figure></p><ul><li><strong>Nodes:</strong> Each box is a node.<ul><li><strong>Root Node (Depth 0, at the top):</strong> This is where you start. It asks a question about a feature. In Figure 6-1, it asks: &ldquo;petal length (cm) &lt;= 2.45?&rdquo;</li><li><strong>Child Nodes:</strong> Based on the answer (True or False), you move to a child node.</li><li><strong>Leaf Nodes:</strong> Nodes that don&rsquo;t have any children. These nodes make the final prediction.</li></ul></li><li><strong>Information in each node:</strong><ul><li><strong>Question/Condition:</strong> E.g., &ldquo;petal length (cm) &lt;= 2.45&rdquo;.</li><li><strong><code>gini</code>:</strong> This measures the <strong>impurity</strong> of the node. We&rsquo;ll discuss this more soon. A <code>gini</code> score of 0 means the node is &ldquo;pure&rdquo; – all training instances that reach this node belong to the same class.</li><li><strong><code>samples</code>:</strong> How many training instances from the dataset fall into this node.</li><li><strong><code>value</code>:</strong> How many training instances <em>of each class</em> fall into this node. For example, <code>value = [50, 50, 50]</code> at the root means there were 50 Setosa, 50 Versicolor, and 50 Virginica instances in the training set that reached this node (which is all of them initially).</li><li><strong><code>class</code>:</strong> The class that would be predicted if this node were a leaf node (i.e., the majority class among the samples in this node).</li></ul></li></ul></li></ul><h2 id=page-176-177-making-predictions>(Page 176-177: Making Predictions)</h2><p>How do you use this tree (Figure 6-1) to classify a new iris flower? It&rsquo;s like a game of &ldquo;20 Questions.&rdquo;</p><ol><li><strong>Start at the root node (depth 0).</strong><ul><li>Question: Is the flower&rsquo;s petal length ≤ 2.45 cm?</li></ul></li><li><strong>If YES (True):</strong> Move to the left child node (depth 1, left).<ul><li>This node in Figure 6-1 has <code>gini = 0.0</code>, <code>samples = 50</code>, <code>value = [50, 0, 0]</code>, <code>class = setosa</code>.</li><li>This is a <strong>leaf node</strong> (it has no further questions/children).</li><li>So, the prediction is <strong>Iris setosa</strong>.</li></ul></li><li><strong>If NO (False, meaning petal length > 2.45 cm):</strong> Move to the right child node (depth 1, right).<ul><li>This node is <em>not</em> a leaf node. It asks another question.</li><li>Question: Is the flower&rsquo;s petal width ≤ 1.75 cm?</li></ul></li><li><strong>If YES (True, petal length > 2.45 cm AND petal width ≤ 1.75 cm):</strong> Move to this node&rsquo;s left child (depth 2, middle of bottom row).<ul><li>This is a leaf node. <code>class = versicolor</code>.</li><li>Prediction: <strong>Iris versicolor</strong>.</li></ul></li><li><strong>If NO (False, petal length > 2.45 cm AND petal width > 1.75 cm):</strong> Move to this node&rsquo;s right child (depth 2, rightmost bottom row).<ul><li>This is a leaf node. <code>class = virginica</code>.</li><li>Prediction: <strong>Iris virginica</strong>.</li></ul></li></ol><p>It&rsquo;s really that simple to make a prediction once the tree is built!</p><ul><li><p><strong>An Important Quality (Bird Icon, page 177):</strong> Decision Trees require very little data preparation. They don&rsquo;t need feature scaling or centering. This is a nice practical advantage.</p></li><li><p><strong>Understanding <code>gini</code> (Gini Impurity - Equation 6-1, page 177):</strong></p><ul><li>A node&rsquo;s <code>gini</code> attribute measures its <strong>impurity</strong>.</li><li>A node is &ldquo;pure&rdquo; (<code>gini = 0</code>) if all training instances it applies to belong to the same class. The depth-1 left node (Setosa) is pure.</li><li><strong>Equation 6-1:</strong> <code>Gᵢ = 1 - Σₖ (pᵢ,ₖ)²</code><ul><li><code>Gᵢ</code>: Gini impurity of the i-th node.</li><li><code>pᵢ,ₖ</code>: Ratio of class <code>k</code> instances among the training instances in the i-th node.</li><li><em>What Gini impurity is ultimately trying to achieve:</em> It&rsquo;s a measure of how &ldquo;mixed up&rdquo; the classes are within a node.<ul><li>If a node is pure (all samples belong to one class, say class C), then <code>pᵢ,C = 1</code> and <code>pᵢ,k = 0</code> for all other <code>k</code>. So <code>Gᵢ = 1 - (1)² = 0</code>.</li><li>If a node has an equal mix of classes, the Gini impurity will be higher. For example, for the depth-2 left node (predicts versicolor):<ul><li>Samples = 54. Value = [0 setosa, 49 versicolor, 5 virginica].</li><li><code>p_setosa = 0/54</code></li><li><code>p_versicolor = 49/54</code></li><li><code>p_virginica = 5/54</code></li><li><code>G = 1 - (0/54)² - (49/54)² - (5/54)² ≈ 0.168</code>. This is fairly low, but not zero, as there&rsquo;s a mix of Versicolor and Virginica.</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>Binary Trees (Scorpion Icon, page 177):</strong></p><ul><li>Scikit-Learn uses the <strong>CART algorithm</strong>, which produces <strong>binary trees</strong>: non-leaf nodes always have exactly two children (questions have yes/no answers).</li><li>Other algorithms like ID3 can produce trees with nodes having more than two children.</li></ul></li></ul><h2 id=page-178-decision-boundaries--model-interpretation>(Page 178: Decision Boundaries & Model Interpretation)</h2><ul><li><p><strong>Figure 6-2 (Decision Tree decision boundaries):</strong> This shows how the tree partitions the feature space (petal length and petal width).<figure><img src=/bookshelf/hands-on-ml/ch-6-fig-6-2.png alt="Figure 6-2. Decision Tree decision boundaries" width=700></figure></p><ul><li>The root node (petal length ≤ 2.45 cm) creates the first thick vertical split. Everything to the left is classified as Setosa (pure).</li><li>The area to the right is impure, so the depth-1 right node splits it further with a horizontal line (petal width ≤ 1.75 cm).</li><li>Since <code>max_depth=2</code>, the tree stops there. The resulting regions are rectangular (or hyperrectangles in higher dimensions).</li><li>If <code>max_depth</code> were 3, the two depth-2 nodes could be split further, adding more boundaries (dotted lines in the figure).</li></ul></li><li><p><strong>Model Interpretation: White Box vs. Black Box (Sidebar, page 178):</strong></p><ul><li>Decision Trees are very intuitive and their decisions are easy to interpret. They are often called <strong>white box models</strong>. You can see the rules.</li><li>In contrast, Random Forests or Neural Networks are often considered <strong>black box models</strong>. They can make great predictions, but it&rsquo;s harder to explain in simple terms <em>why</em> a specific prediction was made.</li><li>Decision Trees provide simple classification rules that can even be applied manually.</li></ul></li></ul><h2 id=page-178-179-estimating-class-probabilities>(Page 178-179: Estimating Class Probabilities)</h2><p>Decision Trees can also estimate the probability that an instance belongs to a particular class <code>k</code>.</p><ul><li><strong>How it works:</strong><ol><li>Traverse the tree to find the leaf node for the instance.</li><li>Return the ratio of training instances of class <code>k</code> in that leaf node.</li></ol></li><li><strong>Example (page 179):</strong> Flower with petal length 5 cm, petal width 1.5 cm.<ol><li>Petal length > 2.45 cm (False for root) -> go to depth-1 right node.</li><li>Petal width ≤ 1.75 cm (True for this node) -> go to depth-2 left node (the one that predicts Versicolor).</li><li>This leaf node has <code>value = [0, 49, 5]</code>, meaning 0 Setosa, 49 Versicolor, 5 Virginica, out of 54 samples.</li></ol><ul><li>Probabilities:<ul><li>P(Setosa) = 0/54 = 0%</li><li>P(Versicolor) = 49/54 ≈ 90.7%</li><li>P(Virginica) = 5/54 ≈ 9.3%</li></ul></li></ul></li><li>Scikit-Learn code:
<code>tree_clf.predict_proba([[5, 1.5]])</code> gives <code>array([[0. , 0.90740741, 0.09259259]])</code>
<code>tree_clf.predict([[5, 1.5]])</code> gives <code>array([1])</code> (class 1 is Versicolor).</li><li><strong>Important Note:</strong> The estimated probabilities are the same for <em>any</em> point that falls into the same leaf node&rsquo;s region (e.g., the bottom-middle rectangle in Figure 6-2). This can sometimes be a limitation if fine-grained probability estimates are needed. Even if a flower had petal length 6cm and width 1.5cm (making it seem more likely Virginica by intuition, if it were near the boundary with Virginica region), it would still get the same probabilities if it landed in that same leaf node.</li></ul><h2 id=page-179-the-cart-training-algorithm>(Page 179: The CART Training Algorithm)</h2><p>Scikit-Learn uses the Classification and Regression Tree (CART) algorithm to train (or &ldquo;grow&rdquo;) Decision Trees.</p><ul><li><p><strong>How it works (Greedy Approach):</strong></p><ol><li>It first splits the training set into two subsets using a <em>single feature <code>k</code></em> and a <em>threshold <code>tₖ</code></em> (e.g., &ldquo;petal length ≤ 2.45 cm&rdquo;).</li><li><strong>How does it choose <code>k</code> and <code>tₖ</code>?</strong> It searches for the pair <code>(k, tₖ)</code> that produces the <strong>purest subsets</strong>, weighted by their size.<ul><li>Purity is measured by Gini impurity (or entropy, which we&rsquo;ll see).</li><li><strong>Equation 6-2: CART cost function for classification</strong>
<code>J(k, tₖ) = (m_left / m) * G_left + (m_right / m) * G_right</code><ul><li><code>m_left</code>, <code>m_right</code>: Number of instances in the left/right subset after the split.</li><li><code>m</code>: Total number of instances.</li><li><code>G_left</code>, <code>G_right</code>: Gini impurity of the left/right subset.</li><li><em>What this cost function is ultimately trying to achieve:</em> Find the feature and threshold that minimize this weighted average impurity of the child nodes. It wants the &ldquo;cleanest&rdquo; possible split.</li></ul></li></ul></li><li><strong>Recursion:</strong> Once the algorithm splits the set in two, it splits the subsets using the same logic, then the sub-subsets, and so on, recursively.</li></ol></li><li><p><strong>Stopping Conditions (When to stop splitting/recursing):</strong></p><ul><li>Reaches <code>max_depth</code> (hyperparameter).</li><li>Cannot find a split that will reduce impurity further.</li><li>Other hyperparameters controlling stopping:<ul><li><code>min_samples_split</code>: Minimum number of samples a node must have before it can be split.</li><li><code>min_samples_leaf</code>: Minimum number of samples a leaf node must have.</li><li><code>min_weight_fraction_leaf</code>: Same as <code>min_samples_leaf</code> but as a fraction of total weighted instances.</li><li><code>max_leaf_nodes</code>: Maximum number of leaf nodes.
These are all <strong>regularization hyperparameters</strong>.</li></ul></li></ul></li><li><p><strong>Greedy Nature (Scorpion Icon, page 180):</strong></p><ul><li>CART is a <strong>greedy algorithm</strong>. At each step, it searches for the <em>locally</em> optimal split at the current level. It doesn&rsquo;t look ahead to see if a less optimal split now might lead to an even better overall tree (lower total impurity) a few levels down.</li><li>A greedy algorithm often produces a solution that&rsquo;s reasonably good, but not guaranteed to be globally optimal.</li><li>Finding the truly optimal tree is an <strong>NP-Complete problem</strong> (computationally very hard, requires O(exp(m)) time), so we settle for a &ldquo;reasonably good&rdquo; greedy solution.</li></ul></li></ul><h2 id=page-180-181-computational-complexity--gini-vs-entropy>(Page 180-181: Computational Complexity & Gini vs. Entropy)</h2><ul><li><p><strong>Prediction Complexity:</strong></p><ul><li>Traversing a Decision Tree from root to leaf takes roughly O(log₂(m)) nodes for a balanced tree (where <code>m</code> is number of instances).</li><li>Each node checks one feature.</li><li>So, overall prediction complexity is O(log₂(m)), independent of the number of features <code>n</code>. Predictions are very fast!</li></ul></li><li><p><strong>Training Complexity:</strong></p><ul><li>At each node, CART compares all features (or <code>max_features</code>) on all samples in that node. This results in a training complexity of roughly O(n × m log₂(m)).</li><li>For small training sets (&lt; few thousand), Scikit-Learn can speed up training by presorting data (<code>presort=True</code> parameter, though this is deprecated and will be removed; Scikit-learn now often sorts internally when beneficial). For larger sets, presorting slows it down.</li></ul></li><li><p><strong>Gini Impurity or Entropy? (Page 180):</strong></p><ul><li>By default, CART uses Gini impurity. You can set <code>criterion="entropy"</code> to use <strong>entropy</strong> as the impurity measure instead.</li><li><strong>Entropy (Equation 6-3, page 181):</strong>
<code>Hᵢ = - Σₖ (pᵢ,ₖ * log₂(pᵢ,ₖ))</code> (sum over classes <code>k</code> where <code>pᵢ,ₖ ≠ 0</code>)<ul><li>Originated in thermodynamics (molecular disorder). In information theory (Shannon), it measures average information content.</li><li>Entropy is 0 if a set contains instances of only one class (pure).</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> Similar to Gini, it measures the &ldquo;mixed-up-ness&rdquo; or uncertainty in a node. Lower entropy means less uncertainty/more purity.</li></ul></li><li><strong>Gini vs. Entropy: Does it matter?</strong><ul><li>Mostly, no. They lead to similar trees.</li><li>Gini is slightly faster to compute, so it&rsquo;s a good default.</li><li>When they differ: Gini tends to isolate the most frequent class in its own branch of the tree. Entropy tends to produce slightly more balanced trees.</li></ul></li></ul></li></ul><h2 id=page-181-182-regularization-hyperparameters>(Page 181-182: Regularization Hyperparameters)</h2><p>Decision Trees make very few assumptions about the data (they are <strong>nonparametric models</strong> – the number of parameters isn&rsquo;t fixed before training, the model structure adapts to the data).</p><ul><li>If left unconstrained, they will fit the training data very closely, likely <strong>overfitting</strong>.</li><li>To avoid this, we need to <strong>regularize</strong> by restricting their freedom during training.</li><li><strong>Key Regularization Hyperparameters in <code>DecisionTreeClassifier</code>:</strong><ul><li><code>max_depth</code>: Maximum depth of the tree. (Default is <code>None</code> = unlimited). Reducing this is a common way to regularize.</li><li><code>min_samples_split</code>: Minimum samples a node needs to be split.</li><li><code>min_samples_leaf</code>: Minimum samples a leaf node must have.</li><li><code>min_weight_fraction_leaf</code>: As <code>min_samples_leaf</code>, but as a fraction.</li><li><code>max_leaf_nodes</code>: Limits the total number of leaf nodes.</li><li><code>max_features</code>: Max number of features evaluated for splitting at each node.</li><li>Increasing <code>min_*</code> hyperparameters or reducing <code>max_*</code> hyperparameters will regularize the model.</li></ul></li><li><strong>Figure 6-3 (page 182):</strong> Shows the effect on the moons dataset.<figure><img src=/bookshelf/hands-on-ml/ch-6-fig-6-3.png alt="Figure 6-3. Regularization using min_samples_leaf" width=700></figure><ul><li>Left: Default hyperparameters (no restrictions) -> Overfitting (wiggly boundary).</li><li>Right: <code>min_samples_leaf=4</code> -> Simpler, smoother boundary, likely generalizes better.</li></ul></li><li><strong>Pruning (Scorpion Icon, page 182):</strong><ul><li>Some algorithms work by first training the tree without restrictions, then <strong>pruning</strong> (deleting) unnecessary nodes.</li><li>A node is considered unnecessary if the purity improvement it provides is not statistically significant (e.g., using a chi-squared test to check if improvement is just by chance). If p-value > threshold, prune.</li></ul></li></ul><h2 id=page-183-184-regression-with-decision-trees>(Page 183-184: Regression with Decision Trees)</h2><p>Decision Trees can also do regression using <code>DecisionTreeRegressor</code>.</p><ul><li>Example: Training on a noisy quadratic dataset with <code>max_depth=2</code>.</li><li><strong>Figure 6-4 (A Decision Tree for regression):</strong> Looks similar to a classification tree.<figure><img src=/bookshelf/hands-on-ml/ch-6-fig-6-4.png alt="Figure 6-4. A Decision Tree for regression" width=700></figure><ul><li><strong>Main difference:</strong> Instead of predicting a <em>class</em> in each node, it predicts a <em>value</em>.</li><li>The value predicted at a leaf node is the <strong>average target value</strong> of the training instances that fall into that leaf.</li><li>The <code>mse</code> attribute in each node shows the mean squared error of the training instances in that node, relative to the average value of that node.</li></ul></li><li><strong>Predictions (Figure 6-5, page 184):</strong><ul><li>The predictions are piecewise constant. For any region defined by a leaf node, the prediction is the average value of the training instances in that region.</li><li>Increasing <code>max_depth</code> leads to more steps in the prediction function, fitting the training data more closely.</li></ul></li><li><strong>CART Algorithm for Regression (Equation 6-4, page 184):</strong><ul><li>Works mostly the same way as for classification.</li><li><strong>Difference:</strong> Instead of minimizing impurity (Gini/entropy), it tries to split the training set in a way that <strong>minimizes the MSE</strong>.</li><li><code>J(k, tₖ) = (m_left / m) * MSE_left + (m_right / m) * MSE_right</code></li><li>It wants to make the instances within each resulting region as close as possible to the mean value of that region.</li></ul></li><li><strong>Regularization (Figure 6-6, page 184):</strong><ul><li>Just like classification trees, regression trees are prone to overfitting if unregularized (left plot).</li><li>Setting <code>min_samples_leaf=10</code> (right plot) gives a much more reasonable, smoother model.</li></ul></li></ul><h2 id=page-185-186-instability-of-decision-trees>(Page 185-186: Instability of Decision Trees)</h2><p>Decision Trees have many great qualities (simple, interpretable, versatile, powerful). But they have limitations.</p><ol><li><p><strong>Sensitivity to Training Set Rotation (Orthogonal Boundaries - Figure 6-7, page 185):</strong><figure><img src=/bookshelf/hands-on-ml/ch-6-fig-6-7.png alt="Figure 6-7. Sensitivity to training set rotation" width=700></figure></p><ul><li>Decision Trees prefer to create <strong>orthogonal decision boundaries</strong> (splits are perpendicular to an axis).</li><li>If your dataset is rotated, a simple linear boundary in the rotated space might require a complex, step-like boundary for the Decision Tree.</li><li>The left plot shows a tree easily splitting unrotated data. The right shows a convoluted boundary for data rotated 45°.</li><li>The model on the right might not generalize well.</li><li>One way to limit this: Use Principal Component Analysis (PCA, Chapter 8) to orient data better first.</li></ul></li><li><p><strong>Sensitivity to Small Variations in Training Data (Figure 6-8, page 186):</strong></p><ul><li>This is a major issue. Decision Trees are very sensitive to small changes in the training data.</li><li>Example: Remove one instance (the widest Iris versicolor) from the Iris dataset and retrain. The resulting tree (Figure 6-8) can look very different from the original (Figure 6-2).</li><li>Since the CART algorithm used by Scikit-Learn is stochastic (randomly selects features to evaluate at nodes if <code>max_features</code> is less than total features, or how ties are broken), you might get different models even on the <em>same</em> training data unless you set <code>random_state</code>.</li></ul></li></ol><p><strong>How to limit this instability?</strong>
Random Forests (Chapter 7!) average predictions over many trees, which greatly helps reduce this variance and instability.</p><p>And that&rsquo;s the essence of Decision Trees! They work by recursively partitioning the data based on simple questions about features, aiming to create purer (for classification) or more homogeneous (for regression) subsets. They are interpretable but can be unstable and prone to overfitting if not regularized.</p><p>Any thoughts or questions on how these trees make decisions or how they are built? The idea of recursive partitioning and measuring purity/error at each step is central.</p><hr><h1 id=glossary>Glossary</h1><h2 id=q-is-backtracking-used-while-training-decision-trees-using-cart-algorithm-in-machine-learning>Q. Is backtracking used while training decision trees using CART algorithm in machine learning?</h2><p>Yes, absolutely! The process of building a decision tree, especially using algorithms like <strong>CART (Classification and Regression Trees)</strong>, shares a very strong conceptual similarity with recursive backtracking, particularly the divide-and-conquer aspect and the exploration of choices.</p><p>Here&rsquo;s how they relate:</p><ol><li><p><strong>Recursive Partitioning (Divide and Conquer):</strong></p><ul><li><strong>Decision Trees:</strong> At each node, the algorithm searches for the &ldquo;best&rdquo; feature and the &ldquo;best&rdquo; split point for that feature to divide the current dataset into two or more subsets. This partitioning is done recursively.</li><li><strong>Backtracking/Recursion:</strong> We break a problem down into smaller sub problems.</li></ul></li><li><p><strong>Making a Sequence of Decisions:</strong></p><ul><li><strong>Decision Trees:</strong> Building a tree is a sequence of decisions:<ul><li>Which feature to split on at the current node?</li><li>What value of that feature to use as the split point?</li></ul></li><li><strong>Backtracking:</strong> We make a sequence of choices to build a potential solution.</li></ul></li><li><p><strong>Exploring Choices (Greedy vs. Exhaustive):</strong></p><ul><li><strong>CART (Typically Greedy):</strong> At each node, CART makes a <em>locally optimal</em> decision. It searches for the single feature and split point that <em>currently</em> gives the best improvement in purity (e.g., Gini impurity, entropy for classification; variance reduction for regression). It <em>commits</em> to this split and then recursively processes the resulting child nodes. It doesn&rsquo;t typically &ldquo;backtrack&rdquo; in the sense of undoing a split if it later turns out to be globally suboptimal. This greedy nature is why decision trees can sometimes find solutions that aren&rsquo;t the absolute global optimum but are good and fast to compute.</li><li><strong>Pure Backtracking (Exhaustive):</strong> Would explore <em>all possible</em> sequences of splits to find the <em>globally</em> best tree. This is computationally infeasible for most datasets.</li></ul></li><li><p><strong>Stopping Conditions (Base Cases):</strong></p><ul><li><strong>Decision Trees:</strong> Recursion stops when:<ul><li>A node is &ldquo;pure&rdquo; (all samples belong to one class).</li><li>A pre-defined maximum depth is reached.</li><li>The number of samples in a node is below a threshold.</li><li>No split further improves purity.</li></ul></li><li><strong>Backtracking:</strong> Recursion stops when:<ul><li>A complete solution is found.</li><li>A dead end is reached (no valid next choice).</li></ul></li></ul></li><li><p><strong>Pruning (Analogous to Constraint Checking/Pruning in Backtracking):</strong></p><ul><li><strong>Decision Trees:</strong> After a large tree is grown (often greedily), a &ldquo;pruning&rdquo; step is often applied. This is where the tree might be &ldquo;simplified&rdquo; by removing branches that don&rsquo;t contribute much to overall accuracy or that lead to overfitting. This is somewhat like backtracking deciding a path is not fruitful, but it&rsquo;s typically done <em>after</em> the initial greedy construction.</li><li><strong>Backtracking:</strong> We &ldquo;prune&rdquo; branches of the search space if a partial solution violates constraints.</li></ul></li></ol><p><strong>Where they differ significantly:</strong></p><ul><li><p><strong>Goal:</strong></p><ul><li><strong>Backtracking (as we discussed):</strong> Often aims to find <em>all</em> solutions or <em>one</em> solution that satisfies constraints (e.g., N-Queens, Sudoku).</li><li><strong>Decision Tree (CART):</strong> Aims to build a <em>model</em> that generalizes well to unseen data by finding optimal decision boundaries.</li></ul></li><li><p><strong>Nature of &ldquo;Undo&rdquo;:</strong></p><ul><li><strong>Backtracking:</strong> The &ldquo;undo&rdquo; is fundamental to explore different branches of the <em>same problem instance</em> to find different discrete solutions.</li><li><strong>CART:</strong> Typically doesn&rsquo;t &ldquo;undo&rdquo; a split choice in its main growing phase. The &ldquo;undo&rdquo; equivalent is more like the post-hoc pruning process, where parts of the already-built tree are removed.</li></ul></li></ul><p><strong>So, in summary:</strong></p><p>The recursive, divide-and-conquer nature of building a decision tree by repeatedly finding the best split is very similar to the recursive calls in backtracking. Both explore a &ldquo;tree&rdquo; of possibilities.</p><p>However, CART&rsquo;s typical implementation is <strong>greedy</strong> in its choice of splits at each node, whereas the backtracking problems we&rsquo;ve discussed (like N-Queens for <em>all</em> solutions) are more <strong>exhaustive</strong> in exploring valid choices. If CART were to try and find the <em>globally optimal</em> decision tree by trying every possible sequence of splits and then backtracking, it would be computationally intractable.</p><p>So, while the recursive structure is similar, the search strategy (greedy vs. exhaustive with backtracking) and the ultimate goal are different. The core idea of recursively breaking down the problem based on choices is a shared theme.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>