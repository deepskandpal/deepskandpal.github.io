<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul></nav></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#introduction---inspiration-from-nature>Introduction - Inspiration from Nature</a><ul><li><a href=#page-280-from-biological-to-artificial-neurons---a-brief-history>(Page 280: From Biological to Artificial Neurons - A Brief History)</a></li><li><a href=#page-281-283-biological-neurons-and-a-simple-artificial-neuron-model>(Page 281-283: Biological Neurons and a Simple Artificial Neuron Model)</a></li><li><a href=#page-284-288-the-perceptron>(Page 284-288: The Perceptron)</a></li><li><a href=#page-288-293-the-multilayer-perceptron-mlp-and-backpropagation>(Page 288-293: The Multilayer Perceptron (MLP) and Backpropagation)</a></li><li><a href=#page-292-294-regression-and-classification-mlps>(Page 292-294: Regression and Classification MLPs)</a></li><li><a href=#page-295-306-implementing-mlps-with-keras>(Page 295-306: Implementing MLPs with Keras)</a></li><li><a href=#page-302-306-compiling-training-evaluating-and-predicting>(Page 302-306: Compiling, Training, Evaluating, and Predicting)</a></li><li><a href=#page-307-308-building-a-regression-mlp-using-the-sequential-api>(Page 307-308: Building a Regression MLP Using the Sequential API)</a></li><li><a href=#page-308-312-building-complex-models-using-the-functional-api>(Page 308-312: Building Complex Models Using the Functional API)</a></li><li><a href=#page-320-327-fine-tuning-neural-network-hyperparameters>(Page 320-327: Fine-Tuning Neural Network Hyperparameters)</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 10: Introduction to Artificial Neural Networks</h1><span class=reading-time><em>39 min read</em></span><div class=book-details><div class=book-content><h1 id=introduction---inspiration-from-nature>Introduction - Inspiration from Nature</h1><p>The chapter beautifully starts by reminding us how nature has often inspired human inventions: birds inspired planes, burdock plants inspired Velcro. So, it&rsquo;s logical to look at the brain&rsquo;s architecture for inspiration on building intelligent machines. This is the core idea that sparked ANNs.</p><ul><li><p><strong>ANNs vs. Biological Neurons:</strong> While ANNs were inspired by the networks of biological neurons in our brains, they have evolved to be quite different. Just like planes don&rsquo;t flap their wings, ANNs don&rsquo;t need to be biologically perfectly realistic to be effective. The footnote mentions a good philosophy: be open to biological inspiration but don&rsquo;t be afraid to create biologically <em>unrealistic</em> models if they work well. Some researchers even prefer calling the components &ldquo;units&rdquo; rather than &ldquo;neurons&rdquo; to avoid this restrictive analogy.</p></li><li><p><strong>The Power of ANNs:</strong></p><ul><li>They are at the heart of <strong>Deep Learning</strong>.</li><li><strong>Versatile, powerful, and scalable.</strong></li><li>Ideal for large, complex tasks like:<ul><li>Image classification (Google Images)</li><li>Speech recognition (Apple&rsquo;s Siri)</li><li>Recommendation systems (YouTube)</li><li>Game playing (DeepMind&rsquo;s AlphaGo)</li></ul></li></ul></li><li><p><strong>Chapter Structure:</strong></p><ul><li><strong>Part 1:</strong> Introduces ANNs, starting from early architectures and leading up to <strong>Multilayer Perceptrons (MLPs)</strong>, which are heavily used today.</li><li><strong>Part 2:</strong> Focuses on implementing neural networks using the <strong>Keras API</strong>. Keras is described as a &ldquo;beautifully designed and simple high-level API&rdquo; for building, training, evaluating, and running neural networks.</li></ul></li></ul><h2 id=page-280-from-biological-to-artificial-neurons---a-brief-history>(Page 280: From Biological to Artificial Neurons - A Brief History)</h2><ul><li><p><strong>Early Beginnings (1943):</strong> ANNs are surprisingly old! They were first introduced by neurophysiologist Warren McCulloch and mathematician Walter Pitts. Their landmark paper proposed a simplified computational model of how biological neurons might perform complex computations using propositional logic. This was the first ANN architecture.</p></li><li><p><strong>The First &ldquo;AI Winter&rdquo; (1960s-1970s):</strong> Early successes led to widespread belief in imminent truly intelligent machines. When this didn&rsquo;t materialize quickly, funding dried up, and ANNs entered a long &ldquo;winter.&rdquo;</p></li><li><p><strong>Revival (1980s - Connectionism):</strong> New architectures and better training techniques sparked renewed interest. However, progress was slow.</p></li><li><p><strong>The Second &ldquo;AI Winter&rdquo; (1990s):</strong> Other ML techniques like Support Vector Machines (Chapter 5) emerged, seeming to offer better results and stronger theoretical foundations, pushing ANNs to the background again.</p></li><li><p><strong>The Current Wave (Now!):</strong> We&rsquo;re in another, much stronger wave of interest in ANNs. Why is this time different?</p><ol><li><strong>Huge Quantity of Data:</strong> We now have vast amounts of data to train large neural networks (e.g., ImageNet). ANNs often outperform other ML techniques on very large and complex problems.</li><li><strong>Tremendous Increase in Computing Power:</strong><ul><li>Moore&rsquo;s Law (components in circuits doubling roughly every 2 years).</li><li>Powerful <strong>GPUs</strong> (Graphics Processing Units), initially driven by the gaming industry, are exceptionally good at the kind of parallel computations needed for ANNs.</li><li>Cloud platforms make this power accessible to everyone.</li></ul></li><li><strong>Improved Training Algorithms:</strong> While often only slight tweaks from 1990s algorithms, these have had a huge positive impact (e.g., better optimization algorithms, initialization techniques, regularization).</li><li><strong>Theoretical Limitations Turning Benign:</strong> Fears that ANNs would always get stuck in poor local optima have largely proven less of an issue in practice. When they do get stuck, the local optima are often fairly close to the global optimum.</li><li><strong>Virtuous Circle of Funding and Progress:</strong> Amazing products based on ANNs make headlines (AlphaGo, GPT-3/4, etc.), attracting more attention, funding, and talent, leading to further progress.</li></ol></li></ul><h2 id=page-281-283-biological-neurons-and-a-simple-artificial-neuron-model>(Page 281-283: Biological Neurons and a Simple Artificial Neuron Model)</h2><ul><li><p><strong>Biological Neurons (Figure 10-1, page 282):</strong></p><ul><li>A quick look at the structure: cell body (soma), dendrites (receive signals), axon (transmits signals), synaptic terminals (connect to other neurons).</li><li>Neurons produce electrical impulses (action potentials). When a neuron receives enough neurotransmitter signals at its synapses within a short period, it &ldquo;fires&rdquo; its own impulse. Some neurotransmitters are excitatory (encourage firing), some are inhibitory.</li><li>Individual neurons are relatively simple, but billions of them, each connected to thousands of others, form a vast network capable of highly complex computations. The brain&rsquo;s architecture, especially the layered structure of the cerebral cortex (Figure 10-2), provides inspiration.</li></ul></li><li><p><strong>Logical Computations with Artificial Neurons (McCulloch & Pitts Model - Page 283):</strong></p><ul><li>Their early model was very simple:<ul><li>Binary (on/off) inputs.</li><li>One binary (on/off) output.</li><li>The neuron activates its output if a certain <em>number</em> of its inputs are active.</li></ul></li><li><strong>Figure 10-3</strong> shows how such simple neurons can perform basic logical computations (assuming activation if at least two inputs are active):<ul><li><strong>Identity (C=A):</strong> Neuron A sends two signals to C. If A is on, C gets two active inputs and turns on.</li><li><strong>Logical AND (C = A ∧ B):</strong> C activates only if both A and B are active (one active input isn&rsquo;t enough).</li><li><strong>Logical OR (C = A ∨ B):</strong> C activates if A is active, or B is active, or both (any one provides two inputs to a common intermediate neuron, which then activates C, or if A and B both directly input to C and one active input is enough, though the diagram is a bit more complex). The diagram shows intermediate neurons. The idea is that if A is active, it can trigger enough input for C to fire, same for B.</li><li><strong>Complex Logic (e.g., A AND NOT B):</strong> If we assume an input can <em>inhibit</em> activity, this is also possible. If A is active and B is off, C activates. If B is on, it inhibits C.</li></ul></li><li><em>What this was ultimately trying to achieve:</em> To show that even a very simplified model of a neuron, when networked, could perform fundamental logical computations, suggesting a path towards building computational intelligence.</li></ul></li></ul><h2 id=page-284-288-the-perceptron>(Page 284-288: The Perceptron)</h2><p>Invented by Frank Rosenblatt in 1957. One of the simplest ANN architectures.</p><ul><li><p><strong>Based on a Threshold Logic Unit (TLU) or Linear Threshold Unit (LTU) (Figure 10-4, page 284):</strong></p><ul><li><strong>Inputs & Output:</strong> Numbers (not just binary on/off).</li><li><strong>Weights:</strong> Each input connection <code>i</code> has an associated weight <code>wᵢ</code>.</li><li><strong>Weighted Sum:</strong> The TLU computes a weighted sum of its inputs: <code>z = w₁x₁ + w₂x₂ + ... + wₙxₙ = wᵀx</code>.</li><li><strong>Step Function:</strong> It then applies a <strong>step function</strong> to this sum <code>z</code> to produce the output: <code>h_w(x) = step(z)</code>.</li><li><em>What the TLU is ultimately trying to achieve:</em> It makes a decision based on whether a weighted combination of evidence (<code>z</code>) exceeds some threshold.</li></ul></li><li><p><strong>Common Step Functions (Equation 10-1, page 285):</strong></p><ul><li><strong>Heaviside step function:</strong> Outputs 0 if <code>z &lt; 0</code>, outputs 1 if <code>z ≥ 0</code> (assuming threshold is 0).</li><li><strong>Sign function:</strong> Outputs -1 if <code>z &lt; 0</code>, 0 if <code>z = 0</code>, +1 if <code>z > 0</code>.</li></ul></li><li><p><strong>Single TLU for Classification:</strong></p><ul><li>A single TLU can perform simple linear binary classification. It&rsquo;s very similar to a Logistic Regression or linear SVM classifier, but with a hard threshold output instead of a probability or a margin.</li><li>Example: Classify Iris flowers based on petal length and width. You&rsquo;d add a bias feature <code>x₀=1</code>. Training means finding weights <code>w₀, w₁, w₂</code>.</li></ul></li><li><p><strong>Perceptron Architecture (Figure 10-5, page 286):</strong><figure><img src=/bookshelf/hands-on-ml/ch-10-fig-10-5.png alt="Figure 10-5. Architecture of a Perceptron with two input neurons, one bias neuron, and three output neurons" width=700></figure></p><ul><li>A Perceptron is typically a single layer of TLUs.</li><li>Each TLU in this layer is connected to all inputs. This is a <strong>fully connected layer</strong> (or <strong>dense layer</strong>).</li><li>Inputs are fed through special &ldquo;passthrough&rdquo; <strong>input neurons</strong>.</li><li>A <strong>bias neuron</strong> (always outputting 1) is usually added and connected to each TLU, providing the bias term <code>w₀</code> (or <code>b</code> in the new notation used later).</li><li>The Perceptron in Figure 10-5 has 2 inputs, 1 bias neuron, and 3 output TLUs. This can classify instances into three <em>different binary classes simultaneously</em> (making it a multioutput classifier). For example, output 1 could be &ldquo;is it a cat?&rdquo;, output 2 &ldquo;is it a dog?&rdquo;, output 3 &ldquo;is it a bird?&rdquo;. An input could be classified as a cat AND a bird if both TLUs fire (though that specific example isn&rsquo;t ideal for mutually exclusive animal classes).</li></ul></li><li><p><strong>Computing Outputs for a Layer (Equation 10-2, page 286):</strong>
For a whole layer of artificial neurons, for several instances at once:
<code>h_W,b(X) = φ(XW + b)</code></p><ul><li><code>X</code>: Matrix of input features (instances x features).</li><li><code>W</code>: Weight matrix (input neurons x artificial neurons in the layer). Contains connection weights <em>excluding</em> bias.</li><li><code>b</code>: Bias vector (one bias term per artificial neuron in the layer).</li><li><code>XW + b</code>: Computes the weighted sum <code>z</code> for every neuron and every instance.</li><li><code>φ</code> (phi): The <strong>activation function</strong>. For TLUs, this is a step function.</li><li><em>What this equation is ultimately trying to achieve:</em> Efficiently calculate the output of every neuron in a layer for every instance in a batch of data, using matrix multiplication.</li></ul></li><li><p><strong>Perceptron Training (Hebbian Learning & Perceptron Learning Rule - Page 286):</strong></p><ul><li>Inspired by <strong>Hebb&rsquo;s Rule</strong> (&ldquo;Cells that fire together, wire together&rdquo;): When neuron A often triggers neuron B, the connection between them strengthens.</li><li>Perceptrons use a variant: The <strong>Perceptron learning rule</strong> reinforces connections that help <em>reduce the error</em>.</li><li><strong>Process:</strong><ol><li>Feed one training instance at a time.</li><li>For each instance, make predictions.</li><li>For <em>every output neuron that produced a wrong prediction</em>, reinforce the connection weights from the inputs that <em>would have contributed to the correct prediction</em>.</li></ol></li><li><strong>Equation 10-3 (Weight Update Rule):</strong>
<code>wᵢⱼ⁽ⁿᵉˣᵗ ˢᵗᵉᵖ⁾ = wᵢⱼ + η(yⱼ - ŷⱼ)xᵢ</code><ul><li><code>wᵢⱼ</code>: Weight between i-th input and j-th output neuron.</li><li><code>η</code> (eta): Learning rate.</li><li><code>yⱼ</code>: Target output for j-th neuron.</li><li><code>ŷⱼ</code>: Predicted output for j-th neuron.</li><li><code>xᵢ</code>: Value of i-th input for the current instance.</li><li><em>What this rule is ultimately trying to achieve:</em><ul><li>If <code>ŷⱼ</code> is correct (<code>yⱼ - ŷⱼ = 0</code>), weights don&rsquo;t change.</li><li>If <code>ŷⱼ</code> is wrong:<ul><li>If <code>yⱼ=1</code> and <code>ŷⱼ=0</code> (neuron should have fired but didn&rsquo;t): <code>yⱼ - ŷⱼ = 1</code>. Weights <code>wᵢⱼ</code> are increased if <code>xᵢ</code> was positive (strengthening connections that should have contributed to firing).</li><li>If <code>yⱼ=0</code> and <code>ŷⱼ=1</code> (neuron fired but shouldn&rsquo;t have): <code>yⱼ - ŷⱼ = -1</code>. Weights <code>wᵢⱼ</code> are decreased if <code>xᵢ</code> was positive (weakening connections that wrongly contributed to firing).</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>Perceptron Convergence Theorem (Page 287):</strong>
If training instances are linearly separable, Rosenblatt showed this algorithm <em>would converge</em> to a solution (a set of weights that separates the classes).</p></li><li><p><strong>Scikit-Learn <code>Perceptron</code> class:</strong> Implements a single-TLU network.
<code>from sklearn.linear_model import Perceptron</code>
<code>per_clf = Perceptron()</code>
<code>per_clf.fit(X, y)</code></p><ul><li>The book notes this is equivalent to <code>SGDClassifier(loss="perceptron", learning_rate="constant", eta0=1, penalty=None)</code>.</li><li>Unlike Logistic Regression, Perceptrons output hard predictions (0 or 1), not probabilities. This is one reason to prefer Logistic Regression.</li></ul></li><li><p><strong>Limitations of Perceptrons (Minsky & Papert, 1969 - Page 288):</strong></p><ul><li>Highlighted serious weaknesses, famously that Perceptrons (being linear classifiers) cannot solve some trivial problems like the <strong>Exclusive OR (XOR)</strong> problem (Figure 10-6, left). XOR is not linearly separable.</li><li>This disappointment led to another decline in ANN research (part of the first AI winter).</li></ul></li></ul><h2 id=page-288-293-the-multilayer-perceptron-mlp-and-backpropagation>(Page 288-293: The Multilayer Perceptron (MLP) and Backpropagation)</h2><ul><li><p><strong>Overcoming Perceptron Limitations: Stacking Perceptrons (Page 288):</strong></p><ul><li>Limitations can be overcome by stacking multiple layers of Perceptrons. The resulting ANN is a <strong>Multilayer Perceptron (MLP)</strong>.</li><li><strong>Figure 10-6 (right)</strong> shows an MLP that <em>can</em> solve the XOR problem. It uses an intermediate &ldquo;hidden&rdquo; layer of neurons.</li><li><em>What the MLP is ultimately trying to achieve:</em> By having hidden layers, MLPs can learn more complex, non-linear decision boundaries. The hidden layers can transform the input features into a new representation where the problem becomes linearly separable for the output layer.</li></ul></li><li><p><strong>MLP Architecture (Figure 10-7, page 289):</strong><figure><img src=/bookshelf/hands-on-ml/ch-10-fig-10-7.png alt="Figure 10-7. Architecture of a Multilayer Perceptron with two inputs, one hidden layer of four neurons, and three output neurons (the bias neurons are shown here, but usually they are implicit)" width=700></figure></p><ul><li>One (passthrough) <strong>input layer</strong>.</li><li>One or more layers of TLUs, called <strong>hidden layers</strong>.</li><li>One final layer of TLUs called the <strong>output layer</strong>.</li><li>Layers near input are &ldquo;lower layers&rdquo;; layers near output are &ldquo;upper layers.&rdquo;</li><li>Every layer (except output) usually includes a bias neuron and is fully connected to the next layer.</li><li>Signal flows one way (input -> output): <strong>Feedforward Neural Network (FNN)</strong>.</li><li><strong>Deep Neural Network (DNN):</strong> An ANN with a &ldquo;deep&rdquo; stack of hidden layers (definition of &ldquo;deep&rdquo; is fuzzy but generally means more than one or two these days). Deep Learning studies DNNs.</li></ul></li><li><p><strong>Training MLPs: The Backpropagation Algorithm (Page 289-290):</strong>
For many years, training MLPs was a major challenge. In 1986, Rumelhart, Hinton, and Williams published the <strong>backpropagation</strong> training algorithm, still fundamental today.</p><ul><li><strong>What it is:</strong> Essentially, it&rsquo;s <strong>Gradient Descent</strong> (Chapter 4) applied to an MLP, using an efficient technique to compute all the necessary gradients.</li><li><strong>How it computes gradients (Autodiff - sidebar, page 290):</strong><ul><li>It uses <strong>reverse-mode automatic differentiation (autodiff)</strong>.</li><li>In just <em>two passes</em> through the network (one forward, one backward), it can compute the gradient of the network&rsquo;s error with respect to <em>every single model parameter</em> (all weights and biases in all layers).</li><li>This tells us how each weight/bias should be tweaked to reduce the error.</li></ul></li><li>Once gradients are computed, it performs a regular Gradient Descent step. Repeat until convergence.</li></ul></li><li><p><strong>Backpropagation Algorithm in More Detail (Page 290):</strong></p><ol><li><strong>Mini-batch Processing:</strong> Handles one mini-batch of training instances at a time. Goes through the full training set multiple times; each full pass is an <strong>epoch</strong>.</li><li><strong>Forward Pass:</strong><ul><li>Pass the mini-batch to the input layer.</li><li>Compute outputs of neurons in the first hidden layer.</li><li>Pass these outputs to the next layer, compute its outputs, and so on, until the output layer.</li><li>This is like making predictions, but all intermediate results (activations of all neurons) are <em>preserved</em> because they are needed for the backward pass.</li></ul></li><li><strong>Measure Error:</strong> Use a loss function (e.g., MSE for regression, Cross-Entropy for classification) to compare the network&rsquo;s output with the desired output (true labels).</li><li><strong>Backward Pass (Propagating Error Gradients):</strong><ul><li>Compute how much each output connection contributed to the error (using the chain rule of calculus).</li><li>Propagate these error contributions backward:<ul><li>Measure how much connections in the layer below contributed to the output layer&rsquo;s error contributions (again, using chain rule).</li><li>Continue backward until the input layer is reached.</li></ul></li><li>This reverse pass efficiently measures the error gradient across all connection weights.</li></ul></li><li><strong>Gradient Descent Step:</strong> Tweak all connection weights in the network using the computed error gradients to reduce the overall error.</li></ol></li><li><p><strong>Key Change for Backpropagation: Activation Functions (Page 291):</strong></p><ul><li>The original Perceptron used a step function. Step functions have flat segments (zero gradient), so Gradient Descent gets stuck.</li><li><strong>Crucial innovation for MLPs:</strong> Replace the step function with a differentiable activation function, like the <strong>logistic (sigmoid) function</strong> <code>σ(z) = 1 / (1 + exp(-z))</code>.<ul><li>It has a well-defined, non-zero derivative everywhere, allowing GD to make progress.</li></ul></li><li><strong>Other Popular Activation Functions (Figure 10-8, page 292):</strong><ul><li><strong>Hyperbolic Tangent (tanh):</strong> <code>tanh(z) = 2σ(2z) - 1</code>.<ul><li>S-shaped, continuous, differentiable.</li><li>Output range: -1 to 1 (vs. 0 to 1 for sigmoid).</li><li>Centering output around 0 often helps speed up convergence at start of training.</li></ul></li><li><strong>Rectified Linear Unit (ReLU):</strong> <code>ReLU(z) = max(0, z)</code>.<ul><li>Outputs 0 if <code>z &lt; 0</code>, outputs <code>z</code> if <code>z ≥ 0</code>.</li><li>Continuous, but not differentiable at <code>z=0</code> (slope changes abruptly). In practice, GD still works (can use a subgradient or just assume gradient is 0 or 1 at <code>z=0</code>).</li><li>Derivative is 0 for <code>z &lt; 0</code>.</li><li><strong>Advantages:</strong> Fast to compute. Has become the default in many cases. No maximum output value (helps with some GD issues like vanishing gradients, Ch 11).</li><li>The footnote on page 292 notes that ReLU, despite being less biologically plausible than sigmoids, often works better in ANNs – a case where the biological analogy can be misleading.</li></ul></li></ul></li></ul></li><li><p><strong>Why Activation Functions? (Page 292):</strong></p><ul><li>If you chain several <em>linear</em> transformations, all you get is another <em>linear</em> transformation.
<code>f(x) = 2x + 3</code>, <code>g(x) = 5x - 1</code> => <code>f(g(x)) = 2(5x - 1) + 3 = 10x + 1</code> (still linear).</li><li>If you have no <em>nonlinearity</em> between layers, even a deep stack of layers is equivalent to a single linear layer. It can&rsquo;t solve complex non-linear problems.</li><li><strong>Nonlinear activation functions are essential for giving ANNs the power to approximate complex, non-linear functions.</strong> A large enough DNN with nonlinear activations can theoretically approximate any continuous function.</li></ul></li></ul><h2 id=page-292-294-regression-and-classification-mlps>(Page 292-294: Regression and Classification MLPs)</h2><p>Now that we know the architecture and training algorithm (backpropagation), what can we do?</p><ul><li><p><strong>Regression MLPs (Page 292-293):</strong></p><ul><li><strong>Single value prediction (e.g., house price):</strong> Need a single output neuron.</li><li><strong>Multivariate regression (e.g., 2D coordinates for object center):</strong> One output neuron per output dimension. (4 output neurons if predicting bounding box: x, y, width, height).</li><li><strong>Output Layer Activation:</strong><ul><li>Usually <strong>no activation function</strong> for output neurons in regression (so they can output any range of values).</li><li>If output must be positive: Use ReLU or <strong>softplus</strong> (<code>log(1 + exp(z))</code>, a smooth ReLU variant).</li><li>If output must be in a specific range: Use logistic (for 0-1) or tanh (for -1 to 1) and scale labels accordingly.</li></ul></li><li><strong>Loss Function:</strong><ul><li>Typically <strong>MSE</strong>.</li><li>If many outliers: Prefer <strong>MAE</strong> or <strong>Huber loss</strong> (quadratic for small errors, linear for large errors – less sensitive to outliers than MSE but converges faster than MAE).</li></ul></li><li><strong>Table 10-1 (Typical Regression MLP Architecture):</strong> Summarizes typical choices for number of neurons, layers, activations, and loss.</li></ul></li><li><p><strong>Classification MLPs (Page 294):</strong></p><ul><li><strong>Binary classification:</strong> Single output neuron, <strong>logistic (sigmoid) activation function</strong>. Output is probability of positive class.</li><li><strong>Multilabel binary classification (e.g., email is spam/ham AND urgent/non-urgent):</strong><ul><li>One output neuron <em>per positive class label</em> (e.g., one for &ldquo;is spam,&rdquo; one for &ldquo;is urgent&rdquo;).</li><li>Each uses <strong>logistic activation</strong>.</li><li>Output probabilities don&rsquo;t necessarily sum to 1 (an email can be &ldquo;not spam&rdquo; and &ldquo;urgent&rdquo;).</li></ul></li><li><strong>Multiclass classification (mutually exclusive classes, e.g., digits 0-9):</strong><ul><li>One output neuron <em>per class</em>.</li><li>Use <strong>softmax activation function</strong> for the <em>whole output layer</em> (as in Chapter 4). This ensures probabilities are between 0-1 and sum to 1.</li><li><strong>Figure 10-9</strong> shows a modern MLP for classification (ReLU in hidden layers, softmax in output).</li></ul></li><li><strong>Loss Function:</strong><ul><li><strong>Cross-entropy loss</strong> (log loss, as in Chapter 4) is generally a good choice when predicting probability distributions.</li></ul></li><li><strong>Table 10-2 (Typical Classification MLP Architecture):</strong> Summarizes typical choices.</li></ul></li></ul><p>Phew! That&rsquo;s a dense introduction to the historical context, the biological inspiration (and divergence from it), the basic Perceptron, the jump to Multilayer Perceptrons, the crucial backpropagation algorithm, and how MLPs are structured for regression and classification.</p><p>The key takeaway is that MLPs are layered networks of simple processing units (neurons), where hidden layers learn increasingly complex representations of the input, enabled by non-linear activation functions and trained by backpropagation (Gradient Descent with efficient gradient calculation).</p><p>Excellent! That detour through &ldquo;The Matrix Calculus You Need For Deep Learning&rdquo; was intense but hopefully gave you a much deeper appreciation for what&rsquo;s happening when we say a neural network &ldquo;learns&rdquo; by minimizing a loss function using gradients. You now have a good intuitive (and even some mathematical) backing for how those weight and bias updates are calculated for individual neurons via the chain rule.</p><h2 id=page-295-306-implementing-mlps-with-keras>(Page 295-306: Implementing MLPs with Keras)</h2><p>This is where the practical fun begins! We&rsquo;ve talked a lot about the &ldquo;what&rdquo; and &ldquo;why&rdquo; of neural networks; now we get to the &ldquo;how&rdquo; of actually building and training them using a popular library.</p><ul><li><p><strong>Keras: A High-Level Deep Learning API (Page 295):</strong></p><ul><li>Keras allows you to easily build, train, evaluate, and run all sorts of neural networks.</li><li>It was developed by François Chollet and is known for its ease of use, flexibility, and beautiful design.</li><li><strong>Backend Reliance:</strong> Keras itself doesn&rsquo;t do the heavy numerical computations. It relies on a <strong>computation backend</strong>. Popular choices include:<ul><li>TensorFlow</li><li>Microsoft Cognitive Toolkit (CNTK)</li><li>Theano (though its development has largely ceased)</li></ul></li><li>The book refers to the original, multi-backend implementation as <strong>multibackend Keras</strong>.</li><li><strong>tf.keras:</strong> Since late 2016/2017, TensorFlow has bundled its own Keras implementation called <code>tf.keras</code>. This is what the book (and most of the community now) uses. It only supports TensorFlow as a backend but offers extra TensorFlow-specific features (like the Data API for efficient data loading, which we&rsquo;ll see later).</li><li>Figure 10-10 (page 296) illustrates these two Keras API implementations.</li></ul></li><li><p><strong>PyTorch (Page 296):</strong></p><ul><li>Another very popular Deep Learning library from Facebook.</li><li>Its API is quite similar to Keras (both inspired by Scikit-Learn and Chainer).</li><li>Gained immense popularity due to its simplicity and excellent documentation, especially compared to TensorFlow 1.x.</li><li>TensorFlow 2.x (which uses <code>tf.keras</code> as its official high-level API) has significantly improved, making it just as simple as PyTorch in many respects. Healthy competition is good!</li></ul></li><li><p><strong>Installing TensorFlow 2 (Page 296):</strong></p><ul><li>The book assumes you&rsquo;ve followed Chapter 2&rsquo;s setup for Jupyter and Scikit-Learn.</li><li>You&rsquo;d typically use <code>pip install -U tensorflow</code>.</li><li>The bird icon notes that for GPU support, you might need <code>tensorflow-gpu</code> and extra libraries (though this is evolving, and TensorFlow aims for a single library). Chapter 19 will cover GPUs.</li><li>Test installation by importing <code>tensorflow as tf</code> and <code>from tensorflow import keras</code>, then printing <code>tf.__version__</code> and <code>keras.__version__</code>.</li></ul></li></ul><p>Now, let&rsquo;s build an image classifier!</p><p><strong>Building an Image Classifier Using the Sequential API (Page 297-301)</strong></p><p>We&rsquo;ll use the <strong>Fashion MNIST</strong> dataset.</p><ul><li><p>A drop-in replacement for MNIST (introduced in Chapter 3).</p></li><li><p>Same format: 70,000 grayscale images of 28x28 pixels, 10 classes.</p></li><li><p>Images are fashion items (T-shirt, trouser, coat, etc.) instead of handwritten digits.</p></li><li><p>More challenging than MNIST (e.g., a simple linear model gets ~92% on MNIST but only ~83% on Fashion MNIST).</p></li><li><p><strong>Using Keras to Load the Dataset (Page 297):</strong>
<code>fashion_mnist = keras.datasets.fashion_mnist</code>
<code>(X_train_full, y_train_full), (X_test, y_test) = fashion_mnist.load_data()</code></p><ul><li>Difference from Scikit-Learn&rsquo;s <code>fetch_openml</code> for MNIST:<ul><li>Images are 28x28 arrays (not flattened 784-element vectors).</li><li>Pixel intensities are integers (0-255), not floats.</li></ul></li><li><code>X_train_full.shape</code> is <code>(60000, 28, 28)</code>.</li></ul></li><li><p><strong>Data Preparation (Page 298):</strong></p><ol><li><strong>Create a validation set:</strong> The loaded data is split into train and test only. We need a validation set for monitoring training and hyperparameter tuning.
<code>X_valid, X_train = X_train_full[:5000], X_train_full[5000:]</code>
<code>y_valid, y_train = y_train_full[:5000], y_train_full[5000:]</code>
(First 5000 instances for validation, rest for training).</li><li><strong>Scale input features:</strong> Neural networks with Gradient Descent require feature scaling. We&rsquo;ll scale pixel intensities from 0-255 down to the 0-1 range by dividing by 255.0 (this also converts them to floats).
<code>X_valid, X_train = X_valid / 255.0, X_train / 255.0</code>
(Note: It&rsquo;s generally better to scale the test set using parameters derived from the training set, e.g., <code>(X_test - X_train_mean) / X_train_std</code>. But for pixel values 0-255, dividing by 255.0 is a common and simple approach.)</li></ol><ul><li><strong>Class Names:</strong> For Fashion MNIST, labels are numbers (0-9). We need a list of class names to interpret them:
<code>class_names = ["T-shirt/top", "Trouser", ..., "Ankle boot"]</code>
<code>class_names[y_train[0]]</code> might give <code>'Coat'</code>.</li><li>Figure 10-11 shows sample images from Fashion MNIST.</li></ul></li><li><p><strong>Creating the Model Using the Sequential API (Page 299):</strong>
This is the simplest way to build a Keras model: a linear stack of layers.
We&rsquo;ll build a classification MLP with two hidden layers.</p><p><code>model = keras.models.Sequential()</code>
<code>model.add(keras.layers.Flatten(input_shape=[28, 28]))</code>
<code>model.add(keras.layers.Dense(300, activation="relu"))</code>
<code>model.add(keras.layers.Dense(100, activation="relu"))</code>
<code>model.add(keras.layers.Dense(10, activation="softmax"))</code></p><p>Let&rsquo;s break this down:</p><ol><li><code>model = keras.models.Sequential()</code>: Creates a Sequential model, which is just a stack of layers.</li><li><code>model.add(keras.layers.Flatten(input_shape=[28, 28]))</code>:<ul><li>This is the <strong>first layer</strong>. Its role is to take each input image (28x28 array) and <strong>flatten</strong> it into a 1D array (of 784 pixels). <code>X.reshape(-1, 1)</code> was mentioned, but a common operation in NNs is <code>X.reshape(batch_size, -1)</code>. Keras Flatten layer handles this conversion.</li><li>It has no parameters to learn; it&rsquo;s just a preprocessing step.</li><li><code>input_shape=[28, 28]</code>: Since it&rsquo;s the first layer, you <em>must</em> specify the shape of the input instances (excluding the batch size).</li></ul></li><li><code>model.add(keras.layers.Dense(300, activation="relu"))</code>:<ul><li>Adds a <strong>Dense (fully connected) hidden layer</strong> with 300 neurons.</li><li><code>activation="relu"</code>: Specifies the ReLU activation function for these neurons.</li><li>Each <code>Dense</code> layer manages its own weight matrix (<code>W</code>) and bias vector (<code>b</code>). When it receives input, it computes <code>XW + b</code> (Equation 10-2 from the book).</li></ul></li><li><code>model.add(keras.layers.Dense(100, activation="relu"))</code>:<ul><li>Adds a second Dense hidden layer with 100 neurons, also using ReLU.</li></ul></li><li><code>model.add(keras.layers.Dense(10, activation="softmax"))</code>:<ul><li>Adds a Dense <strong>output layer</strong> with 10 neurons (one for each class, 0-9).</li><li><code>activation="softmax"</code>: Uses the softmax activation function because the classes are exclusive (an item belongs to only one class). Softmax will ensure the outputs are probabilities that sum to 1.</li></ul></li></ol><ul><li><strong>Alternative Sequential Model Creation (Page 300):</strong>
You can also pass a list of layers directly to the <code>Sequential</code> constructor:
<code>model = keras.models.Sequential([</code>
<code>keras.layers.Flatten(input_shape=[28, 28]),</code>
<code>keras.layers.Dense(300, activation="relu"),</code>
<code>keras.layers.Dense(100, activation="relu"),</code>
<code>keras.layers.Dense(10, activation="softmax")</code>
<code>])</code></li></ul></li><li><p><strong>Model Summary (Page 300-301):</strong>
<code>model.summary()</code> displays all the model&rsquo;s layers:</p><ul><li>Layer name (auto-generated or custom).</li><li>Output shape (<code>None</code> for batch size means it can be anything).</li><li>Number of parameters.</li><li><code>Flatten</code>: Output shape <code>(None, 784)</code>, 0 params.</li><li><code>dense</code> (first hidden layer): Output <code>(None, 300)</code>. Params: <code>(784 inputs * 300 neurons) + 300 biases = 235,200 + 300 = 235,500</code>.</li><li><code>dense_1</code> (second hidden): Output <code>(None, 100)</code>. Params: <code>(300 inputs * 100 neurons) + 100 biases = 30,000 + 100 = 30,100</code>.</li><li><code>dense_2</code> (output): Output <code>(None, 10)</code>. Params: <code>(100 inputs * 10 neurons) + 10 biases = 1,000 + 10 = 1,010</code>.</li><li>Total params: 266,610. All are trainable.</li><li>This gives the model a lot of flexibility but also risks overfitting if data is scarce.</li></ul></li><li><p><strong>Accessing Layers and Weights (Page 301):</strong></p><ul><li><code>model.layers</code> gives a list of layers.</li><li><code>hidden1 = model.layers[1]</code></li><li><code>hidden1.name</code></li><li><code>model.get_layer('dense')</code> (if name is &lsquo;dense&rsquo;)</li><li><code>weights, biases = hidden1.get_weights()</code> gets the layer&rsquo;s parameters.<ul><li>Weights are initialized randomly (to break symmetry for backpropagation).</li><li>Biases are initialized to zeros (which is fine).</li></ul></li><li>You can set custom initializers for weights (<code>kernel_initializer</code>) or biases (<code>bias_initializer</code>) when creating the layer. (More in Ch 11).</li></ul></li><li><p><strong>When <code>input_shape</code> is Determined (Bird Icon, page 302):</strong>
It&rsquo;s best to specify <code>input_shape</code> for the first layer. If you don&rsquo;t, Keras waits until it sees actual data (e.g., during <code>fit()</code>) or until you call <code>model.build()</code> to build the layers (i.e., create their weights). Before that, layers won&rsquo;t have weights, and <code>model.summary()</code> or saving the model might not work.</p></li></ul><h2 id=page-302-306-compiling-training-evaluating-and-predicting>(Page 302-306: Compiling, Training, Evaluating, and Predicting)</h2><ul><li><p><strong>Compiling the Model (Page 302):</strong>
After creating the model, you <em>must</em> call <code>compile()</code> to specify:</p><ol><li><strong>Loss function</strong></li><li><strong>Optimizer</strong></li><li>Optionally, extra <strong>metrics</strong> to compute during training/evaluation.</li></ol><p><code>model.compile(loss="sparse_categorical_crossentropy",</code>
<code>optimizer="sgd",</code>
<code>metrics=["accuracy"])</code></p><ul><li><strong><code>loss="sparse_categorical_crossentropy"</code>:</strong><ul><li>We use this because our labels (<code>y_train</code>) are &ldquo;sparse&rdquo; – just target class indices (0 to 9).</li><li>And the classes are exclusive.</li><li>If labels were one-hot encoded (e.g., class 3 is <code>[0,0,0,1,0,0,0,0,0,0]</code>), we&rsquo;d use <code>loss="categorical_crossentropy"</code>.</li><li>If binary classification (output layer with sigmoid), we&rsquo;d use <code>loss="binary_crossentropy"</code>.</li><li>The bird icon (page 302) notes you can use full Keras objects too: <code>loss=keras.losses.sparse_categorical_crossentropy</code>.</li></ul></li><li><strong><code>optimizer="sgd"</code>:</strong><ul><li>This means use simple Stochastic Gradient Descent. Keras will perform backpropagation (reverse-mode autodiff + Gradient Descent).</li><li>More advanced optimizers in Chapter 11.</li><li><strong>Important (bird icon, page 303):</strong> For SGD, tuning the learning rate is crucial. You&rsquo;d typically use <code>optimizer=keras.optimizers.SGD(learning_rate=...)</code> instead of the string <code>"sgd"</code> (which defaults to <code>lr=0.01</code>).</li></ul></li><li><strong><code>metrics=["accuracy"]</code>:</strong><ul><li>Since it&rsquo;s a classifier, we want to track accuracy during training and evaluation.</li></ul></li></ul></li><li><p><strong>Training and Evaluating the Model (Page 303-304):</strong>
Call <code>fit()</code>:
<code>history = model.fit(X_train, y_train, epochs=30,</code>
<code>validation_data=(X_valid, y_valid))</code></p><ul><li>Pass input features (<code>X_train</code>) and target classes (<code>y_train</code>).</li><li><code>epochs=30</code>: Number of times to iterate over the entire training dataset. (Defaults to 1, which is usually not enough).</li><li><code>validation_data=(X_valid, y_valid)</code>: Optional. Keras will measure loss and metrics on this validation set at the end of each epoch. Very useful to see how well the model is generalizing and to detect overfitting.</li><li><strong>Output during training:</strong> For each epoch, Keras displays:<ul><li>Progress bar.</li><li>Mean training time per sample.</li><li>Loss and accuracy on the training set (average over the epoch).</li><li>Loss and accuracy on the validation set (at the end of the epoch).</li></ul></li><li>The example output shows training loss decreasing and validation accuracy reaching ~89% after 30 epochs. Training and validation accuracy are close, so not much overfitting.</li><li>The bird icon (page 304) mentions <code>validation_split=0.1</code> as an alternative to <code>validation_data</code>, to use the last 10% of training data for validation (before shuffling).</li><li>Also mentions <code>class_weight</code> (to give more importance to underrepresented classes) and <code>sample_weight</code> (for per-instance weighting) arguments in <code>fit()</code>.</li></ul></li><li><p><strong>Learning Curves (Page 304-305):</strong></p><ul><li><code>fit()</code> returns a <code>History</code> object. <code>history.history</code> is a dictionary containing the loss and metrics measured at the end of each epoch (e.g., <code>loss</code>, <code>accuracy</code>, <code>val_loss</code>, <code>val_accuracy</code>).</li><li>You can use this to plot learning curves with pandas and Matplotlib (Figure 10-12, page 305).<figure><img src=/bookshelf/hands-on-ml/ch-10-fig-10-12.png alt="Figure 10-12. Learning curves: the mean training loss and accuracy measured over each epoch, and the mean validation loss and accuracy measured at the end of each epoch" width=700></figure></li><li>The plot shows training/validation accuracy increasing and loss decreasing. Validation curves are close to training curves, confirming little overfitting.</li><li>The book notes that validation metrics are computed at the <em>end</em> of an epoch, while training metrics are a running mean <em>during</em> the epoch. So, for a fair comparison, the training curve should be shifted left by half an epoch.</li></ul></li><li><p><strong>Further Training and Hyperparameter Tuning (Page 306):</strong></p><ul><li>If validation loss is still decreasing (as in the example), the model hasn&rsquo;t fully converged. You can call <code>fit()</code> again; Keras continues training from where it left off.</li><li>If not satisfied, tune hyperparameters:<ul><li>Learning rate (most important first check).</li><li>Try another optimizer (and retune learning rate).</li><li>Number of layers, neurons per layer, activation functions.</li><li>Batch size (in <code>fit()</code>, defaults to 32).</li></ul></li></ul></li><li><p><strong>Evaluating on the Test Set (Page 306):</strong></p><ul><li>Once satisfied with validation accuracy, evaluate on the <em>test set</em> to estimate generalization error.
<code>model.evaluate(X_test, y_test)</code>
Returns <code>[loss, accuracy]</code>. Example gives ~88.5% accuracy.</li><li>Common to get slightly lower performance on test set than validation (since HPs tuned on validation). <strong>Resist tweaking HPs based on test set results!</strong></li></ul></li><li><p><strong>Using the Model to Make Predictions (Page 206-207):</strong>
<code>predict()</code> method for new instances.
<code>X_new = X_test[:3]</code>
<code>y_proba = model.predict(X_new)</code></p><ul><li><code>y_proba</code> contains one probability per class for each instance (from the softmax output layer). Example: <code>[[0. , ..., 0.03, ..., 0.96], ...]</code> for the first image (96% prob for class 9 &lsquo;Ankle boot&rsquo;, 3% for class 5 &lsquo;Sandal&rsquo;).</li><li>To get the class with the highest probability:
<code>y_pred = model.predict_classes(X_new)</code> (Note: <code>predict_classes</code> is deprecated in newer TensorFlow/Keras; use <code>np.argmax(model.predict(X_new), axis=-1)</code> instead).
This might give <code>array([9, 2, 1])</code>.</li><li>Figure 10-13 (page 307) shows these three test images, which were correctly classified.</li></ul></li></ul><p>That&rsquo;s a complete walkthrough of building, training, and using a classification MLP with Keras&rsquo;s Sequential API! The process is quite streamlined.</p><p>Great! It&rsquo;s satisfying to see how those theoretical concepts translate into a working Keras model.</p><p>Let&rsquo;s continue with <strong>Chapter 10</strong>, moving on to how we&rsquo;d build a regression MLP with Keras and then explore more advanced ways to define model architectures.</p><h2 id=page-307-308-building-a-regression-mlp-using-the-sequential-api>(Page 307-308: Building a Regression MLP Using the Sequential API)</h2><p>We&rsquo;ve just built an image <em>classifier</em>. Now, let&rsquo;s switch to a <em>regression</em> task: predicting California housing prices, similar to what we did in Chapter 2, but this time with a neural network.</p><ul><li><p><strong>Loading the Data:</strong></p><ul><li><p>For simplicity, the book uses Scikit-Learn&rsquo;s <code>fetch_california_housing()</code> to load the data.</p></li><li><p>This version is simpler than the one in Chapter 2: only numerical features, no missing values.</p></li><li><p>Standard train-validation-test split and feature scaling (using <code>StandardScaler</code>) are performed as usual.
<code>from sklearn.datasets import fetch_california_housing</code>
<code>from sklearn.model_selection import train_test_split</code>
<code>from sklearn.preprocessing import StandardScaler</code></p><p><code>housing = fetch_california_housing()</code>
<code>X_train_full, X_test, y_train_full, y_test = train_test_split(housing.data, housing.target)</code>
<code>X_train, X_valid, y_train, y_valid = train_test_split(X_train_full, y_train_full)</code></p><p><code>scaler = StandardScaler()</code>
<code>X_train = scaler.fit_transform(X_train)</code>
<code>X_valid = scaler.transform(X_valid)</code>
<code>X_test = scaler.transform(X_test)</code></p></li></ul></li><li><p><strong>Building the Regression MLP (Page 308):</strong>
The process is very similar to the classification MLP, with a few key differences:</p><p><code>model = keras.models.Sequential([</code>
<code>keras.layers.Dense(30, activation="relu", input_shape=X_train.shape[1:]),</code>
<code>keras.layers.Dense(1) # Output layer</code>
<code>])</code></p><ul><li><strong>Output Layer:</strong><ul><li>Has a <strong>single neuron</strong> (because we&rsquo;re predicting a single value – the housing price).</li><li>Uses <strong>no activation function</strong> (or you could say a &ldquo;linear&rdquo; activation <code>activation=None</code>). This allows the output neuron to produce any range of values, which is what we want for regression. (Recall for classification we used <code>softmax</code> or <code>sigmoid</code>).</li></ul></li><li><strong>Hidden Layer:</strong> The example uses a single hidden layer with 30 neurons and ReLU activation. The book mentions using fewer neurons and a shallower network because the dataset is quite noisy, to avoid overfitting. <code>input_shape=X_train.shape[1:]</code> correctly sets the input dimension based on the number of features in <code>X_train</code>.</li><li><em>What this architecture is ultimately trying to achieve:</em> The hidden layer learns complex combinations of the input features, and the final output neuron combines these learned features linearly to produce the price prediction.</li></ul></li><li><p><strong>Compiling the Model:</strong>
<code>model.compile(loss="mean_squared_error", optimizer="sgd")</code></p><ul><li><strong>Loss Function:</strong> <code>loss="mean_squared_error"</code> (or <code>keras.losses.mean_squared_error</code>). This is standard for regression.</li><li><strong>Optimizer:</strong> <code>"sgd"</code> (again, you&rsquo;d likely want to specify <code>keras.optimizers.SGD(learning_rate=...)</code> for tuning).</li><li><strong>Metrics:</strong> For regression, common metrics might be MAE (Mean Absolute Error) if MSE is the loss, or just watching the loss itself. Accuracy isn&rsquo;t used for regression.</li></ul></li><li><p><strong>Training, Evaluating, Predicting:</strong>
These steps are identical to the classification MLP:
<code>history = model.fit(X_train, y_train, epochs=20, validation_data=(X_valid, y_valid))</code>
<code>mse_test = model.evaluate(X_test, y_test)</code>
<code>y_pred = model.predict(X_new)</code></p><p>The core workflow with the Sequential API is consistent. The main changes for regression are the <strong>structure of the output layer (number of neurons, no activation)</strong> and the <strong>choice of loss function (MSE)</strong>.</p></li></ul><h2 id=page-308-312-building-complex-models-using-the-functional-api>(Page 308-312: Building Complex Models Using the Functional API)</h2><p>The Sequential API is easy to use for simple stacks of layers. However, sometimes you need to build neural networks with more complex topologies:</p><ul><li>Multiple inputs.</li><li>Multiple outputs.</li><li>Layers that branch off and then merge back.</li></ul><p>For these, Keras offers the <strong>Functional API</strong>.</p><ul><li><p><strong>Wide & Deep Neural Network (Example Architecture - Page 308, Figure 10-14):</strong></p><ul><li>Introduced in a 2016 paper by Google for recommender systems.</li><li><strong>The Idea:</strong> Combine the strengths of deep learning (learning complex patterns through a &ldquo;deep path&rdquo; of stacked layers) with the ability to learn simple rules (through a &ldquo;wide path&rdquo; where inputs connect directly, or via a shallow path, to the output).</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> Prevent simple, easily learnable patterns in the data from being distorted or lost by forcing them through many layers of transformations. It allows the network to memorize simple rules while also discovering intricate patterns.</li></ul></li><li><p><strong>Building a Wide & Deep Network with the Functional API (Page 309):</strong>
Let&rsquo;s tackle the California housing problem with this architecture.
<code>input_ = keras.layers.Input(shape=X_train.shape[1:])</code>
<code>hidden1 = keras.layers.Dense(30, activation="relu")(input_)</code>
<code>hidden2 = keras.layers.Dense(30, activation="relu")(hidden1)</code>
<code>concat = keras.layers.Concatenate()([input_, hidden2])</code>
<code>output = keras.layers.Dense(1)(concat)</code>
<code>model = keras.Model(inputs=[input_], outputs=[output])</code></p><p>Let&rsquo;s break this down step-by-step:</p><ol><li><code>input_ = keras.layers.Input(shape=X_train.shape[1:])</code>:<ul><li>This creates an <code>Input</code> object (a symbolic tensor). It defines the <em>shape</em> and <code>dtype</code> of the input the model will receive. This is like declaring the entry point for your data.</li></ul></li><li><code>hidden1 = keras.layers.Dense(30, activation="relu")(input_)</code>:<ul><li>We create a <code>Dense</code> layer.</li><li>Then, we <em>call it like a function</em>, passing it the <code>input_</code> object. This connects <code>input_</code> to <code>hidden1</code>. <code>hidden1</code> now represents the symbolic output of this layer.</li><li>This &ldquo;calling a layer on a tensor&rdquo; is the essence of the Functional API. You are defining how layers connect. No actual data is processed yet.</li></ul></li><li><code>hidden2 = keras.layers.Dense(30, activation="relu")(hidden1)</code>:<ul><li>Create another <code>Dense</code> layer and connect it to the output of <code>hidden1</code>.</li></ul></li><li><code>concat = keras.layers.Concatenate()([input_, hidden2])</code>:<ul><li>Create a <code>Concatenate</code> layer.</li><li>Call it with a <em>list</em> of tensors you want to concatenate: the original <code>input_</code> (this is the &ldquo;wide&rdquo; path) and the output of <code>hidden2</code> (the &ldquo;deep&rdquo; path). <code>concat</code> is now the symbolic concatenated tensor.</li></ul></li><li><code>output = keras.layers.Dense(1)(concat)</code>:<ul><li>Create the output <code>Dense</code> layer (single neuron, no activation for regression) and connect it to the <code>concat</code> layer.</li></ul></li><li><code>model = keras.Model(inputs=[input_], outputs=[output])</code>:<ul><li>Finally, create the <code>Model</code> object by specifying its inputs and outputs. Keras then figures out the graph of layers.</li></ul></li></ol><p>Once this model is built, <code>compile()</code>, <code>fit()</code>, <code>evaluate()</code>, and <code>predict()</code> work exactly the same as with the Sequential API.</p></li><li><p><strong>Handling Multiple Inputs (Figure 10-15, page 310):</strong>
What if you want to send different subsets of features through the wide and deep paths?</p><ul><li><p>Define <strong>multiple <code>Input</code> objects</strong>:
<code>input_A = keras.layers.Input(shape=[5], name="wide_input")</code> (e.g., features 0-4)
<code>input_B = keras.layers.Input(shape=[6], name="deep_input")</code> (e.g., features 2-7, notice overlap is possible)</p></li><li><p>Build the paths:
<code>hidden1 = keras.layers.Dense(30, activation="relu")(input_B)</code>
<code>hidden2 = keras.layers.Dense(30, activation="relu")(hidden1)</code></p></li><li><p>Concatenate:
<code>concat = keras.layers.concatenate([input_A, hidden2])</code> (using the functional form <code>concatenate()</code> which creates and calls the layer in one step).</p></li><li><p>Output:
<code>output = keras.layers.Dense(1, name="output")(concat)</code></p></li><li><p>Create the model, specifying multiple inputs:
<code>model = keras.Model(inputs=[input_A, input_B], outputs=[output])</code></p></li><li><p><strong>Training with Multiple Inputs (Page 311):</strong>
When calling <code>fit()</code>, <code>evaluate()</code>, or <code>predict()</code>, you must pass data for each input.</p><ul><li>If inputs are ordered in the <code>inputs</code> list of <code>keras.Model</code>, you pass a tuple/list of NumPy arrays:
<code>model.fit((X_train_A, X_train_B), y_train, ...)</code>
Where <code>X_train_A</code> would be <code>X_train[:, :5]</code> and <code>X_train_B</code> would be <code>X_train[:, 2:]</code>.</li><li>Alternatively (and often better if many inputs), you can pass a dictionary mapping input names (defined in <code>keras.layers.Input(name=...)</code>) to the data arrays:
<code>model.fit({"wide_input": X_train_A, "deep_input": X_train_B}, y_train, ...)</code></li></ul></li></ul></li><li><p><strong>Handling Multiple Outputs (Figure 10-16, page 312):</strong>
Sometimes a task demands multiple outputs, or it&rsquo;s useful for regularization.</p><ul><li>Example: Adding an <strong>auxiliary output</strong> deeper in the network (e.g., from <code>hidden2</code>). This can encourage the main network to learn useful features earlier on, as this auxiliary output also contributes to the loss.
<code>[...] # Up to hidden2</code>
<code>output = keras.layers.Dense(1, name="main_output")(concat)</code>
<code>aux_output = keras.layers.Dense(1, name="aux_output")(hidden2)</code>
<code>model = keras.Model(inputs=[input_A, input_B], outputs=[output, aux_output])</code></li><li><strong>Compiling with Multiple Outputs/Losses (Page 312):</strong><ul><li>Each output needs its own loss function. You can pass a list of losses:
<code>model.compile(loss=["mse", "mse"], optimizer="sgd", ...)</code></li><li>You can also specify <code>loss_weights</code> to give different importance to each loss:
<code>model.compile(loss=["mse", "mse"], loss_weights=[0.9, 0.1], optimizer="sgd")</code>
Here, the main output&rsquo;s loss contributes 90% to the total loss, and the auxiliary output&rsquo;s loss contributes 10%.
(You can also pass dictionaries for <code>loss</code> and <code>loss_weights</code> mapping output names to values).</li></ul></li><li><strong>Training with Multiple Outputs/Labels:</strong>
You need to provide labels for each output during <code>fit()</code>:
<code>model.fit([X_train_A, X_train_B], [y_train, y_train], ...)</code>
(If the main and aux outputs predict the same thing, you can pass <code>y_train</code> twice).</li><li><strong>Evaluating with Multiple Outputs:</strong>
<code>model.evaluate(...)</code> will return the total loss, as well as the individual losses for each output.</li><li><strong>Predicting with Multiple Outputs:</strong>
<code>model.predict(...)</code> will return predictions for each output.</li></ul></li></ul><p>The Functional API is very powerful for creating custom, non-sequential network architectures!</p><p>Excellent! Let&rsquo;s proceed with that plan.</p><p>We&rsquo;ve covered the foundational concepts of Artificial Neural Networks, including their structure (Perceptrons, MLPs), how they learn (the idea of backpropagation and gradient descent), and how they are designed for regression and classification.</p><h2 id=page-320-327-fine-tuning-neural-network-hyperparameters>(Page 320-327: Fine-Tuning Neural Network Hyperparameters)</h2><p>This section is critical because, as the book states, &ldquo;The flexibility of neural networks is also one of their main drawbacks: there are many hyperparameters to tweak.&rdquo;</p><ul><li><em>What we are ultimately trying to achieve with hyperparameter tuning:</em> We want to find the specific configuration of the network&rsquo;s architecture and training process that allows it to learn the underlying patterns in our data effectively and generalize well to new, unseen data, without overfitting or underfitting.</li></ul><p>Even in a simple MLP, you can change:</p><ul><li>Number of hidden layers.</li><li>Number of neurons per hidden layer.</li><li>Type of activation function for each layer.</li><li>Weight initialization logic.</li><li>Optimizer and its specific parameters (like learning rate).</li><li>Batch size.</li><li>Regularization techniques and their strengths.
And many more! How do you find the best combination?</li></ul><p><strong>General Strategies for Hyperparameter Tuning (Page 320):</strong></p><ol><li><strong>Trial and Error (Guided by Best Practices):</strong> Try many combinations and see which performs best on a validation set (or using K-fold cross-validation).</li><li><strong>Automated Hyperparameter Optimization:</strong><ul><li>Tools like Scikit-Learn&rsquo;s <code>GridSearchCV</code> or <code>RandomizedSearchCV</code> can be used. To do this with Keras models, you need to wrap your Keras model in an object that mimics a Scikit-Learn regressor/classifier. The book shows how to create a <code>build_model</code> function that Keras-wrapping classes (like <code>KerasRegressor</code> or <code>KerasClassifier</code> from <code>tf.keras.wrappers.scikit_learn</code> or a similar older Keras utility) can use.</li><li>The <code>build_model</code> function would take hyperparameters as arguments (e.g., <code>n_hidden</code>, <code>n_neurons</code>, <code>learning_rate</code>) and return a compiled Keras model.</li><li><code>RandomizedSearchCV</code> is often preferred over <code>GridSearchCV</code> when there are many hyperparameters, as it explores the space more efficiently.</li><li>The book provides an example of setting up <code>param_distribs</code> for <code>n_hidden</code>, <code>n_neurons</code>, and <code>learning_rate</code> to use with <code>RandomizedSearchCV</code>.</li></ul></li></ol><ul><li><strong>Challenges with Automated Search for NNs (Page 321-322):</strong><ul><li>Training NNs can be slow, especially with large datasets or complex models. Exploring a large hyperparameter space can take many hours or days.</li><li><strong>Manual Assistance:</strong> You can guide the search: start with a wide random search, then do a finer search around the best values found. This is time-consuming.</li><li><strong>More Efficient Search Techniques:</strong> The core idea is that when a region of the hyperparameter space looks promising, it should be explored more. Libraries that help with this (beyond simple random search or grid search):<ul><li><strong>Hyperopt:</strong> Optimizes over complex search spaces (real, discrete values).</li><li><strong>Hyperas, kopt, Talos:</strong> Based on Hyperopt, specifically for Keras.</li><li><strong>Keras Tuner:</strong> Easy-to-use library from Google for Keras models, with visualization.</li><li><strong>Scikit-Optimize (skopt):</strong> General-purpose, <code>BayesSearchCV</code> class uses Bayesian optimization.</li><li><strong>Spearmint:</strong> Bayesian optimization library.</li><li><strong>Hyperband:</strong> Fast tuning based on a novel bandit-based approach.</li><li><strong>Sklearn-Deap:</strong> Uses evolutionary algorithms.</li></ul></li><li>Many cloud providers (like Google Cloud AI Platform) also offer hyperparameter tuning services.</li><li><strong>Evolutionary Algorithms & AutoML (Page 323):</strong> Research is active in using evolutionary approaches not just for hyperparameters but also for finding the best network <em>architecture</em> itself (AutoML). Even training individual NNs with evolutionary algorithms instead of Gradient Descent is being explored (e.g., Uber&rsquo;s Deep Neuroevolution).</li></ul></li></ul><p><strong>Guidelines for Choosing Key Hyperparameters (Page 323-327):</strong></p><p>Even with advanced tuning tools, having some intuition about reasonable starting values and search ranges is very helpful.</p><ol><li><p><strong>Number of Hidden Layers (Page 323-324):</strong></p><ul><li><strong>Start Simple:</strong> For many problems, you can begin with just <strong>one or two hidden layers</strong> and get reasonable results.<ul><li>An MLP with one hidden layer can theoretically model even very complex functions, <em>if it has enough neurons</em>.</li></ul></li><li><strong>Parameter Efficiency of Deep Networks:</strong> For complex problems, <strong>deep networks (more layers) have much higher parameter efficiency than shallow ones.</strong> They can model complex functions using exponentially <em>fewer neurons</em> than a shallow net would need to achieve similar performance. This means they can often reach better performance with the same amount of training data.</li><li><strong>Hierarchical Structure of Real-World Data:</strong> Deep networks naturally take advantage of hierarchical structures in data.<ul><li>Lower hidden layers tend to learn low-level structures (e.g., edges, simple shapes in images).</li><li>Intermediate hidden layers combine these to model intermediate-level structures (e.g., eyes, noses, squares, circles).</li><li>Highest hidden layers and the output layer combine these to model high-level structures (e.g., faces, specific objects).</li><li>This hierarchical learning helps DNNs converge faster and generalize better.</li></ul></li><li><strong>Transfer Learning:</strong> This hierarchical nature enables <strong>transfer learning</strong>. If you&rsquo;ve trained a network to recognize faces, you can reuse its lower layers (which learned general visual features) to kickstart training for a new, related task like recognizing hairstyles. The new network doesn&rsquo;t have to learn low-level features from scratch. (More in Chapter 11).</li><li><strong>General Guideline:</strong><ul><li>Start with 1-2 hidden layers.</li><li>For more complex problems, gradually ramp up the number of hidden layers until you start overfitting the training set, then use regularization techniques (like early stopping, dropout, etc., which we&rsquo;ll see more of).</li><li>Very complex tasks (large image classification, speech recognition) might need dozens of layers (but often specialized architectures like CNNs, not fully connected MLPs).</li><li>You&rsquo;ll rarely train huge networks from scratch; usually, you&rsquo;ll reuse parts of a pretrained state-of-the-art network (transfer learning).</li></ul></li></ul></li><li><p><strong>Number of Neurons per Hidden Layer (Page 324-325):</strong></p><ul><li><strong>Input/Output Layers:</strong> Determined by your task (number of input features, number of output classes/values).</li><li><strong>Hidden Layers:</strong><ul><li><strong>Old Practice (Pyramid):</strong> Fewer neurons in higher layers (e.g., 300 -> 200 -> 100). Rationale: many low-level features coalesce into fewer high-level features. Largely abandoned.</li><li><strong>Current Practice:</strong> Using the <strong>same number of neurons in all hidden layers</strong> often performs just as well or better, and it&rsquo;s simpler (only one hyperparameter for neuron count per layer, instead of one per layer).</li><li>Sometimes, making the first hidden layer larger than subsequent ones can be beneficial, depending on the dataset.</li><li><strong>&ldquo;Stretch Pants&rdquo; Approach (Vincent Vanhoucke):</strong> It&rsquo;s often simpler and more efficient to pick a model with <em>more layers and neurons than you actually need</em>, and then use <strong>early stopping</strong> and other <strong>regularization techniques</strong> to prevent it from overfitting. This is like buying large stretch pants that shrink to the right size.<ul><li>This avoids creating &ldquo;bottleneck&rdquo; layers (layers with too few neurons) that might lose important information from the inputs. Once information is lost by a bottleneck, subsequent larger layers cannot recover it.</li></ul></li><li><strong>More Bang for Your Buck (Scorpion Icon, page 325):</strong> In general, you&rsquo;ll get better performance improvements by increasing the <em>number of layers</em> rather than just the number of neurons in a single layer.</li></ul></li></ul></li><li><p><strong>Learning Rate (Page 325):</strong></p><ul><li>Arguably the <strong>most important hyperparameter</strong>.</li><li><strong>Optimal Learning Rate:</strong> Often about half of the maximum learning rate (the rate above which training diverges).</li><li><strong>Finding a Good Learning Rate:</strong><ol><li>Train the model for a few hundred iterations.</li><li>Start with a very low learning rate (e.g., 10⁻⁵).</li><li>Gradually increase it exponentially up to a very large value (e.g., 10 or 100).</li><li>Plot the loss as a function of the learning rate (use a log scale for the learning rate axis).</li><li>The loss will typically drop, then flatten, then shoot back up.</li><li>The optimal learning rate is usually a bit lower (e.g., 10 times lower) than the point where the loss starts to climb.
(More techniques for learning rate schedules in Chapter 11).</li></ol></li></ul></li><li><p><strong>Optimizer (Page 326):</strong></p><ul><li>Choosing a better optimizer than plain Mini-batch Gradient Descent (and tuning its specific hyperparameters) is also very important. (Advanced optimizers like Adam, RMSprop, etc., will be covered in Chapter 11).</li></ul></li><li><p><strong>Batch Size (Page 326):</strong></p><ul><li>Can significantly impact model performance and training time.</li><li><strong>Large Batch Sizes:</strong><ul><li>Benefit: Hardware accelerators (GPUs) can process them efficiently, leading to more instances seen per second.</li><li>Catch: Often lead to training instabilities (especially at the start), and the resulting model <em>may not generalize as well</em> as one trained with a small batch size.</li></ul></li><li><strong>Small Batch Sizes (e.g., 2 to 32):</strong><ul><li>A 2018 paper (Masters and Luschi) concluded these were often preferable, leading to better models in less training time. Yann LeCun famously tweeted &ldquo;Friends don&rsquo;t let friends use mini-batches larger than 32.&rdquo;</li></ul></li><li><strong>The Counter-Argument (Very Large Batches):</strong><ul><li>Other research (Hoffer et al. 2017, Goyal et al. 2017) showed it&rsquo;s possible to use very large batch sizes (up to 8,192) effectively with techniques like <strong>learning rate warmup</strong> (start with a small learning rate, then ramp it up). This can lead to very short training times without a generalization gap.</li></ul></li><li><strong>Practical Strategy:</strong><ol><li>Try using a large batch size with learning rate warmup.</li><li>If training is unstable or final performance is disappointing, then try using a small batch size.</li></ol></li></ul></li><li><p><strong>Activation Function (Page 326):</strong></p><ul><li><strong>Hidden Layers:</strong> In general, <strong>ReLU</strong> is a good default. (SELU and other variants will be discussed in Chapter 11).</li><li><strong>Output Layer:</strong> Depends entirely on your task:<ul><li>Regression (unbounded): None (linear).</li><li>Regression (positive output): ReLU or softplus.</li><li>Regression (output in a specific range, e.g., 0-1): Logistic (sigmoid) or tanh (for -1 to 1), and scale labels accordingly.</li><li>Binary Classification: Logistic (sigmoid).</li><li>Multiclass Classification (exclusive classes): Softmax.</li></ul></li></ul></li><li><p><strong>Number of Iterations (Epochs) (Page 327):</strong></p><ul><li>In most cases, this doesn&rsquo;t actually need to be tweaked directly.</li><li><strong>Just use early stopping instead.</strong> Set a large number of epochs and let early stopping find the optimal point.</li></ul></li></ol><ul><li><p><strong>Important Note on Interacting Hyperparameters (Bird Icon, page 327):</strong>
The optimal learning rate often depends on other hyperparameters, especially the <strong>batch size</strong>. If you modify any hyperparameter, make sure to re-evaluate/retune the learning rate.</p></li><li><p><strong>Further Reading (Page 327):</strong>
The book recommends an excellent 2018 paper by Leslie Smith, &ldquo;A Disciplined Approach to Neural Network Hyper-Parameters,&rdquo; for more best practices.</p></li></ul><p><strong>Conclusion of Chapter 10:</strong>
This overview of hyperparameter tuning gives you a strategic approach to building effective neural networks. It&rsquo;s less about finding one &ldquo;magic number&rdquo; and more about understanding the trade-offs and having a systematic way to explore the possibilities, often starting simple and iteratively adding complexity or using smart search strategies and regularization.</p><p>This pretty much wraps up the core <em>conceptual</em> learning from Chapter 10. We&rsquo;ve journeyed from the biological neuron to the idea of MLPs, backpropagation, how to design them for different tasks, and now, critically, how to approach the art and science of tuning them.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer></body></html>