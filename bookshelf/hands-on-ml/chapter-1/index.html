<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#notes-for-chapter-1>Notes for Chapter 1</a><ul><li><a href=#page-2-what-is-machine-learning>(Page 2: What Is Machine Learning?)</a></li><li><a href=#page-3-4-why-use-machine-learning>(Page 3-4: Why Use Machine Learning?)</a></li><li><a href=#page-5-6-examples-of-applications>(Page 5-6: Examples of Applications)</a></li><li><a href=#page-7-9-types-of-machine-learning-systems---the-big-picture>(Page 7-9: Types of Machine Learning Systems - The Big Picture)</a><ul><li><a href=#1-based-on-human-supervision-during-training>1. Based on Human Supervision during Training:</a></li><li><a href=#2-based-on-incremental-learning-on-the-fly>2. Based on Incremental Learning (On-the-fly):</a></li><li><a href=#3-based-on-how-they-generalize>3. Based on How They Generalize:</a></li></ul></li><li><a href=#page-23-29-main-challenges-of-machine-learning>(Page 23-29: Main Challenges of Machine Learning)</a></li><li><a href=#page-30-33-stepping-back-testing-and-validating>(Page 30-33: Stepping Back, Testing and Validating)</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 1: The Machine Learning Landscape</h1><span class=reading-time><em>17 min read</em></span><div class=book-details><div class=book-content><h1 id=notes-for-chapter-1>Notes for Chapter 1</h1><p>When you hear &ldquo;Machine Learning,&rdquo; what pops into your head? Robots? Terminators? Maybe a friendly butler? The book nails it – it&rsquo;s not just sci-fi; it&rsquo;s already here. Think about the <strong>spam filter</strong>. That was one of the first really big ML applications that touched millions. It learned, from examples of spam and non-spam (or &ldquo;ham,&rdquo; as we call it), to tell the difference. And it got so good that we barely notice it anymore. That&rsquo;s the hallmark of good ML – it just works.</p><p>This chapter aims to clarify what ML is, why it&rsquo;s useful, and give you a &ldquo;map&rdquo; of the ML continent: supervised vs. unsupervised, online vs. batch, instance-based vs. model-based. We&rsquo;ll also touch on the typical project workflow and some common challenges.</p><h2 id=page-2-what-is-machine-learning>(Page 2: What Is Machine Learning?)</h2><p>Alright, so what is it? The book gives a great, simple definition:</p><blockquote><p>&ldquo;Machine Learning is the science (and art) of programming computers so they can <strong>learn from data</strong>.&rdquo;</p></blockquote><p>The key here is &ldquo;learn from data.&rdquo; Instead of you, the programmer, writing explicit rules for every single scenario, you show the computer a bunch of examples, and it figures out the patterns itself.</p><p><strong>Arthur Samuel</strong>, a pioneer back in 1959, said it&rsquo;s the &ldquo;field of study that gives computers the ability to learn <strong>without being explicitly programmed</strong>.&rdquo; Think about that – without explicit programming. That&rsquo;s the magic.</p><p>Then there&rsquo;s <strong>Tom Mitchell&rsquo;s</strong> more engineering-focused definition from 1997, which is super useful for grounding this:</p><blockquote><p>&ldquo;A computer program is said to learn from <strong>experience E</strong> with respect to some <strong>task T</strong> and some <strong>performance measure P</strong>, if its performance on T, as measured by P, improves with experience E.&rdquo;</p></blockquote><p>Let&rsquo;s break that down with our spam filter:</p><ul><li><strong>Task T</strong>: Flagging spam emails.</li><li><strong>Experience E</strong>: The training data – thousands of example emails, each labeled as &ldquo;spam&rdquo; or &ldquo;ham.&rdquo;</li><li><strong>Performance Measure P</strong>: How well does it do the task? Maybe it&rsquo;s accuracy – the percentage of emails it correctly classifies.</li></ul><p>So, if our spam filter gets better at correctly identifying spam (higher accuracy P) after being shown more examples of emails (more experience E), then it&rsquo;s learning!</p><p>And the book rightly points out: downloading all of Wikipedia doesn&rsquo;t make your computer &ldquo;learn&rdquo; in the ML sense. It has more data, sure, but it&rsquo;s not suddenly better at, say, translating languages or identifying cats in pictures, unless you use that data to train it for a specific task.</p><h2 id=page-3-4-why-use-machine-learning>(Page 3-4: Why Use Machine Learning?)</h2><p>So, why bother? Why not just write the rules, like we&rsquo;ve always done in traditional programming?
The book uses the spam filter example (Figure 1-1 vs 1-2), and it&rsquo;s perfect.</p><ol><li><strong>Problems too complex for traditional rules</strong>: Imagine trying to write rules for spam. &ldquo;If email contains &lsquo;4U&rsquo;, &lsquo;credit card&rsquo;, &lsquo;free&rsquo;, &lsquo;amazing&rsquo;&mldr;&rdquo; Okay, a start. But spammers get smart. They start writing &ldquo;For U&rdquo; or using images. Your list of rules would become a monster – thousands, maybe millions of lines long, and a nightmare to maintain (Figure 1-1).<ul><li>An ML spam filter, on the other hand, learns which words and phrases are good predictors by looking at frequencies in spam vs. ham (Figure 1-2). It&rsquo;s often shorter, easier to maintain, and more accurate.</li></ul></li><li><strong>Adapting to changing environments</strong>: When spammers change tactics (&ldquo;For U&rdquo; instead of &ldquo;4U&rdquo;), a traditional filter needs you to manually update the rules. An ML system, especially an online learning one (we&rsquo;ll get to that), can see these new patterns emerging in user-flagged spam and automatically adapt (Figure 1-3). It keeps learning!</li><li><strong>No known algorithm</strong>: Think about speech recognition. How would you even begin to write rules to distinguish &ldquo;one&rdquo; from &ldquo;two&rdquo; for every voice, accent, in noisy environments, across dozens of languages? It&rsquo;s incredibly hard. But give an ML algorithm enough recordings of people saying &ldquo;one&rdquo; and &ldquo;two,&rdquo; and it can learn to distinguish them.</li><li><strong>Helping humans learn (Data Mining)</strong>: This is a fascinating one (Figure 1-4). Sometimes, we train an ML model, and then we can peek inside (though it&rsquo;s tricky for some complex models) to see what it learned. A spam filter might reveal surprising combinations of words that are highly predictive of spam. This can give us new insights into complex problems by finding patterns we wouldn&rsquo;t have spotted.</li></ol><h2 id=page-5-6-examples-of-applications>(Page 5-6: Examples of Applications)</h2><p>The book lists a ton, and this really shows the breadth of ML:</p><ul><li><strong>Image Classification (CNNs)</strong>: Identifying products on a production line, detecting tumors in brain scans (this is more semantic segmentation – classifying every pixel).</li><li><strong>Natural Language Processing (NLP)</strong>: Classifying news articles, flagging offensive comments, summarizing documents, chatbots (NLU, question-answering). These often use RNNs, CNNs, or more recently, Transformers.</li><li><strong>Regression (predicting values)</strong>: Forecasting company revenue. This can use Linear Regression, SVMs, Random Forests, Neural Networks.</li><li><strong>Speech Recognition</strong>: Making your app react to voice commands.</li><li><strong>Anomaly Detection</strong>: Detecting credit card fraud.</li><li><strong>Clustering (Unsupervised)</strong>: Segmenting customers based on purchases for targeted marketing.</li><li><strong>Data Visualization/Dimensionality Reduction</strong>: Taking high-dimensional data and making it understandable in 2D or 3D.</li><li><strong>Recommender Systems</strong>: Suggesting products you might like.</li><li><strong>Reinforcement Learning (RL)</strong>: Building intelligent bots for games, like AlphaGo that beat the world Go champion.</li></ul><p>This isn&rsquo;t exhaustive, but it gives you a taste of the sheer power and versatility.</p><h2 id=page-7-9-types-of-machine-learning-systems---the-big-picture>(Page 7-9: Types of Machine Learning Systems - The Big Picture)</h2><p>Okay, now for the &ldquo;map of the ML continent.&rdquo; We can categorize ML systems based on a few key criteria. These aren&rsquo;t mutually exclusive; a system can be a mix.</p><h3 id=1-based-on-human-supervision-during-training>1. Based on Human Supervision during Training:</h3><ul><li><p><strong>(Page 8) Supervised Learning</strong>: This is probably the most common. The &ldquo;supervision&rdquo; comes from the fact that your training data includes the desired solutions, called <strong>labels</strong> (Figure 1-5). You show the system an email AND tell it &ldquo;this is spam.&rdquo; You show it a picture of a cat AND tell it &ldquo;this is a cat.&rdquo;</p><ul><li><strong>Classification</strong>: The task is to predict a category. Spam or ham? Cat or dog? Figure 1-5 (spam classification) is a classic example.</li><li><strong>Regression</strong>: The task is to predict a numerical value. What&rsquo;s the price of this car given its mileage, age, brand (these are <strong>features</strong> or <strong>predictors</strong>)? (Figure 1-6). The &ldquo;label&rdquo; here is the actual price.</li><li>A quick note on terminology (page 8): An <strong>attribute</strong> is a data type (e.g., &ldquo;mileage&rdquo;). A <strong>feature</strong> is often an attribute plus its value (e.g., &ldquo;mileage = 15,000&rdquo;). People often use them interchangeably, but it&rsquo;s good to know the nuance.</li><li>The book lists some key supervised algorithms we&rsquo;ll cover: k-Nearest Neighbors, Linear Regression, Logistic Regression (often used for classification despite &ldquo;regression&rdquo; in its name!), SVMs, Decision Trees, Random Forests, and Neural Networks.</li></ul></li><li><p><strong>(Page 9-12) Unsupervised Learning</strong>: Here, the training data is <strong>unlabeled</strong> (Figure 1-7). There&rsquo;s no &ldquo;teacher&rdquo; providing answers. The system tries to find patterns and structure in the data on its own.</p><ul><li><strong>(Page 10) Clustering</strong>: Trying to find natural groupings in the data. For example, grouping your blog visitors into different segments based on their behavior (Figure 1-8). You don&rsquo;t tell it the groups beforehand; it discovers them. Algorithms include K-Means, DBSCAN, Hierarchical Cluster Analysis (HCA).</li><li><strong>(Page 11) Visualization & Dimensionality Reduction</strong>: Taking complex, high-dimensional data and creating a 2D or 3D plot (Figure 1-9, t-SNE example). This helps us understand the data. Dimensionality reduction aims to simplify the data by merging correlated features (e.g., car mileage and age into &ldquo;wear and tear&rdquo;) or dropping less important ones, without losing too much information. This is called <strong>feature extraction</strong>. It can make subsequent learning faster and sometimes better. PCA, Kernel PCA, LLE are examples.</li><li><strong>(Page 12) Anomaly Detection / Novelty Detection</strong>: Spotting unusual instances. Anomaly detection is about finding things that look different from most of the data (e.g., fraud detection, Figure 1-10). Novelty detection is similar but assumes your training data is &ldquo;clean&rdquo; and you want to find things different from anything seen in training.</li><li><strong>(Page 13) Association Rule Learning</strong>: Discovering relationships between attributes in large datasets. E.g., people who buy barbecue sauce and potato chips also tend to buy steak.</li></ul></li><li><p><strong>(Page 13) Semisupervised Learning</strong>: This is a middle ground. You have a lot of unlabeled data and a little bit of labeled data (Figure 1-11). The system uses both. Think of Google Photos: it clusters faces (unsupervised), then you label a few faces (&ldquo;That&rsquo;s Aunt May&rdquo;), and it can then label Aunt May in many other photos (supervised part). Deep Belief Networks (DBNs) using Restricted Boltzmann Machines (RBMs) are an example.</p></li><li><p><strong>(Page 14) Reinforcement Learning (RL)</strong>: This is a different beast altogether! The learning system, called an <strong>agent</strong>, observes an <strong>environment</strong>, selects and performs <strong>actions</strong>, and gets <strong>rewards</strong> (or penalties) in return (Figure 1-12). It learns the best strategy, called a <strong>policy</strong>, to maximize its cumulative reward over time. Think training a robot to walk, or AlphaGo learning to play Go. It learns by trial and error, essentially.</p></li></ul><h3 id=2-based-on-incremental-learning-on-the-fly>2. Based on Incremental Learning (On-the-fly):</h3><ul><li><p><strong>(Page 15) Batch Learning (Offline Learning)</strong>: The system is trained using all available data at once. It takes time and resources. Once trained, it&rsquo;s launched and doesn&rsquo;t learn anymore; it just applies what it learned. If you want it to learn about new data (e.g., new types of spam), you have to retrain it from scratch on the full dataset (old + new). This can be automated (as in Figure 1-3), but it&rsquo;s still a full retrain. This is fine for many things, but not if you need to adapt rapidly or have massive datasets.</p></li><li><p><strong>(Page 15-16) Online Learning (Incremental Learning)</strong>: The system is trained incrementally by feeding it data instances sequentially, either individually or in small groups called <strong>mini-batches</strong> (Figure 1-13). Each learning step is fast and cheap. This is great for:</p><ul><li>Systems needing rapid adaptation (e.g., stock price prediction).</li><li>Systems with limited computing resources (once it learns from a data instance, it might not need to store it anymore).</li><li>Handling huge datasets that can&rsquo;t fit in memory (called <strong>out-of-core learning</strong>, Figure 1-14). It loads a chunk, trains, loads the next chunk, trains, etc. The book notes, &ldquo;Think of it as incremental learning,&rdquo; which is a good way to avoid confusion, as out-of-core is often done offline.</li><li>A key parameter here is the <strong>learning rate</strong>: how quickly it adapts. Too high, and it forgets old patterns quickly. Too low, and it learns slowly and might be less sensitive to noise or outliers.</li></ul></li></ul><h3 id=3-based-on-how-they-generalize>3. Based on How They Generalize:</h3><p>This is about how systems make predictions on new, unseen data.</p><ul><li><p><strong>(Page 17-18) Instance-Based Learning</strong>: The system learns the training examples by heart. Then, when it sees a new instance, it compares it to the stored examples using a similarity measure and makes a prediction based on the most similar known instances. For example, in Figure 1-15, the new instance (cross) is classified as a triangle because most of its nearest neighbors are triangles. k-Nearest Neighbors is a classic example.</p></li><li><p><strong>(Page 18-22) Model-Based Learning</strong>: The system builds a <strong>model</strong> from the training examples and then uses that model to make predictions. This is like a scientist observing data and building a theory.
The book uses a great example: predicting life satisfaction based on GDP per capita (Table 1-1, Figure 1-17).</p><ol><li>You select a type of model – say, a linear model (Equation 1-1: <code>life_satisfaction = θ₀ + θ₁ × GDP_per_capita</code>). This is <strong>model selection</strong>.</li><li>This model has <strong>parameters</strong> (θ₀ and θ₁ – theta-zero and theta-one). By tweaking these, you get different lines (Figure 1-18).</li><li>How do you find the best parameters? You need a performance measure. For linear regression, it&rsquo;s often a <strong>cost function</strong> that measures how far the model&rsquo;s predictions are from the training examples. The goal is to minimize this cost.</li><li>The learning algorithm (e.g., Linear Regression algorithm) takes your training data and finds the parameter values (θ₀, θ₁) that make the model best fit the data. This is called <strong>training the model</strong> (Figure 1-19).</li><li>Once trained (e.g., θ₀ = 4.85, θ₁ = 4.91 × 10⁻⁵), you can use the model to make predictions on new data (e.g., Cyprus&rsquo;s life satisfaction, page 21).
The code snippet on page 21-22 shows how you&rsquo;d do this with Scikit-Learn. And then it shows how simple it is to swap in an instance-based algorithm like k-Nearest Neighbors!</li></ol></li></ul><h2 id=page-23-29-main-challenges-of-machine-learning>(Page 23-29: Main Challenges of Machine Learning)</h2><p>So, you select an algorithm and train it. What can go wrong? The book says: &ldquo;bad algorithm&rdquo; and &ldquo;bad data.&rdquo;</p><p>Let&rsquo;s start with <strong>&ldquo;Bad Data&rdquo;</strong>:</p><ul><li><strong>(Page 23) Insufficient Quantity of Training Data</strong>: Most ML algorithms need a lot of data to work well. Thousands for simple problems, millions for complex ones like image recognition. The &ldquo;Unreasonable Effectiveness of Data&rdquo; paper (page 24, Figure 1-20) showed that even simple algorithms can perform incredibly well if given enough data. Data often trumps a fancy algorithm, but getting more data isn&rsquo;t always cheap or easy.</li><li><strong>(Page 25) Nonrepresentative Training Data</strong>: Your training data must be representative of the new cases you want to generalize to. If you train a model on life satisfaction vs. GDP using only rich countries, it won&rsquo;t predict well for poor countries (Figure 1-21).<ul><li>This can happen due to <strong>sampling noise</strong> (if your sample is too small and just happens to be unrepresentative by chance) or <strong>sampling bias</strong> (if your sampling method is flawed).</li><li>The Literary Digest poll example (page 26) is a classic case of sampling bias – they polled wealthier people, who leaned Landon, but Roosevelt won. And <strong>nonresponse bias</strong> – only certain types of people responded.</li><li>Want to build a funk music video recognizer by searching YouTube? Your results will be biased towards popular artists.</li></ul></li><li><strong>(Page 26) Poor-Quality Data</strong>: Errors, outliers, noise. &ldquo;Garbage in, garbage out.&rdquo; Data cleaning is a huge part of a data scientist&rsquo;s job! You might discard outliers, fix errors, or decide how to handle missing feature values (ignore the feature, ignore the instance, fill it in – e.g., with the median).</li><li><strong>(Page 27) Irrelevant Features</strong>: If your training data has too many irrelevant features (and not enough relevant ones), the system will struggle. <strong>Feature engineering</strong> is critical:<ul><li><strong>Feature selection</strong>: Choosing the most useful features.</li><li><strong>Feature extraction</strong>: Combining existing features into a more useful one (like we saw with dimensionality reduction).</li><li><strong>Creating new features</strong>: Sometimes you need to gather new data or derive new features.</li></ul></li></ul><p>Now for <strong>&ldquo;Bad Algorithm&rdquo;</strong> (or more accurately, issues with the model itself):</p><ul><li><p><strong>(Page 27-29) Overfitting the Training Data</strong>: This is a HUGE one. The model performs great on the training data but poorly on new, unseen data. It&rsquo;s like it memorized the training data, including its noise and quirks, instead of learning the underlying general pattern (Figure 1-22).</p><ul><li>Imagine your life satisfaction model learns that countries with a &lsquo;W&rsquo; in their name are happier based on your training data (New Zealand, Norway, Sweden). This is just a chance pattern in your data, not a real rule!</li><li>Solutions (page 28):<ul><li>Simplify the model: Choose one with fewer parameters (e.g., linear instead of high-degree polynomial), reduce features, or constrain the model.</li><li>Gather more training data.</li><li>Reduce noise in the training data (fix errors, remove outliers).</li></ul></li><li><strong>Regularization</strong> (page 28-29): Constraining a model to make it simpler and reduce overfitting. For our linear model, if we force the slope (θ₁) to be small, it makes the line flatter and less likely to chase noise (Figure 1-23). The amount of regularization is controlled by a <strong>hyperparameter</strong>.</li><li>Crucial distinction (page 29): A model <strong>parameter</strong> (like θ₀, θ₁) is something the learning algorithm tunes. A <strong>hyperparameter</strong> is a parameter of the learning algorithm itself (e.g., the amount of regularization to apply). You set hyperparameters <em>before</em> training.</li></ul></li><li><p><strong>(Page 29) Underfitting the Training Data</strong>: The opposite of overfitting. Your model is too simple to learn the underlying structure of the data. A linear model for life satisfaction might underfit because reality is more complex (Figure 1-21 showed this too – the linear model wasn&rsquo;t great for very rich or very poor countries).</p><ul><li>Solutions:<ul><li>Select a more powerful model (more parameters).</li><li>Feed better features to the algorithm (feature engineering).</li><li>Reduce constraints on the model (e.g., reduce the regularization hyperparameter).</li></ul></li></ul></li></ul><h2 id=page-30-33-stepping-back-testing-and-validating>(Page 30-33: Stepping Back, Testing and Validating)</h2><p>Phew! That was a lot. The book summarizes it well on page 30:</p><ul><li>ML is about machines learning from data, not explicit rules.</li><li>Many types: supervised/unsupervised, batch/online, instance/model-based.</li><li>Typical project: Gather data, feed to algorithm. Model-based learns parameters to fit. Instance-based learns by heart.</li><li>Pitfalls: Bad data (too little, non-representative, noisy, irrelevant features) or bad model (overfitting/underfitting).</li></ul><p>So, you&rsquo;ve trained a model. How do you know if it will generalize to new cases? You can&rsquo;t just &ldquo;hope&rdquo;!</p><ul><li><p><strong>Training Set and Test Set (Page 30)</strong>: Split your data. You train on the <strong>training set</strong>. You evaluate on the <strong>test set</strong> (data the model has never seen). The error rate on the test set is called the <strong>generalization error</strong> (or out-of-sample error). This tells you how well it will likely do in the real world.</p><ul><li>If training error is low but generalization error is high, you&rsquo;re overfitting!</li><li>Common split: 80% train, 20% test (but depends on dataset size, as page 31 notes).</li></ul></li><li><p><strong>(Page 31) Hyperparameter Tuning and Model Selection</strong>:</p><ul><li>What if you&rsquo;re choosing between a linear model and a polynomial model? Or trying to find the best regularization hyperparameter? You can&rsquo;t just try them all on the test set and pick the best. Why? Because then you&rsquo;ve tuned your model and hyperparameters to that specific test set. It might not perform well on other new data. You&rsquo;ve essentially &ldquo;used up&rdquo; your test set.</li><li><strong>Holdout Validation</strong>: The solution! Split your original training data further. Keep some aside as a <strong>validation set</strong> (or dev set).<ol><li>Train various models (with different hyperparameters, or different model types) on the reduced training set (full training set - validation set).</li><li>Evaluate them on the validation set. Pick the best one.</li><li>Now, train your best model (with its best hyperparameters) on the full original training set (including the validation set). This is your final model.</li><li>Finally, evaluate this final model on the test set to get an estimate of its true generalization error.</li></ol></li><li><strong>Cross-validation</strong> is mentioned as a way to deal with small validation sets by using many small validation sets. More robust, but takes longer.</li></ul></li><li><p><strong>(Page 32) Data Mismatch</strong>: What if your training data (e.g., flower pictures from the web) isn&rsquo;t perfectly representative of your production data (e.g., flower pictures taken by your mobile app)?</p><ul><li>Crucial rule: Your validation set and test set must be as representative of the production data as possible. So, they should come from the app pictures.</li><li>If performance on the validation set is bad after training on web pictures, is it overfitting or data mismatch?</li><li>Andrew Ng suggests a <strong>train-dev set</strong>: a subset of the web (training) pictures held out.<ul><li>If model does poorly on train-dev: it overfit the training web pictures. Simplify/regularize.</li><li>If model does well on train-dev but poorly on (app-based) validation set: it&rsquo;s data mismatch. Try to make web images look more like app images (preprocessing).</li></ul></li></ul></li><li><p><strong>(Page 33) No Free Lunch (NFL) Theorem</strong>: A humbling but important concept. There&rsquo;s no single model that is <em>a priori</em> guaranteed to work best on all problems. If you make no assumptions about your data, any model is as good as any other.</p><ul><li>A linear model might be best for one dataset, a neural network for another.</li><li>The only way to know for sure is to try them all (impossible!).</li><li>In practice, we make reasonable assumptions about the data and try a few suitable models.</li></ul></li><li><p><strong>(Page 33-34: Exercises)</strong>
The chapter ends with a great set of exercises. I strongly encourage you to go through them. If you can answer these, you&rsquo;ve got a solid grasp of this foundational material.</p></li></ul><hr><p>Okay! We&rsquo;ve covered a massive amount of ground – the entire landscape of Machine Learning, really. We&rsquo;ve defined what it is, why it&rsquo;s a game-changer, explored the main types of systems, the process of building models, and the pitfalls to watch out for.</p><p>The key takeaways:</p><ul><li>ML is about learning patterns from data.</li><li>The type of learning (supervised, unsupervised, etc.) depends on your data and your goal.</li><li>Data is king, but it needs to be good quality and representative.</li><li>Overfitting and underfitting are constant battles.</li><li>Always test your model on unseen data!</li></ul><p>This chapter sets the stage. From here on out, we&rsquo;ll be diving deeper into these concepts, with more math, more code, and more hands-on examples from the book.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>