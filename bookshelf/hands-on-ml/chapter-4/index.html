<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#introduction---beyond-black-boxes>Introduction - Beyond Black Boxes</a></li><li><a href=#linear-regression---the-model>Linear Regression - The Model</a></li><li><a href=#mse-cost-function--the-normal-equation>MSE Cost Function & The Normal Equation</a></li><li><a href=#testing-the-normal-equation>Testing the Normal Equation</a></li><li><a href=#scikit-learn-and-computational-complexity>Scikit-Learn and Computational Complexity</a></li><li><a href=#gradient-descent---the-iterative-approach>Gradient Descent - The Iterative Approach</a></li><li><a href=#batch-gradient-descent---bgd>Batch Gradient Descent - BGD</a></li><li><a href=#stochastic-gradient-descent---sgd>Stochastic Gradient Descent - SGD</a></li><li><a href=#mini-batch-gradient-descent>Mini-batch Gradient Descent</a></li><li><a href=#comparison-table-4-1>Comparison Table 4-1</a></li><li><a href=#polynomial-regression>Polynomial Regression</a></li><li><a href=#learning-curves>Learning Curves</a></li><li><a href=#regularized-linear-models>Regularized Linear Models</a></li><li><a href=#logistic-regression>Logistic Regression</a></li><li><a href=#softmax-regression>Softmax Regression</a></li></ul></li><li><a href=#glossary>Glossary</a><ul><li><a href=#difference-between-l1-lasso-and-l2-ridge-regularization-lets-break-down-that-intuition-about-the-shapes-and-corners>Difference between L1 (Lasso) and L2 (Ridge) regularization! Let&rsquo;s break down that intuition about the &ldquo;shapes&rdquo; and &ldquo;corners.&rdquo;</a></li><li><a href=#softmax-regression-the-direct-multiclass-probabilistic-approach>Softmax Regression: The &ldquo;Direct&rdquo; Multiclass Probabilistic Approach</a></li><li><a href=#focus-on-the-cross-entropy-cost-function>Focus on the Cross-Entropy cost function</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 4: Training Models</h1><span class=reading-time><em>53 min read</em></span><div class=book-details><div class=book-content><p>Chapter 4: Training Models.</p><h2 id=introduction---beyond-black-boxes>Introduction - Beyond Black Boxes</h2><p>Up until now, as the book says, we&rsquo;ve treated ML models and their training algorithms mostly like black boxes. We fed them data, they gave us results, and we learned to evaluate those results. You&rsquo;ve optimized regression, improved classifiers, even built a spam filter, often without peeking under the hood. And that&rsquo;s okay for many practical purposes!</p><p>However, understanding <em>how</em> these things work internally is incredibly powerful. It helps you:</p><ul><li>Choose the right model and algorithm: Knowing the mechanics helps you match the tool to the task.</li><li>Select good hyper parameters: Hyper parameters often control the learning process itself. Understanding that process helps you tune them effectively.</li><li>Debug issues and perform error analysis: When things go wrong, or your model makes weird mistakes, knowing the &ldquo;why&rdquo; is crucial.</li><li>Foundation for advanced topics: Especially for neural networks (Part II of the book), the concepts here are fundamental.</li></ul><p>This chapter focuses on Linear Regression as a starting point because it&rsquo;s simple, yet we can train it in very different ways. We&rsquo;ll explore two main approaches:</p><ol><li>A direct &ldquo;closed-form&rdquo; equation (The Normal Equation): This is like having a magic formula that directly spits out the best model parameters in one go.</li><li>An iterative optimization approach (Gradient Descent): This is more like a trial-and-error process. We start with a guess for the parameters and gradually tweak them, step by step, to minimize the error, eventually (hopefully!) arriving at the same best parameters. We&rsquo;ll see different &ldquo;flavors&rdquo; of Gradient Descent: Batch, Mini-batch, and Stochastic.</li></ol><p>Then, the chapter will touch on:</p><ul><li>Polynomial Regression: How to use linear models for non-linear data.</li><li>Learning Curves: Tools to diagnose over fitting or under fitting.</li><li>Regularization: Techniques to prevent over fitting.</li><li>Logistic Regression and Softmax Regression: Models commonly used for classification tasks.</li></ul><p>The scorpion icon on page 112 gives a fair warning: there will be some math (linear algebra, calculus). If you&rsquo;re &ldquo;allergic,&rdquo; the book suggests you can still get the concepts by focusing on the text. My job is to make sure you get those concepts, regardless of how comfortable you are with the equations. We&rsquo;ll always ask: &ldquo;What is this equation ultimately trying to achieve?&rdquo;</p><h2 id=linear-regression---the-model>Linear Regression - The Model</h2><p>Remember our life satisfaction model from Chapter 1? <code>life_satisfaction = θ₀ + θ₁ × GDP_per_capita</code>. That was a simple linear regression with one feature.</p><p>More generally, a linear model predicts a value by:</p><ol><li>Taking all the input features (like a house&rsquo;s square footage, number of bedrooms, age, etc.).</li><li>Multiplying each feature by a specific weight (a model parameter).</li><li>Summing up these weighted features.</li><li>Adding a constant bias term (another model parameter, also called the intercept).</li></ol><p>Equation 4-1 (page 112): Linear Regression model prediction
<code>ŷ = θ₀ + θ₁x₁ + θ₂x₂ + ⋯ + θₙxₙ</code></p><ul><li><code>ŷ</code> (y-hat): The predicted value.</li><li><code>n</code>: The number of features.</li><li><code>xᵢ</code>: The value of the i-th feature.</li><li><code>θ₀</code>: The bias term (theta-zero). <em>What it&rsquo;s ultimately trying to achieve:</em> It&rsquo;s the baseline prediction if all feature values were zero. It allows the line/plane to shift up or down.</li><li><code>θ₁</code> to <code>θₙ</code>: The feature weights. <code>θⱼ</code> is the weight for the j-th feature. <em>What they&rsquo;re ultimately trying to achieve:</em> They represent how much a one-unit change in that feature <code>xⱼ</code> affects the predicted value <code>ŷ</code>, holding other features constant. A positive weight means the feature positively influences the prediction; a negative weight means it negatively influences it. The magnitude shows the strength of the influence.</li></ul><p>Equation 4-2 (page 113): Vectorized form
<code>ŷ = h_θ(x) = θ · x</code></p><p>This is just a more compact way to write Equation 4-1 using vector notation.</p><ul><li><code>θ</code> (theta): Is now a parameter vector <code>[θ₀, θ₁, ..., θₙ]</code>.</li><li><code>x</code>: Is the instance&rsquo;s feature vector <code>[x₀, x₁, ..., xₙ]</code>. Here, we add a &ldquo;dummy&rdquo; feature <code>x₀</code> which is always set to 1. This allows us to include the bias term <code>θ₀</code> neatly into the dot product (because <code>θ₀ * x₀ = θ₀ * 1 = θ₀</code>).</li><li><code>θ · x</code>: This is the dot product of the two vectors. It&rsquo;s exactly the sum <code>θ₀x₀ + θ₁x₁ + ... + θₙxₙ</code>.</li><li><code>h_θ(x)</code>: This is our hypothesis function (our model), parameterized by <code>θ</code>. Given an input <code>x</code>, it predicts <code>ŷ</code>.</li></ul><p>The bird sidebar (page 113) explains that vectors are often column vectors (2D arrays with one column). So, if <code>θ</code> and <code>x</code> are column vectors, the dot product can be written as a matrix multiplication: <code>ŷ = θᵀx</code> (where <code>θᵀ</code> is the transpose of <code>θ</code>, making it a row vector). Don&rsquo;t let this bog you down; it&rsquo;s a notational convenience. The goal is the same: calculate a weighted sum of features plus a bias.</p><p>How do we train it?
Training means finding the values for the parameters <code>θ</code> (the bias <code>θ₀</code> and the weights <code>θ₁</code> to <code>θₙ</code>) that make the model &ldquo;best fit&rdquo; the training data.</p><p>To do this, we need a way to measure how well (or poorly) the model fits. We learned in Chapter 2 that for regression, a common measure is RMSE (Root Mean Square Error).</p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> Quantify the typical prediction error.
However, for mathematical convenience during training, it&rsquo;s often easier to minimize the MSE (Mean Squared Error) instead. Minimizing MSE will also minimize RMSE (since the square root function is monotonic).
The footnote on page 113 is important: the function we optimize during training (the <em>cost function</em>, here MSE) might be different from the final performance metric we use to evaluate the model (e.g., RMSE). This is often because the cost function has nice mathematical properties (like being easily differentiable) that make optimization easier.</li></ul><h2 id=mse-cost-function--the-normal-equation>MSE Cost Function & The Normal Equation</h2><p>Equation 4-3 (page 114): MSE cost function for a Linear Regression model
<code>MSE(X, h_θ) = (1/m) * Σᵢ (θᵀx⁽ⁱ⁾ - y⁽ⁱ⁾)²</code>
(summing from i=1 to m, where m is the number of instances)</p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em><ul><li>For each training instance <code>i</code>:<ul><li><code>θᵀx⁽ⁱ⁾</code> is the model&rsquo;s prediction for that instance.</li><li><code>y⁽ⁱ⁾</code> is the actual target value.</li><li><code>(θᵀx⁽ⁱ⁾ - y⁽ⁱ⁾)</code> is the error for that instance.</li><li>We square this error: <code>(error)²</code>. (Why square? It makes all errors positive, and it penalizes larger errors more heavily).</li></ul></li><li>We sum these squared errors over all <code>m</code> training instances: <code>Σᵢ (error)²</code>.</li><li>We divide by <code>m</code> to get the <em>mean</em> of the squared errors.
This function tells us, on average, how &ldquo;bad&rdquo; our model&rsquo;s predictions are for a given set of parameters <code>θ</code>. Our goal in training is to find the <code>θ</code> that makes this MSE as small as possible.</li></ul></li></ul><p>The Normal Equation: A Direct Solution</p><p>For Linear Regression with an MSE cost function, there&rsquo;s a wonderful mathematical shortcut. Instead of iteratively searching for the best <code>θ</code>, there&rsquo;s a direct formula that gives you the <code>θ</code> that minimizes the cost function in one shot! This is called the Normal Equation.</p><p>Equation 4-4 (page 114): Normal Equation
<code>θ̂ = (XᵀX)⁻¹ Xᵀy</code></p><ul><li><code>θ̂</code> (theta-hat): This is the value of <code>θ</code> that minimizes the cost function.</li><li><code>X</code>: The matrix of input features for all training instances (each row is an instance, <code>x₀</code> for each instance is 1).</li><li><code>y</code>: The vector of actual target values for all training instances.</li><li><code>Xᵀ</code>: The transpose of matrix <code>X</code>.</li><li><code>(XᵀX)⁻¹</code>: The inverse of the matrix <code>XᵀX</code>.</li></ul><p><em>What it&rsquo;s ultimately trying to achieve:</em> This equation, derived using calculus (setting the derivative of the cost function to zero and solving for θ), directly calculates the optimal parameter vector <code>θ̂</code> that makes the linear model fit the training data as closely as possible (in the mean squared error sense). It&rsquo;s like a direct recipe: plug in your data <code>X</code> and <code>y</code>, and out pops the best <code>θ</code>.</p><h2 id=testing-the-normal-equation>Testing the Normal Equation</h2><p>The book generates some linear-looking data (Figure 4-1):
<code>X = 2 * np.random.rand(100, 1)</code> (100 instances, 1 feature)
<code>y = 4 + 3 * X + np.random.randn(100, 1)</code> (True model is <code>y = 4 + 3x₁ + noise</code>)
So, the ideal <code>θ₀</code> is 4, and the ideal <code>θ₁</code> is 3.</p><p>To use the Normal Equation, we need to add <code>x₀ = 1</code> to each instance in <code>X</code>:
<code>X_b = np.c_[np.ones((100, 1)), X]</code> (<code>np.c_</code> concatenates arrays column-wise)</p><p>Now, apply the Normal Equation:
<code>theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)</code>
The result is something like <code>[[4.215...], [2.770...]]</code>.
So, <code>θ₀̂ ≈ 4.215</code> and <code>θ₁̂ ≈ 2.770</code>.
It&rsquo;s close to the true values (4 and 3), but not exact because of the random noise we added to <code>y</code>. The noise makes it impossible to recover the exact original parameters.</p><p>We can then use this <code>theta_best</code> to make predictions (Figure 4-2).</p><h2 id=scikit-learn-and-computational-complexity>Scikit-Learn and Computational Complexity</h2><ul><li><p>Scikit-Learn <code>LinearRegression</code>:
<code>from sklearn.linear_model import LinearRegression</code>
<code>lin_reg = LinearRegression()</code>
<code>lin_reg.fit(X, y)</code>
Scikit-Learn handles adding the <code>x₀=1</code> feature (or rather, it separates the bias term <code>lin_reg.intercept_</code> from the feature weights <code>lin_reg.coef_</code>). The results are the same as the Normal Equation.</p></li><li><p>Underlying Method (<code>scipy.linalg.lstsq</code>):
Scikit-Learn&rsquo;s <code>LinearRegression</code> actually uses <code>scipy.linalg.lstsq()</code> (&ldquo;least squares&rdquo;). This function computes <code>θ̂ = X⁺y</code>, where <code>X⁺</code> is the pseudoinverse (or Moore-Penrose inverse) of <code>X</code>.
You can compute <code>X⁺</code> using <code>np.linalg.pinv()</code>.
The pseudoinverse is calculated using a technique called Singular Value Decomposition (SVD).</p><ul><li><em>Why SVD/pseudoinverse instead of the direct Normal Equation <code>(XᵀX)⁻¹ Xᵀy</code>?</em><ol><li>More efficient: SVD is generally more computationally efficient.</li><li>Handles edge cases: The Normal Equation requires <code>XᵀX</code> to be invertible. If it&rsquo;s not (e.g., if you have more features than instances, <code>m &lt; n</code>, or if some features are redundant/linearly dependent), the Normal Equation breaks down. The pseudoinverse is <em>always</em> defined, making SVD more robust.</li></ol></li></ul></li><li><p>Computational Complexity:</p><ul><li>Normal Equation (inverting <code>XᵀX</code>): About O(n²·⁴) to O(n³) where <code>n</code> is the number of features. This gets very slow if you have many features (e.g., 100,000 features). Doubling features can increase time by 5-8x.</li><li>SVD (used by Scikit-Learn): About O(n²). Doubling features increases time by ~4x. Still slow for very large <code>n</code>.</li><li>Both are O(m) with respect to the number of instances <code>m</code>. So, they handle large numbers of training instances efficiently, <em>as long as the data fits in memory</em>.</li><li>Predictions: Once trained, making predictions is very fast: O(m) and O(n) – linear with number of instances and features.</li></ul></li></ul><p>The Problem with Normal Equation/SVD: They get slow with many features and require all data to be in memory. This leads us to the next method&mldr;</p><h2 id=gradient-descent---the-iterative-approach>Gradient Descent - The Iterative Approach</h2><p>When the Normal Equation is too slow (too many features) or the dataset is too large to fit in memory, we need a different approach. Enter Gradient Descent.</p><ul><li><p>The Core Idea: Gradient Descent is a generic optimization algorithm. It iteratively tweaks model parameters to minimize a cost function.</p><ul><li>Imagine you&rsquo;re lost in a foggy mountain valley. You can only feel the slope of the ground under your feet. To get to the bottom, you&rsquo;d take a step in the direction of the steepest downhill slope. Repeat.</li><li>This is Gradient Descent:<ol><li>It measures the local gradient of the cost function (e.g., MSE) with respect to the parameter vector <code>θ</code>. The gradient tells you the direction of steepest <em>ascent</em>.</li><li>It takes a step in the <em>opposite</em> direction (descending gradient) to reduce the cost.</li><li>Repeat until the gradient is zero (or very close), meaning you&rsquo;ve reached a minimum.</li></ol></li></ul></li><li><p>The Process (Figure 4-3, page 118):<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-3.png alt="Figure 4-3" width=700></figure></p><ol><li>Random Initialization: Start with random values for <code>θ</code>.</li><li>Iterative Improvement: In each step:<ul><li>Calculate the gradient of the cost function at the current <code>θ</code>.</li><li>Update <code>θ</code> by taking a small step in the negative gradient direction.</li></ul></li><li>Convergence: Continue until the algorithm converges to a minimum (cost stops decreasing significantly).</li></ol></li><li><p>Learning Rate (η - eta):</p><ul><li>This is a crucial hyperparameter that determines the <em>size</em> of the steps.</li><li>Too small (Figure 4-4): Many iterations needed to converge (very slow).<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-4.png alt="Figure 4-4" width=700></figure></li><li>Too large (Figure 4-5): Might jump across the valley, diverge, and fail to find a solution.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-5.png alt="Figure 4-5" width=700></figure></li></ul></li><li><p>Challenges (Figure 4-6, page 119):</p><ul><li>Local Minima: If the cost function has multiple minima (not a smooth bowl), GD might converge to a <em>local minimum</em>, which isn&rsquo;t as good as the <em>global minimum</em>.</li><li>Plateaus: If the cost function has flat areas, GD can take a very long time to cross them.</li><li>Irregular Terrains: Holes, ridges make convergence difficult.</li></ul></li><li><p>Good News for Linear Regression MSE:</p><ul><li>The MSE cost function for Linear Regression is a convex function.<ul><li><em>What this means:</em> It&rsquo;s shaped like a bowl. It has <em>no local minima</em>, only one global minimum.</li><li>It&rsquo;s also continuous with a slope that doesn&rsquo;t change abruptly.</li></ul></li><li>Consequence: Gradient Descent is <em>guaranteed</em> to approach the global minimum if you wait long enough and the learning rate isn&rsquo;t too high.</li></ul></li><li><p>Feature Scaling Matters! (Figure 4-7, page 120):</p><ul><li>If features have very different scales (e.g., feature 1 ranges 0-1, feature 2 ranges 0-1000), the cost function &ldquo;bowl&rdquo; becomes elongated.</li><li>GD will take a long, zig-zag path to the minimum.</li><li>Solution: Ensure all features have a similar scale (e.g., using <code>StandardScaler</code>). GD will then converge much faster.</li></ul></li><li><p>Parameter Space: Training a model is essentially a search in the model&rsquo;s <em>parameter space</em> for the combination of parameters that minimizes the cost. More parameters = higher dimensional space = harder search. For Linear Regression (convex cost), it&rsquo;s like finding the bottom of a D-dimensional bowl.</p></li></ul><h2 id=batch-gradient-descent---bgd>Batch Gradient Descent - BGD</h2><p>To implement GD, we need the gradient of the cost function with respect to <em>each</em> model parameter <code>θⱼ</code>. This is the partial derivative <code>∂MSE(θ) / ∂θⱼ</code>.</p><ul><li><p>Equation 4-5 (page 121): Partial derivative of MSE w.r.t. <code>θⱼ</code>
<code>∂MSE(θ)/∂θⱼ = (2/m) * Σᵢ (θᵀx⁽ⁱ⁾ - y⁽ⁱ⁾) * xⱼ⁽ⁱ⁾</code></p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> For each parameter <code>θⱼ</code>, it calculates how much the MSE would change if <code>θⱼ</code> changed a tiny bit.<ul><li><code>(θᵀx⁽ⁱ⁾ - y⁽ⁱ⁾)</code> is the prediction error for instance <code>i</code>.</li><li>We multiply this error by the value of the <code>j</code>-th feature of instance <code>i</code>, <code>xⱼ⁽ⁱ⁾</code>. (If <code>xⱼ⁽ⁱ⁾</code> is large, <code>θⱼ</code> has a bigger impact on the prediction and thus on the error).</li><li>We average this product over all instances <code>m</code>.</li></ul></li></ul></li><li><p>Equation 4-6 (page 122): Gradient vector <code>∇_θ MSE(θ)</code>
<code>∇_θ MSE(θ) = (2/m) Xᵀ(Xθ - y)</code></p><ul><li>This is the compact, vectorized way to compute all partial derivatives at once. <code>∇_θ MSE(θ)</code> is a vector containing <code>∂MSE(θ)/∂θ₀</code>, <code>∂MSE(θ)/∂θ₁</code>, &mldr;, <code>∂MSE(θ)/∂θₙ</code>.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> It gives the direction of steepest <em>increase</em> in the cost function.</li></ul><p>Crucial point for BATCH GD: This formula uses the <em>entire training set <code>X</code></em> at each step to calculate the gradients. This is why it&rsquo;s called Batch Gradient Descent.</p><ul><li>Consequence: Terribly slow on very large training sets.</li><li>Advantage: Scales well with the number of features (unlike Normal Equation).</li></ul></li><li><p>Equation 4-7 (page 122): Gradient Descent step
<code>θ⁽ⁿᵉˣᵗ ˢᵗᵉᵖ⁾ = θ - η ∇_θ MSE(θ)</code></p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> Update the current parameters <code>θ</code> by taking a step of size <code>η</code> (learning rate) in the direction <em>opposite</em> to the gradient (downhill).</li></ul></li><li><p>Implementation (page 122):
The code shows a loop:
<code>for iteration in range(n_iterations):</code>
<code>gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y)</code>
<code>theta = theta - eta * gradients</code>
With <code>eta = 0.1</code> and <code>n_iterations = 1000</code>, the resulting <code>theta</code> is exactly what the Normal Equation found! Perfect.</p></li><li><p>Effect of Learning Rate <code>η</code> (Figure 4-8, page 123):</p><ul><li><code>η = 0.02</code> (left): Too slow, many steps to converge.</li><li><code>η = 0.1</code> (middle): Good, converges quickly.</li><li><code>η = 0.5</code> (right): Too high, diverges, jumps around.</li></ul></li><li><p>Finding a good learning rate: Grid search (Chapter 2).</p></li><li><p>Setting number of iterations: If too low, far from optimum. If too high, waste time after convergence.</p><ul><li>Solution: Set many iterations, but stop when the gradient vector becomes tiny (its norm &lt; <code>ϵ</code>, a small tolerance). This means we&rsquo;re (almost) at the minimum.</li></ul></li><li><p>Convergence Rate (sidebar, page 124):
For convex cost functions like MSE, BGD with fixed <code>η</code> takes O(1/ϵ) iterations to reach within <code>ϵ</code> of the optimum. To get 10x more precision (divide <code>ϵ</code> by 10), you need ~10x more iterations.</p></li></ul><h2 id=stochastic-gradient-descent---sgd>Stochastic Gradient Descent - SGD</h2><p>Batch GD is slow on large datasets because it uses all training data at each step.</p><ul><li><p>Stochastic Gradient Descent (SGD):</p><ul><li>At each step, picks <em>one random instance</em> from the training set and computes gradients based <em>only on that single instance</em>.</li><li>Advantages:<ul><li>Much faster per step (very little data to process).</li><li>Can train on huge datasets (only one instance in memory at a time – good for out-of-core learning, Ch 1).</li></ul></li><li>Disadvantages (Figure 4-9, page 124):<ul><li>Stochastic nature: The path to the minimum is much more erratic (&ldquo;bouncy&rdquo;) than BGD. Cost function goes up and down, decreasing only on average.</li><li>Never settles: Once near the minimum, it keeps bouncing around, never perfectly settling. Final parameters are good, but not optimal.</li></ul></li><li>Advantage of randomness: If cost function is irregular (non-convex, Figure 4-6), SGD&rsquo;s randomness can help it jump out of local minima and find a better global minimum.</li></ul></li><li><p>Learning Schedule (page 125):</p><ul><li>To help SGD settle at the minimum, we can gradually reduce the learning rate <code>η</code>.</li><li>Start with large <code>η</code> (quick progress, escape local minima).</li><li>Make <code>η</code> smaller over time (settle at global minimum).</li><li>This is like simulated annealing in metallurgy.</li><li>The function determining <code>η</code> at each iteration is the learning schedule.</li><li>If <code>η</code> reduces too quickly -> stuck in local minimum or frozen half-way.</li><li>If <code>η</code> reduces too slowly -> bounce around minimum for long, or stop too early with suboptimal solution.</li></ul></li><li><p>Implementation of SGD (page 125):</p><ul><li>Outer loop for <code>epochs</code> (an epoch is one pass through the entire training set, by convention).</li><li>Inner loop for <code>m</code> iterations (number of instances). In each inner iteration:<ul><li>Pick a <code>random_index</code>.</li><li>Get <code>xi</code> and <code>yi</code> for that instance.</li><li>Gradients calculated using <em>only</em> <code>xi</code> and <code>yi</code>: <code>gradients = 2 * xi.T.dot(xi.dot(theta) - yi)</code>. (Note: <code>2</code> not <code>2/m</code> because <code>m=1</code> here).</li><li>Update <code>eta</code> using <code>learning_schedule(epoch * m + i)</code>.</li><li>Update <code>theta</code>.</li></ul></li><li>After 50 epochs (much fewer iterations than BGD&rsquo;s 1000), it finds a <code>theta</code> very close to BGD&rsquo;s.</li><li>Figure 4-10 (page 126) shows the irregular first 20 steps.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-10.png alt="Figure 4-10" width=700></figure></li></ul></li><li><p>Important note on SGD (sidebar, page 126):</p><ul><li>Training instances <em>must be independent and identically distributed (IID)</em> for SGD to converge to global optimum on average.</li><li>Shuffle instances during training (pick randomly, or shuffle set at start of each epoch). If data is sorted (e.g., by label), SGD will optimize for one label, then the next, and not find global minimum.</li></ul></li><li><p>SGD with Scikit-Learn (<code>SGDRegressor</code>, page 126):</p><ul><li>Defaults to optimizing MSE.</li><li><code>sgd_reg = SGDRegressor(max_iter=1000, tol=1e-3, penalty=None, eta0=0.1)</code><ul><li><code>max_iter</code>: max epochs.</li><li><code>tol</code>: stop if loss drops by less than this in one epoch.</li><li><code>penalty=None</code>: no regularization (more later).</li><li><code>eta0</code>: initial learning rate. Uses its own default learning schedule.</li></ul></li><li><code>sgd_reg.fit(X, y.ravel())</code> (<code>.ravel()</code> flattens <code>y</code> into 1D array, often needed by Scikit-Learn).</li><li>Resulting intercept and coefficient are very close to Normal Equation&rsquo;s.</li></ul></li></ul><h2 id=mini-batch-gradient-descent>Mini-batch Gradient Descent</h2><p>A compromise between Batch GD and Stochastic GD.</p><ul><li>At each step, computes gradients on small random sets of instances called mini-batches.</li><li>Main advantage over SGD: Performance boost from hardware optimization of matrix operations (especially on GPUs).</li><li>Behavior (Figure 4-11, page 127):<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-11.png alt="Figure 4-11" width=700></figure><ul><li>Less erratic path than SGD.</li><li>Ends up closer to the minimum than SGD (with fixed <code>η</code>).</li><li>But may be harder to escape local minima (for non-convex problems) compared to SGD.</li><li>All three (Batch, Stochastic, Mini-batch) end up near the minimum. Batch stops <em>at</em> the minimum. SGD and Mini-batch would also reach minimum with a good learning schedule.</li><li>But Batch GD takes much longer per step.</li></ul></li></ul><h2 id=comparison-table-4-1>Comparison Table 4-1</h2><p>This table nicely summarizes Normal Equation, SVD, Batch GD, Stochastic GD, Mini-batch GD for Linear Regression based on:</p><ul><li><code>Large m</code> (instances): Normal Eq/SVD are fast if data fits memory. GD methods are also fast (SGD/Mini-batch can do out-of-core).</li><li><code>Out-of-core support</code>: Only SGD/Mini-batch.</li><li><code>Large n</code> (features): Normal Eq/SVD are slow. GD methods are fast.</li><li><code>Hyperparameters</code>: Normal Eq/SVD have 0. BGD has 2 (η, iterations). SGD/Mini-batch have >=2 (η, iterations, schedule params).</li><li><code>Scaling required</code>: No for Normal Eq/SVD. Yes for GD methods.</li><li><code>Scikit-Learn class</code>: <code>LinearRegression</code> for SVD. <code>SGDRegressor</code> for GDs.<figure><img src=/bookshelf/hands-on-ml/ch-4-tbl-1.png alt="Table 4-1" width=700></figure></li></ul><p>The key is that after training, all these methods (if converged) produce very similar models and make predictions in the same way. The difference is in <em>how they get there</em> (the training process).</p><p>Excellent! Glad you&rsquo;re with me. Let&rsquo;s push on to the next sections of Chapter 4. We&rsquo;ve just laid the groundwork for how Linear Regression models are trained. Now, let&rsquo;s see how we can adapt these ideas for more complex scenarios.</p><h2 id=polynomial-regression>Polynomial Regression</h2><p>So far, Linear Regression assumes a straight-line (or flat plane/hyperplane) relationship between features and the target. But what if your data is more complex, like the curved data in Figure 4-12 (page 129)?<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-12.png alt="Figure 4-12" width=700></figure>The book shows data generated by a simple quadratic equation: <code>y = 0.5 * X2 + X + 2 + noise</code>. Clearly, a straight line won&rsquo;t fit this well.</p><p>This is where Polynomial Regression comes in.</p><ul><li><p>The Core Idea: You can still use a <em>linear model</em> to fit <em>nonlinear data</em>!</p></li><li><p>How? By adding powers of each feature as new features, and then training a linear model on this <em>extended</em> set of features.</p><ul><li>For example, if you have one feature <code>X</code>, you can create a new feature <code>X²</code>. Then your linear model becomes <code>ŷ = θ₀ + θ₁X + θ₂X²</code>. Even though the equation is quadratic in <code>X</code>, it&rsquo;s <em>linear</em> in terms of the parameters <code>θ₀, θ₁, θ₂</code> and the features <code>X</code> and <code>X²</code>.</li></ul></li><li><p>Scikit-Learn&rsquo;s <code>PolynomialFeatures</code> (page 129): This class transforms your data.
<code>from sklearn.preprocessing import PolynomialFeatures</code>
<code>poly_features = PolynomialFeatures(degree=2, include_bias=False)</code></p><ul><li><code>degree=2</code>: We want to add 2nd-degree polynomial features (i.e., squares).</li><li><code>include_bias=False</code>: <code>PolynomialFeatures</code> can add a column of 1s (for the bias term), but <code>LinearRegression</code> handles that, so we set it to <code>False</code> to avoid redundancy.
<code>X_poly = poly_features.fit_transform(X)</code>
If <code>X[0]</code> was <code>[-0.75]</code>, then <code>X_poly[0]</code> becomes <code>[-0.75, 0.566]</code> (original X, and X²).</li></ul></li><li><p>Train a Linear Model on Extended Data:
Now, you just fit a standard <code>LinearRegression</code> model to this <code>X_poly</code>:
<code>lin_reg = LinearRegression()</code>
<code>lin_reg.fit(X_poly, y)</code>
The model predictions are shown in Figure 4-13 (page 130). It&rsquo;s a nice curve that fits the data much better than a straight line! The estimated equation (e.g., <code>ŷ = 0.56x₁² + 0.93x₁ + 1.78</code>) is close to the original <code>y = 0.5x₁² + 1.0x₁ + 2.0 + noise</code>.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-13.png alt="Figure 4-13" width=700></figure></p></li><li><p>Multiple Features and Combinations (page 130):
If you have multiple features (say, <code>a</code> and <code>b</code>) and use <code>PolynomialFeatures(degree=3)</code>, it will add <code>a²</code>, <code>a³</code>, <code>b²</code>, <code>b³</code>, AND also the <em>combination terms</em> like <code>ab</code>, <code>a²b</code>, <code>ab²</code>. This allows the model to find relationships <em>between</em> features.</p></li><li><p>Warning: Combinatorial Explosion! (Scorpion icon, page 130)
The number of features can explode if you have many original features and use a high polynomial degree. The formula is <code>(n+d)! / (d!n!)</code> where <code>n</code> is original features, <code>d</code> is degree. Be careful! This can make the model very slow and prone to overfitting.</p></li></ul><h2 id=learning-curves>Learning Curves</h2><p>With high-degree Polynomial Regression, you can fit the training data <em>very</em> well, maybe too well. Figure 4-14 (page 131) shows:<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-14.png alt="Figure 4-14" width=700></figure></p><ul><li>A 300-degree polynomial model: Wiggles wildly to hit every training point. This is severe overfitting.</li><li>A plain linear model: Misses the curve. This is underfitting.</li><li>A quadratic model (2nd degree): Fits best, which makes sense as the data was generated quadratically.</li></ul><p>But how do you know in general if your model is too complex (overfitting) or too simple (underfitting), especially if you don&rsquo;t know the true underlying function?</p><ol><li><p>Cross-Validation (from Chapter 2):</p><ul><li>If model performs well on training data but poorly on cross-validation, it&rsquo;s overfitting.</li><li>If it performs poorly on both, it&rsquo;s underfitting.</li></ul></li><li><p>Learning Curves (page 131):</p><ul><li><p>What they are: Plots of the model&rsquo;s performance (e.g., RMSE) on the training set and the validation set, as a function of the training set size (or training iteration).</p></li><li><p>How to generate them: Train the model multiple times on different-sized subsets of the training set.</p></li><li><p>The book provides a <code>plot_learning_curves</code> function (page 132).</p></li><li><p>Learning Curves for an Underfitting Model (e.g., plain Linear Regression on the quadratic data - Figure 4-15, page 132):<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-15.png alt="Figure 4-15" width=700></figure></p><ul><li>Training error: Starts at 0 (perfect fit with 1-2 instances), then rises as more noisy/nonlinear data is added, eventually plateauing.</li><li>Validation error: Starts very high (model trained on few instances generalizes poorly), then decreases as model learns from more examples, eventually plateauing close to the training error.</li><li>Key characteristics of underfitting curves: Both curves plateau, they are close together, and the error is fairly high.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> The plot tells you that the model is too simple. Adding more training examples <em>will not help</em> if the curves have plateaued (as the scorpion icon on page 133 says). You need a more complex model or better features.</li></ul></li><li><p>Learning Curves for an Overfitting Model (e.g., 10th-degree polynomial on the quadratic data - Figure 4-16, page 133):</p><ul><li>Training error: Much lower than the Linear Regression model&rsquo;s training error. It fits the training data well.</li><li>Validation error: There&rsquo;s a gap between the training error and the validation error. The model performs significantly better on the training data than on the validation data. This is the hallmark of overfitting.</li><li>If you had a much larger training set, these two curves would eventually get closer.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> The plot tells you the model is too complex for the current amount of data. One way to improve an overfitting model is to feed it more training data (as the scorpion icon on page 134 suggests), until the validation error meets the training error (or use regularization, which we&rsquo;ll see next).</li></ul></li></ul></li></ol><ul><li><p>The Bias/Variance Trade-off (sidebar, page 134):
This is a fundamental concept in statistics and ML. A model&rsquo;s generalization error (how well it performs on unseen data) can be expressed as the sum of three components:</p><ol><li>Bias:<ul><li>Error due to wrong assumptions made by the model. E.g., assuming data is linear when it&rsquo;s quadratic.</li><li>A high-bias model is likely to underfit.</li><li><em>What it&rsquo;s ultimately trying to achieve (in a bad way):</em> It has a strong preconceived notion of how the data should look, and it sticks to it even if the data says otherwise.</li></ul></li><li>Variance:<ul><li>Error due to the model&rsquo;s excessive sensitivity to small variations in the training data. A model with many degrees of freedom (like a high-degree polynomial) can have high variance.</li><li>A high-variance model is likely to overfit. It learns the noise in the training data, not just the signal.</li><li><em>What it&rsquo;s ultimately trying to achieve (in a bad way):</em> It tries to fit every little nook and cranny of the training data, making it unstable and perform poorly on new, slightly different data.</li></ul></li><li>Irreducible Error:<ul><li>Error due to the inherent noisiness of the data itself.</li><li>This part cannot be reduced by model changes; only by cleaning the data (e.g., fixing broken sensors, removing outliers).</li></ul></li></ol><p>The Trade-off:</p><ul><li>Increasing model complexity typically <em>increases variance</em> (more likely to overfit) and <em>reduces bias</em> (better fit to complex patterns).</li><li>Decreasing model complexity typically <em>increases bias</em> (more likely to underfit) and <em>reduces variance</em>.
The goal is to find a sweet spot, balancing bias and variance.</li></ul></li></ul><h2 id=regularized-linear-models>Regularized Linear Models</h2><p>We saw that overfitting is a problem with complex models. Regularization is a way to reduce overfitting by <em>constraining</em> the model.</p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> For linear models, this usually means constraining the model&rsquo;s weights. The idea is to prevent the weights from becoming too large, which can happen when the model tries too hard to fit the noise in the training data. Smaller weights generally lead to simpler, smoother models that generalize better.</li></ul><p>The book discusses three types of regularized linear models: Ridge, Lasso, and Elastic Net.</p><ul><li><p>Ridge Regression (also Tikhonov regularization) (page 135):</p><ul><li>It adds a regularization term to the MSE cost function.</li><li>Equation 4-8: Ridge Regression cost function
<code>J(θ) = MSE(θ) + α * (1/2) * Σᵢ (θᵢ)²</code> (sum from i=1 to n, so bias term <code>θ₀</code> is NOT regularized)<ul><li>The regularization term is <code>α * (1/2) * Σᵢ (θᵢ)²</code>. This is <code>α/2</code> times the sum of the squares of the feature weights. This is related to the ℓ₂ norm of the weight vector <code>w = [θ₁, ..., θₙ]</code>, specifically <code>(1/2) * ||w||₂²</code>.</li><li><code>α</code> (alpha) is a hyperparameter that controls how much you want to regularize.<ul><li>If <code>α = 0</code>, it&rsquo;s just Linear Regression.</li><li>If <code>α</code> is very large, all weights <code>θᵢ</code> (for i>0) end up very close to zero, and the model becomes a flat line through the data&rsquo;s mean.</li></ul></li><li><em>What it&rsquo;s ultimately trying to achieve:</em> The learning algorithm is now forced to not only <em>fit the data</em> (minimize MSE) but also keep the model weights <em>as small as possible</em>.</li></ul></li><li>Important: Scale the data (e.g., <code>StandardScaler</code>) <em>before</em> performing Ridge Regression, as it&rsquo;s sensitive to the scale of input features (scorpion icon, page 136). This is true for most regularized models.</li><li>Figure 4-17 (page 136) shows the effect of <code>α</code>:<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-17.png alt="Figure 4-17" width=700></figure><ul><li>Left: Plain Ridge Regression on linear data. Higher <code>α</code> makes predictions flatter.</li><li>Right: Polynomial features (degree=10) + scaling + Ridge. Increasing <code>α</code> leads to flatter (less extreme, more reasonable) predictions, reducing variance but increasing bias.</li></ul></li><li>Training Ridge Regression:<ul><li>Closed-form solution (Equation 4-9, page 137):
<code>θ̂ = (XᵀX + αA)⁻¹ Xᵀy</code> (where <code>A</code> is an identity matrix with a 0 at the top-left for the bias term).
Scikit-Learn&rsquo;s <code>Ridge(alpha=..., solver="cholesky")</code> uses this.</li><li>Gradient Descent (page 137):
Add <code>αw</code> to the MSE gradient vector (where <code>w</code> is the vector of weights, excluding bias).
Scikit-Learn&rsquo;s <code>SGDRegressor(penalty="l2")</code> does this. The <code>"l2"</code> means add a regularization term equal to half the square of the ℓ₂ norm of the weights.</li></ul></li></ul></li><li><p>Lasso Regression (Least Absolute Shrinkage and Selection Operator) (page 137):</p><ul><li>Also adds a regularization term to the MSE cost function, but uses the ℓ₁ norm of the weight vector.</li><li>Equation 4-10: Lasso Regression cost function
<code>J(θ) = MSE(θ) + α * Σᵢ |θᵢ|</code> (sum from i=1 to n)<ul><li>The regularization term is <code>α</code> times the sum of the <em>absolute values</em> of the weights.</li></ul></li><li>Figure 4-18 (page 138) shows Lasso models, similar to Figure 4-17 for Ridge, but with smaller <code>α</code> values.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-18.png alt="Figure 4-18" width=700></figure></li><li>Key characteristic of Lasso: It tends to completely eliminate the weights of the least important features (i.e., set them to zero). It automatically performs feature selection and outputs a sparse model (a model with few non-zero feature weights).</li><li>Why does Lasso do this? (Figure 4-19, page 139):<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-19.png alt="Figure 4-19" width=700></figure><ul><li>This is a bit more advanced, but the intuition comes from looking at the &ldquo;shape&rdquo; of the ℓ₁ penalty vs. the ℓ₂ penalty.</li><li>The ℓ₁ penalty <code>|θ₁| + |θ₂|</code> has &ldquo;corners&rdquo; along the axes in the parameter space. When minimizing the combined MSE + ℓ₁ penalty, the optimization path often hits these corners, forcing one of the parameters to zero.</li><li>The ℓ₂ penalty <code>θ₁² + θ₂²</code> is circular. The optimization path approaches the origin smoothly, shrinking weights but not usually making them exactly zero.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> The ℓ₁ penalty encourages sparsity by pushing less important feature weights all the way to zero.</li></ul></li><li>Training Lasso Regression:<ul><li>The Lasso cost function is not differentiable at <code>θᵢ = 0</code>. However, Gradient Descent can still work if you use a subgradient vector (Equation 4-11, page 140). This is a technical detail; the main idea is that an iterative approach can still find the minimum.</li><li>Scikit-Learn: <code>Lasso(alpha=...)</code> or <code>SGDRegressor(penalty="l1")</code>.</li><li>When using Lasso with GD, you often need to gradually reduce the learning rate to help it converge without bouncing around the optimum (due to the &ldquo;sharp corners&rdquo; of the ℓ₁ penalty).</li></ul></li></ul></li><li><p>Elastic Net (page 140):</p><ul><li>A middle ground between Ridge and Lasso. Its regularization term is a simple mix of both Ridge (ℓ₂) and Lasso (ℓ₁) terms.</li><li>Equation 4-12: Elastic Net cost function
<code>J(θ) = MSE(θ) + rα Σᵢ|θᵢ| + ((1-r)/2)α Σᵢθᵢ²</code><ul><li><code>r</code> is the mix ratio.<ul><li>If <code>r = 0</code>, Elastic Net is equivalent to Ridge.</li><li>If <code>r = 1</code>, Elastic Net is equivalent to Lasso.</li></ul></li></ul></li><li>Scikit-Learn: <code>ElasticNet(alpha=..., l1_ratio=...)</code> (where <code>l1_ratio</code> is <code>r</code>).</li></ul></li><li><p>When to use which? (page 140):</p><ul><li>Plain Linear Regression (no regularization) should generally be avoided. Some regularization is almost always better.</li><li>Ridge is a good default.</li><li>If you suspect only a few features are useful, prefer Lasso or Elastic Net because they perform feature selection by shrinking useless feature weights to zero.</li><li>Elastic Net is generally preferred over Lasso because Lasso can behave erratically when the number of features is greater than the number of training instances, or when several features are strongly correlated. Elastic Net is more stable in these cases.</li></ul></li><li><p>Early Stopping (page 141):</p><ul><li>A very different way to regularize iterative learning algorithms like Gradient Descent.</li><li>The Idea: Stop training as soon as the validation error reaches a minimum.</li><li>Figure 4-20 (page 141) shows a complex model (high-degree polynomial) being trained with Batch GD:<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-20.png alt="Figure 4-20" width=700></figure><ul><li>As epochs go by, training error (RMSE) goes down.</li><li>Validation error also goes down initially, but then starts to go back <em>up</em>. This indicates the model has started to overfit.</li><li>With early stopping, you just stop training when the validation error is at its minimum.</li></ul></li><li>It&rsquo;s a simple and efficient regularization technique. Geoffrey Hinton called it a &ldquo;beautiful free lunch.&rdquo;</li><li>Implementation (page 142):<ul><li>Loop for epochs.</li><li>In each epoch, train the model (e.g., <code>SGDRegressor</code> with <code>warm_start=True</code> so it continues training, <code>max_iter=1</code> so it does one epoch).</li><li>Evaluate on validation set.</li><li>If validation error is less than current <code>minimum_val_error</code>, save the model (clone it) and update <code>minimum_val_error</code> and <code>best_epoch</code>.</li><li>After the loop, the <code>best_model</code> is your regularized model.</li></ul></li><li>With SGD/Mini-batch GD, validation curves are noisy. You might stop only after validation error has been above minimum for a while, then roll back to the best model.</li></ul></li></ul><p>Fantastic! It&rsquo;s great that the intuition behind L1 and L2 regularization clicked. Let&rsquo;s continue our journey through Chapter 4, moving on to models designed for classification.</p><h2 id=logistic-regression>Logistic Regression</h2><p>We&rsquo;ve seen Linear Regression for predicting continuous values. Now, what if we want to predict a class? For example, is an email spam or not spam? This is a binary classification problem.</p><p>The book points out (as we saw in Chapter 1) that some regression algorithms can be adapted for classification. Logistic Regression (also called Logit Regression) is a prime example.</p><ul><li><p>What it&rsquo;s ultimately trying to achieve: Logistic Regression estimates the <em>probability</em> that an instance belongs to a particular class (typically the &ldquo;positive&rdquo; class, labeled &lsquo;1&rsquo;). If this probability is greater than a certain threshold (usually 50%), the model predicts &lsquo;1&rsquo;; otherwise, it predicts &lsquo;0&rsquo;.</p></li><li><p>Estimating Probabilities (Page 143):</p><ol><li>Linear Combination: Just like Linear Regression, it first computes a weighted sum of the input features plus a bias term: <code>t = xᵀθ</code>. (This <code>t</code> is often called the logit).</li><li>Logistic Function (Sigmoid): Instead of outputting <code>t</code> directly, it passes <code>t</code> through the logistic function (also called the sigmoid function), denoted as <code>σ(t)</code>.<ul><li>Equation 4-13: Logistic Regression model estimated probability (vectorized form)
<code>p̂ = h_θ(x) = σ(xᵀθ)</code>
where <code>p̂</code> (p-hat) is the estimated probability that the instance <code>x</code> belongs to the positive class.</li><li>Equation 4-14: Logistic function
<code>σ(t) = 1 / (1 + exp(-t))</code></li><li>Figure 4-21 (page 143) shows the characteristic S-shape of the sigmoid function.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-21.png alt="Figure 4-21" width=700></figure><ul><li><em>What the sigmoid is ultimately trying to achieve:</em> It squashes any input value <code>t</code> (which can range from -∞ to +∞) into an output value between 0 and 1. This output can then be interpreted as a probability.<ul><li>If <code>t</code> is large and positive, <code>exp(-t)</code> is close to 0, so <code>σ(t)</code> is close to 1.</li><li>If <code>t</code> is large and negative, <code>exp(-t)</code> is very large, so <code>σ(t)</code> is close to 0.</li><li>If <code>t = 0</code>, <code>exp(-t) = 1</code>, so <code>σ(t) = 1/2 = 0.5</code>.</li></ul></li></ul></li></ul></li></ol></li><li><p>Making Predictions (Page 143):</p><ul><li>Equation 4-15: Logistic Regression model prediction
<code>ŷ = 0 if p̂ &lt; 0.5</code>
<code>ŷ = 1 if p̂ ≥ 0.5</code></li><li>Since <code>σ(t) ≥ 0.5</code> when <code>t ≥ 0</code>, the model predicts 1 if <code>xᵀθ</code> (the logit) is positive, and 0 if it&rsquo;s negative.</li></ul></li><li><p>Training and Cost Function (Page 144):</p><ul><li>Objective: We want to set the parameter vector <code>θ</code> so that the model estimates a <em>high probability</em> for positive instances (actual y=1) and a <em>low probability</em> for negative instances (actual y=0).</li><li>Cost Function for a Single Instance (Equation 4-16):
<code>c(θ) = -log(p̂) if y = 1</code>
<code>c(θ) = -log(1 - p̂) if y = 0</code><ul><li><em>What this cost function is ultimately trying to achieve:</em><ul><li>If <code>y=1</code> (actual is positive):<ul><li>If model predicts <code>p̂</code> close to 1 (correct), <code>-log(p̂)</code> is close to 0 (low cost).</li><li>If model predicts <code>p̂</code> close to 0 (incorrect), <code>-log(p̂)</code> is very large (high cost).</li></ul></li><li>If <code>y=0</code> (actual is negative):<ul><li>If model predicts <code>p̂</code> close to 0 (so <code>1-p̂</code> is close to 1, correct), <code>-log(1-p̂)</code> is close to 0 (low cost).</li><li>If model predicts <code>p̂</code> close to 1 (so <code>1-p̂</code> is close to 0, incorrect), <code>-log(1-p̂)</code> is very large (high cost).
This cost function penalizes the model heavily when it&rsquo;s confident and wrong.</li></ul></li></ul></li></ul></li><li>Cost Function for the Whole Training Set (Log Loss - Equation 4-17):
<code>J(θ) = - (1/m) * Σᵢ [ y⁽ⁱ⁾log(p̂⁽ⁱ⁾) + (1 - y⁽ⁱ⁾)log(1 - p̂⁽ⁱ⁾) ]</code>
This is just the average cost over all training instances. It&rsquo;s a single, clever expression that combines the two cases from Equation 4-16.</li><li>Good news: This log loss cost function is convex. So, Gradient Descent (or other optimization algorithms) can find the global minimum.</li><li>Bad news: There&rsquo;s no closed-form solution (like the Normal Equation for Linear Regression) to find the <code>θ</code> that minimizes this cost function. We <em>must</em> use an iterative optimization algorithm like Gradient Descent.</li><li>Partial Derivatives (Equation 4-18, page 145):
<code>∂J(θ)/∂θⱼ = (1/m) * Σᵢ (σ(θᵀx⁽ⁱ⁾) - y⁽ⁱ⁾) * xⱼ⁽ⁱ⁾</code><ul><li>This looks very similar to the partial derivative for Linear Regression&rsquo;s MSE (Equation 4-5)!</li><li><code>σ(θᵀx⁽ⁱ⁾)</code> is the predicted probability <code>p̂⁽ⁱ⁾</code>.</li><li><code>(p̂⁽ⁱ⁾ - y⁽ⁱ⁾)</code> is the prediction error.</li><li>This error is multiplied by the feature value <code>xⱼ⁽ⁱ⁾</code> and averaged.
Once you have these gradients, you can use Batch GD, Stochastic GD, or Mini-batch GD to find the optimal <code>θ</code>.</li></ul></li></ul></li><li><p>Decision Boundaries (Page 145-147):
Let&rsquo;s use the Iris dataset to illustrate. We&rsquo;ll try to classify <em>Iris virginica</em> based only on petal width.</p><ul><li>Load data: <code>X = iris["data"][:, 3:]</code> (petal width), <code>y = (iris["target"] == 2).astype(int)</code> (1 if virginica, else 0).</li><li>Train <code>LogisticRegression()</code>:
<code>log_reg = LogisticRegression()</code>
<code>log_reg.fit(X, y)</code></li><li>Figure 4-23 (page 146): Shows estimated probabilities vs. petal width.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-23.png alt="Figure 4-23" width=700></figure><ul><li>The S-shape is clear.</li><li>For petal widths > ~2cm, probability of being <em>Iris virginica</em> is high.</li><li>For petal widths &lt; ~1cm, probability is low.</li><li>The decision boundary (where <code>p̂ = 0.5</code>) is around 1.6 cm. If petal width > 1.6cm, it predicts virginica; otherwise, not virginica.</li></ul></li><li>Figure 4-24 (page 147): Shows decision boundary using two features (petal width and petal length).<ul><li>The dashed line is where the model estimates 50% probability – this is the linear decision boundary.</li><li>Other parallel lines show other probability contours (e.g., 15%, 90%).</li></ul></li><li>Regularization: Logistic Regression models in Scikit-Learn use ℓ₂ regularization by default. The hyperparameter is <code>C</code> (inverse of <code>α</code>): higher <code>C</code> means <em>less</em> regularization.</li></ul></li></ul><h2 id=softmax-regression>Softmax Regression</h2><p>Logistic Regression is for binary classification. What if we have more than two classes, and we want a model that handles them directly (not with OvR/OvO strategies)? Enter Softmax Regression (or Multinomial Logistic Regression).</p><ul><li><p>The Idea:</p><ol><li>For a given instance <code>x</code>, compute a score <code>sₖ(x)</code> for each class <code>k</code>. This is done just like Linear Regression: <code>sₖ(x) = xᵀθ⁽ᵏ⁾</code> (Equation 4-19). Each class <code>k</code> has its own dedicated parameter vector <code>θ⁽ᵏ⁾</code>. These are often stored as rows in a parameter matrix <code>Θ</code>.</li><li>Estimate the probability <code>p̂ₖ</code> that the instance belongs to class <code>k</code> by applying the softmax function (also called normalized exponential) to the scores.<ul><li>Equation 4-20: Softmax function
<code>p̂ₖ = σ(s(x))ₖ = exp(sₖ(x)) / Σⱼ exp(sⱼ(x))</code> (sum over all classes <code>j=1</code> to <code>K</code>)<ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> It takes a vector of arbitrary scores <code>s(x)</code> for all classes, computes the exponential of each score (making them all positive), and then normalizes them by dividing by their sum. The result is a set of probabilities (<code>p̂ₖ</code>) that are all between 0 and 1 and sum up to 1 across all classes. The class with the highest initial score <code>sₖ(x)</code> will get the highest probability <code>p̂ₖ</code>.</li></ul></li></ul></li></ol></li><li><p>Prediction (Equation 4-21, page 149):
The classifier predicts the class <code>k</code> that has the highest estimated probability <code>p̂ₖ</code> (which is simply the class with the highest score <code>sₖ(x)</code>).
<code>ŷ = argmaxₖ p̂ₖ</code></p><ul><li>Softmax Regression predicts only one class at a time (mutually exclusive classes). It&rsquo;s multiclass, not multioutput.</li></ul></li><li><p>Training and Cost Function (Cross Entropy - page 149):<figure><img src=/bookshelf/hands-on-ml/cross-entropy.png alt="Figure 4-23" width=700></figure></p><ul><li>Objective: Estimate a high probability for the <em>target class</em> and low probabilities for other classes.</li><li>Cost Function (Cross Entropy - Equation 4-22):
<code>J(Θ) = - (1/m) * Σᵢ Σₖ yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code><ul><li><code>yₖ⁽ⁱ⁾</code> is the target probability that instance <code>i</code> belongs to class <code>k</code> (usually 1 if it&rsquo;s the target class, 0 otherwise).</li><li><code>p̂ₖ⁽ⁱ⁾</code> is the model&rsquo;s estimated probability that instance <code>i</code> belongs to class <code>k</code>.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> This cost function penalizes the model when it estimates a low probability for the actual target class. It&rsquo;s a common measure for how well a set of estimated class probabilities matches the target classes.</li><li>The sidebar on &ldquo;Cross Entropy&rdquo; (page 150) gives some information theory background – it measures the average number of bits needed to encode events based on your probability estimates vs. the true probabilities. Lower is better.</li><li>When there are only two classes (K=2), this cross-entropy cost function is equivalent to the log loss for Logistic Regression.</li></ul></li><li>Gradient Vector (Equation 4-23, page 150):
<code>∇_θ⁽ᵏ⁾ J(Θ) = (1/m) * Σᵢ (p̂ₖ⁽ⁱ⁾ - yₖ⁽ⁱ⁾) * x⁽ⁱ⁾</code>
This gives the gradient for the parameter vector <code>θ⁽ᵏ⁾</code> of a specific class <code>k</code>. Again, very similar form to previous gradient equations!
You compute this for every class, then use an optimization algorithm (like GD) to find the parameter matrix <code>Θ</code> that minimizes the cost.</li></ul></li><li><p>Using Softmax Regression in Scikit-Learn (page 150):</p><ul><li><code>LogisticRegression</code> can perform Softmax Regression by setting:<ul><li><code>multi_class="multinomial"</code></li><li><code>solver="lbfgs"</code> (or another solver that supports multinomial, like &ldquo;sag&rdquo; or &ldquo;newton-cg&rdquo;)</li><li>It also applies ℓ₂ regularization by default (controlled by <code>C</code>).</li></ul></li><li>Example: Classify Iris flowers into all 3 classes using petal length and width.
<code>X = iris["data"][:, (2, 3)]</code>
<code>y = iris["target"]</code>
<code>softmax_reg = LogisticRegression(multi_class="multinomial", solver="lbfgs", C=10)</code>
<code>softmax_reg.fit(X, y)</code></li><li>To predict: <code>softmax_reg.predict([[5, 2]])</code> might give <code>array([2])</code> (Iris virginica).</li><li>To get probabilities: <code>softmax_reg.predict_proba([[5, 2]])</code> might give <code>[[6.3e-07, 0.057, 0.942]]</code>, meaning 94.2% prob for class 2 (virginica), 5.8% for class 1 (versicolor), and near 0% for class 0 (setosa).</li><li>Figure 4-25 (page 151) shows the decision boundaries. They are linear between any two classes.<figure><img src=/bookshelf/hands-on-ml/ch-4-fig-4-25.png alt="Figure 4-25" width=700></figure></li></ul></li></ul><p>And that brings us to the end of the core content of Chapter 4! We&rsquo;ve gone from simple Linear Regression to Polynomial Regression, learned about diagnosing model fit with learning curves, seen how to regularize models to prevent overfitting (Ridge, Lasso, Elastic Net, Early Stopping), and finally explored Logistic and Softmax Regression for classification tasks.</p><p>The recurring theme for training, especially for models without closed-form solutions, is defining a cost function that captures how &ldquo;bad&rdquo; our model is, and then using an iterative algorithm like Gradient Descent to find the model parameters that minimize this cost. The specific form of the cost function and how predictions are made change from model to model, but the underlying optimization principle is often very similar.</p><p>This chapter is dense, but the concepts are absolutely key for understanding how models actually <em>learn</em>. How are you feeling about Logistic and Softmax Regression? Any particular part of &ldquo;what they are trying to achieve&rdquo; that needs more light?</p><hr><h1 id=glossary>Glossary</h1><h2 id=difference-between-l1-lasso-and-l2-ridge-regularization-lets-break-down-that-intuition-about-the-shapes-and-corners>Difference between L1 (Lasso) and L2 (Ridge) regularization! Let&rsquo;s break down that intuition about the &ldquo;shapes&rdquo; and &ldquo;corners.&rdquo;</h2><p>Imagine we have a model with just two weights, <code>θ₁</code> and <code>θ₂</code>. We want to find the values of <code>θ₁</code> and <code>θ₂</code> that minimize our main cost function (let&rsquo;s say MSE), <em>subject to</em> some penalty on the size of these weights.</p><p>Visualizing the Penalties (Loss Functions for Weights)</p><p>Think of the penalty term as defining a &ldquo;budget&rdquo; or a &ldquo;constraint region&rdquo; for our weights. The optimization process is trying to find the best MSE it can, <em>while staying within or close to this budget defined by the penalty.</em></p><ol><li><p>L₂ Penalty (Ridge): <code>θ₁² + θ₂² ≤ C</code></p><ul><li>The equation <code>θ₁² + θ₂² = constant</code> describes a circle (or a sphere/hypersphere in higher dimensions) centered at the origin (<code>θ₁=0, θ₂=0</code>).</li><li>So, the L2 penalty encourages the weights <code>(θ₁, θ₂)</code> to stay within a circular region around the origin.</li><li>Shape: Smooth and round. No sharp corners.</li><li>Imagine the contours of this penalty function: they are concentric circles.</li></ul></li><li><p>L₁ Penalty (Lasso): <code>|θ₁| + |θ₂| ≤ C</code></p><ul><li>The equation <code>|θ₁| + |θ₂| = constant</code> describes a diamond (or a rotated square in 2D, and a similar shape with &ldquo;pointy&rdquo; corners on the axes in higher dimensions).</li><li>So, the L1 penalty encourages the weights <code>(θ₁, θ₂)</code> to stay within a diamond-shaped region around the origin.</li><li>Shape: Has sharp corners that lie <em>on the axes</em>. For our 2D example, the corners are at points like (C, 0), (-C, 0), (0, C), and (0, -C).</li><li>Imagine the contours of this penalty function: they are concentric diamonds.</li></ul></li></ol><p>Visualizing the Optimization Process (Figure 4-19)</p><p>Now, let&rsquo;s consider the main cost function, the MSE. The contours of the MSE (if we ignore the penalty for a moment) are typically elliptical. The center of these ellipses is the point where MSE is minimized <em>without any regularization</em> – let&rsquo;s call this the &ldquo;unconstrained optimum.&rdquo;</p><p>The regularization process is trying to find a point that:
a. Is on the lowest possible MSE contour (meaning good fit to the data).
b. Satisfies the &ldquo;budget&rdquo; imposed by the L1 or L2 penalty (meaning weights are small).</p><p>This can be visualized as finding the point where an MSE ellipse first &ldquo;touches&rdquo; the boundary of the penalty region (the circle for L2, the diamond for L1).</p><ul><li><p>With L₂ Penalty (Ridge - bottom-right plot in Figure 4-19):</p><ul><li>Imagine an expanding MSE ellipse (as we try to get lower MSE) until it just kisses the circular L2 penalty region.</li><li>Because the circle is smooth and round, the point where the ellipse touches it can be anywhere on the circle&rsquo;s boundary.</li><li>It&rsquo;s very unlikely that this touch point will be <em>exactly</em> on an axis (e.g., where <code>θ₁ = 0</code> or <code>θ₂ = 0</code>).</li><li>Result: The L2 penalty shrinks both <code>θ₁</code> and <code>θ₂</code> towards zero, but it&rsquo;s rare for either of them to become <em>exactly</em> zero. The optimization path (white dots) goes smoothly towards a point where both weights are small but likely non-zero.</li></ul></li><li><p>With L₁ Penalty (Lasso - top-right plot in Figure 4-19):</p><ul><li>Imagine an expanding MSE ellipse until it just kisses the diamond-shaped L1 penalty region.</li><li>Because the diamond has sharp corners <em>on the axes</em>, it&rsquo;s much more likely that the ellipse will first touch the diamond at one of these corners.</li><li>If it touches at a corner on, say, the <code>θ₁</code>-axis, then at that point, <code>θ₂</code> will be <em>exactly zero</em>.</li><li>Result: The L1 penalty also shrinks weights towards zero, but because of its shape, it often forces some weights to become <em>exactly zero</em>. This is the &ldquo;feature selection&rdquo; property. The optimization path (white dots) is shown hitting the <code>θ₂=0</code> axis and then &ldquo;rolling down the gutter&rdquo; along that axis.</li></ul></li></ul><p>Why the &ldquo;Corners&rdquo; Matter for Hitting Zero:</p><p>Think about the gradient (the direction of steepest descent) of the penalty term itself:</p><ul><li>L₂ Penalty: The gradient of <code>θ₁² + θ₂²</code> always points directly towards the origin. It smoothly pulls all weights smaller.</li><li>L₁ Penalty: The gradient of <code>|θ₁| + |θ₂|</code> is a bit trickier.<ul><li>If <code>θ₁ > 0</code>, the derivative w.r.t. <code>θ₁</code> is 1.</li><li>If <code>θ₁ &lt; 0</code>, the derivative w.r.t. <code>θ₁</code> is -1.</li><li>If <code>θ₁ = 0</code>, it&rsquo;s undefined (this is the &ldquo;corner&rdquo;).
This means the L1 penalty applies a constant &ldquo;force&rdquo; (either +1 or -1) pulling a weight towards zero, regardless of how small the weight already is (as long as it&rsquo;s not zero). Once a weight hits zero, this &ldquo;force&rdquo; can effectively keep it there if the pull from the MSE term isn&rsquo;t strong enough to move it away.
In contrast, for L2, the &ldquo;force&rdquo; <code>2θ₁</code> pulling <code>θ₁</code> towards zero gets weaker as <code>θ₁</code> gets smaller. So, it might get very close to zero but not quite hit it unless the MSE term also strongly favors zero.</li></ul></li></ul><p>Intuitive Summary:</p><ul><li>L₂ (Ridge) is like saying: &ldquo;Try to make your weights small, and distribute the &lsquo;smallness&rsquo; somewhat evenly. Keep them inside this round ball.&rdquo; It pulls weights towards zero but doesn&rsquo;t aggressively zero them out.</li><li>L₁ (Lasso) is like saying: &ldquo;Try to make your weights small, and if possible, make some of them <em>exactly</em> zero. Keep them inside this pointy diamond. It&rsquo;s okay to focus your &lsquo;budget&rsquo; on just a few important weights and eliminate the others.&rdquo;</li></ul><p>The &ldquo;corners&rdquo; of the L1 penalty region are key because they represent solutions where one or more weights are exactly zero. The optimization process, in trying to balance minimizing MSE with staying within the L1 budget, often finds its optimal solution precisely at one of these corners.</p><p>Does that help clarify why the <em>shape</em> of the penalty (round vs. pointy with corners on axes) leads to these different behaviors in terms of zeroing out weights?</p><p>Okay, absolutely! Let&rsquo;s revisit Softmax Regression (pages 148-150) and really focus on what it&rsquo;s ultimately trying to achieve, especially in contrast to just using multiple binary Logistic Regressions.</p><p>You&rsquo;re spot on: Logistic Regression is great for &ldquo;is it A or not A?&rdquo; (binary). But what if you have &ldquo;is it A, B, C, or D?&rdquo; (multiclass).</p><p>The Problem with Just Using Multiple Binary Classifiers (OvR/OvO):</p><p>We saw in Chapter 3 that you <em>can</em> use binary classifiers for multiclass problems:</p><ul><li><p>One-vs-Rest (OvR): Train a separate binary Logistic Regression for each class.</p><ul><li>Classifier 1: &ldquo;Is it class A (vs. B, C, D)?&rdquo;</li><li>Classifier 2: &ldquo;Is it class B (vs. A, C, D)?&rdquo;</li><li>&mldr;and so on.</li><li>To make a prediction, you run your input through all these binary classifiers and pick the class whose classifier gives the highest &ldquo;confidence&rdquo; score (or probability, if the binary classifier outputs that).</li></ul></li><li><p>One-vs-One (OvO): Train a binary classifier for every pair of classes (A vs B, A vs C, A vs D, B vs C, etc.). Pick the class that wins the most &ldquo;duels.&rdquo;</p></li></ul><p>Limitations/Quirks of OvR/OvO for Probabilities:</p><p>While these strategies work for getting a class label, there&rsquo;s a slight awkwardness if you want well-calibrated <em>probabilities</em> for each class that naturally sum to 1.</p><ul><li>With OvR, each binary Logistic Regression outputs a probability for <em>its</em> class versus <em>all others</em>. For example, <code>P(A | not A)</code>. These probabilities from different classifiers aren&rsquo;t inherently guaranteed to sum to 1 when you look across all classes for a single instance. You might get <code>P(A)=0.7</code>, <code>P(B)=0.4</code>, <code>P(C)=0.1</code>. These don&rsquo;t sum to 1, and it&rsquo;s not immediately clear how to turn them into a proper probability distribution over A, B, and C. You usually just pick the class with the highest score.</li></ul><h2 id=softmax-regression-the-direct-multiclass-probabilistic-approach>Softmax Regression: The &ldquo;Direct&rdquo; Multiclass Probabilistic Approach</h2><p>Softmax Regression is designed from the ground up to handle multiple classes directly and produce a consistent set of probabilities that sum to 1 across all classes.</p><p>Here&rsquo;s the core idea and &ldquo;what it&rsquo;s trying to achieve&rdquo;:</p><ol><li><p>Goal: For any given input instance (e.g., an image of a digit), we want to output a probability for <em>each possible class</em> (e.g., P(digit is 0), P(digit is 1), &mldr;, P(digit is 9)). Critically, these probabilities should all add up to 100%.</p></li><li><p>Step 1: Calculate a &ldquo;Score&rdquo; for Each Class (Equation 4-19)</p><ul><li>Just like Linear Regression or Logistic Regression, for each class <code>k</code>, Softmax Regression calculates a linear score:
<code>sₖ(x) = xᵀθ⁽ᵏ⁾</code></li><li><code>x</code> is the input feature vector.</li><li><code>θ⁽ᵏ⁾</code> (theta-k) is a <em>separate vector of weights</em> specifically for class <code>k</code>. So, if you have 10 classes (digits 0-9), you will have 10 different <code>θ</code> vectors.</li><li><em>What these scores <code>sₖ(x)</code> are ultimately trying to achieve:</em> They are like raw &ldquo;evidence&rdquo; or &ldquo;suitability scores&rdquo; for each class, given the input <code>x</code>. A higher score <code>sₖ(x)</code> suggests that class <code>k</code> is a more likely candidate for this input. These scores can be any real number (positive, negative, large, small).</li></ul></li><li><p>Step 2: Convert Scores into Probabilities (The Softmax Function - Equation 4-20)</p><ul><li>The raw scores <code>sₖ(x)</code> are not probabilities yet (they don&rsquo;t sum to 1, and they can be negative). We need a way to transform them into a valid probability distribution. This is where the softmax function (also called &ldquo;normalized exponential&rdquo;) comes in.</li><li>For each class <code>k</code>, the probability <code>p̂ₖ</code> is calculated as:
<code>p̂ₖ = exp(sₖ(x)) / Σⱼ exp(sⱼ(x))</code> (where the sum in the denominator is over all possible classes <code>j</code>)</li><li><em>What the softmax function is ultimately trying to achieve:</em><ul><li><code>exp(sₖ(x))</code> (Exponential): First, it takes the exponential of each score. This has two effects:<ul><li>It makes all scores positive (since <code>e</code> to any power is positive).</li><li>It tends to exaggerate differences: if score A is slightly higher than score B, <code>exp(A)</code> will be significantly higher than <code>exp(B)</code>. The &ldquo;softmax&rdquo; is &ldquo;soft&rdquo; in that it doesn&rsquo;t just pick the max score and give it 100% probability, but it does give more weight to higher scores.</li></ul></li><li><code>Σⱼ exp(sⱼ(x))</code> (Sum of Exponentials): It then sums up these positive, exponentiated scores for <em>all</em> classes. This sum acts as a normalization constant.</li><li>Division: Dividing each <code>exp(sₖ(x))</code> by this total sum ensures two things:<ol><li>Each <code>p̂ₖ</code> will be between 0 and 1.</li><li>All the <code>p̂ₖ</code> values will sum up to 1.
So, we get a proper probability distribution across all classes. The class that had the highest initial score <code>sₖ(x)</code> will end up with the largest probability <code>p̂ₖ</code>.</li></ol></li></ul></li></ul></li></ol><p>Analogy for Softmax:</p><p>Imagine you have several candidates for a job (the classes).</p><ol><li>You give each candidate a raw &ldquo;suitability score&rdquo; (the <code>sₖ(x)</code>). Some might be high, some low, some even negative if they seem really unsuitable.</li><li>To decide how to allocate a &ldquo;probability of being hired&rdquo; that sums to 100% across all candidates:<ul><li>You first want to ensure everyone&rsquo;s considered &ldquo;positively&rdquo; and amplify the scores of strong candidates: you &ldquo;exponentiate&rdquo; their scores. A candidate with a score of 3 becomes <code>e³ ≈ 20</code>, while a candidate with a score of 1 becomes <code>e¹ ≈ 2.7</code>. The difference is magnified.</li><li>Then, you add up all these amplified, positive scores to get a &ldquo;total pool of amplified suitability.&rdquo;</li><li>Finally, each candidate&rsquo;s share of this total pool becomes their probability of being hired.</li></ul></li></ol><p>Why is this better than just running multiple OvR Logistic Regressions for probabilities?</p><ul><li>Direct Probabilistic Interpretation: Softmax directly outputs a set of probabilities that are inherently linked and sum to 1. It&rsquo;s designed for this purpose. With OvR Logistic Regression, you&rsquo;d have to do some extra (potentially ad-hoc) normalization step if you wanted the &ldquo;probabilities&rdquo; from different binary classifiers to sum to 1 for a given instance.</li><li>Shared Information During Training (via the cost function): When Softmax Regression is trained (using the cross-entropy cost function, which we&rsquo;ll get to), the updates to the weights <code>θ⁽ᵏ⁾</code> for one class are influenced by the scores and target probabilities of <em>all other classes</em> because of that denominator in the softmax function. This allows the model to learn the relationships and distinctions between all classes simultaneously in a more coupled way. With independent OvR classifiers, each classifier only learns to distinguish its class from &ldquo;everything else&rdquo; without explicitly considering the fine-grained distinctions between those &ldquo;everything else&rdquo; classes.</li></ul><p>Making a Prediction and Training:</p><ul><li>Prediction (Equation 4-21): Once you have the probabilities <code>p̂ₖ</code> for all classes, you simply predict the class <code>k</code> that has the highest probability. This is equivalent to picking the class with the highest initial score <code>sₖ(x)</code>.</li><li>Training (Cross-Entropy Cost Function - Equation 4-22):<ul><li>The goal is to find the parameter matrix <code>Θ</code> (which contains all the <code>θ⁽ᵏ⁾</code> vectors) such that for a given training instance, the predicted probability <code>p̂ₖ</code> is high for the <em>correct</em> class <code>k</code> and low for all other classes.</li><li>The cross-entropy cost function is used for this.
<code>J(Θ) = - (1/m) * Σᵢ Σₖ yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code><ul><li><code>yₖ⁽ⁱ⁾</code> is 1 if class <code>k</code> is the true class for instance <code>i</code>, and 0 otherwise.</li><li><em>What it&rsquo;s ultimately trying to achieve:</em> It heavily penalizes the model if <code>log(p̂ₖ⁽ⁱ⁾)</code> is a large negative number for the <em>true</em> class <code>k</code> (which happens if <code>p̂ₖ⁽ⁱ⁾</code> is close to 0 for the true class). It wants to maximize the log-probability of the correct class.</li></ul></li><li>This cost function is convex, so Gradient Descent can find the optimal <code>Θ</code>. The gradients (Equation 4-23) are computed, and <code>Θ</code> is updated iteratively.</li></ul></li></ul><p>In essence, Softmax Regression is a generalization of Logistic Regression to handle multiple classes by:</p><ol><li>Calculating a linear score for each class.</li><li>Using the softmax function to convert these scores into a proper probability distribution over all classes.</li><li>Being trained with a cost function (cross-entropy) that encourages high probabilities for correct classes.</li></ol><p>It provides a more principled and direct way to get multiclass probabilities compared to trying to combine multiple independent binary logistic regressions.</p><h2 id=focus-on-the-cross-entropy-cost-function>Focus on the Cross-Entropy cost function</h2><p>Let&rsquo;s break it down slowly, focusing on what it&rsquo;s ultimately trying to achieve.</p><p>Recall the equation:
<code>J(Θ) = - (1/m) * Σᵢ Σₖ yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code></p><p>Where:</p><ul><li><code>J(Θ)</code>: The total cost for our model parameters <code>Θ</code>. We want to minimize this.</li><li><code>m</code>: The number of training instances. <code>(1/m)</code> means we&rsquo;re averaging the cost over all instances.</li><li><code>Σᵢ</code>: Sum over all training instances <code>i</code> (from 1 to <code>m</code>).</li><li><code>Σₖ</code>: Sum over all possible classes <code>k</code> (from 1 to <code>K</code>).</li><li><code>yₖ⁽ⁱ⁾</code>: This is the true target probability that instance <code>i</code> belongs to class <code>k</code>.<ul><li>For most classification problems (like digit recognition), this is a &ldquo;one-hot encoded&rdquo; value. If instance <code>i</code> is truly a &lsquo;digit 3&rsquo;, then:<ul><li><code>y₃⁽ⁱ⁾ = 1</code> (the probability of being class &lsquo;3&rsquo; is 100%)</li><li><code>y₀⁽ⁱ⁾ = 0</code>, <code>y₁⁽ⁱ⁾ = 0</code>, <code>y₂⁽ⁱ⁾ = 0</code>, <code>y₄⁽ⁱ⁾ = 0</code>, &mldr;, <code>y₉⁽ⁱ⁾ = 0</code> (the probability of being any other class is 0%).</li></ul></li></ul></li><li><code>p̂ₖ⁽ⁱ⁾</code>: This is the model&rsquo;s predicted probability that instance <code>i</code> belongs to class <code>k</code> (this comes from the softmax function).</li><li><code>log(p̂ₖ⁽ⁱ⁾)</code>: The natural logarithm of the model&rsquo;s predicted probability.</li></ul><p>Understanding the Core Term: <code>yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code></p><p>Let&rsquo;s focus on a single instance <code>i</code> and a single class <code>k</code>.</p><p>The term <code>yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code> is the heart of it.
Since <code>yₖ⁽ⁱ⁾</code> is either 0 or 1 (for the one-hot encoded true label):</p><ol><li><p>Case 1: Class <code>k</code> is NOT the true class for instance <code>i</code>.</p><ul><li>Then <code>yₖ⁽ⁱ⁾ = 0</code>.</li><li>So, <code>yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾) = 0 * log(p̂ₖ⁽ⁱ⁾) = 0</code>.</li><li>This means: For all the classes that are <em>not</em> the true class, this term contributes <em>nothing</em> to the sum <code>Σₖ</code>. This makes sense – we don&rsquo;t directly care about the exact log-probability the model assigns to the incorrect classes, as long as it assigns a high probability to the <em>correct</em> class.</li></ul></li><li><p>Case 2: Class <code>k</code> IS the true class for instance <code>i</code>.</p><ul><li>Then <code>yₖ⁽ⁱ⁾ = 1</code>.</li><li>So, <code>yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾) = 1 * log(p̂ₖ⁽ⁱ⁾) = log(p̂ₖ⁽ⁱ⁾)</code>.</li><li>This means: For the <em>one true class</em>, this term contributes <code>log(p̂ₖ⁽ⁱ⁾)</code> to the sum <code>Σₖ</code>.</li></ul></li></ol><p>So, for a single instance <code>i</code>, the inner sum <code>Σₖ yₖ⁽ⁱ⁾ log(p̂ₖ⁽ⁱ⁾)</code> simplifies to just <code>log(p̂_true_class⁽ⁱ⁾)</code>.
It&rsquo;s the logarithm of the probability that the model assigned to the <em>actual correct class</em> for that instance.</p><p>Why <code>log</code>? And why the negative sign in <code>J(Θ)</code>?</p><p>Now let&rsquo;s consider the <code>log</code> and the overall negative sign in <code>J(Θ) = - (1/m) * Σᵢ log(p̂_true_class⁽ⁱ⁾)</code>.</p><ul><li><p>Probabilities <code>p̂</code> are between 0 and 1.</p></li><li><p>The logarithm of a number between 0 and 1 is always negative (or zero if p̂=1).</p><ul><li><code>log(1) = 0</code></li><li><code>log(0.5) ≈ -0.69</code></li><li><code>log(0.1) ≈ -2.3</code></li><li>As <code>p̂</code> approaches 0, <code>log(p̂)</code> approaches -∞.</li></ul></li><li><p>What the cost function is trying to achieve:</p><ul><li>We want <code>p̂_true_class⁽ⁱ⁾</code> to be as close to 1 as possible. This means our model is very confident and correct.<ul><li>If <code>p̂_true_class⁽ⁱ⁾ = 1</code> (perfect prediction for this instance), then <code>log(p̂_true_class⁽ⁱ⁾) = log(1) = 0</code>.</li><li>The negative sign makes it <code>-0 = 0</code>. This is the <em>minimum possible cost</em> for this instance. Good!</li></ul></li><li>We want to heavily penalize the model if <code>p̂_true_class⁽ⁱ⁾</code> is close to 0. This means our model is very confident but <em>wrong</em> about the true class.<ul><li>If <code>p̂_true_class⁽ⁱ⁾</code> is very small (e.g., 0.0001), then <code>log(p̂_true_class⁽ⁱ⁾)</code> is a large negative number (e.g., <code>log(0.0001) ≈ -9.2</code>).</li><li>The negative sign in <code>J(Θ)</code> makes this <code>- (large negative number) = large positive number</code>. This is a <em>very high cost</em>. Good! This is what we want the cost function to do – penalize bad, confident predictions for the true class.</li></ul></li></ul></li></ul><p>So, minimizing <code>J(Θ) = - Σ log(p̂_true_class)</code> is equivalent to maximizing <code>Σ log(p̂_true_class)</code>.
And since <code>log</code> is a monotonically increasing function, maximizing the sum of log-probabilities is equivalent to maximizing the product of the probabilities (this is related to Maximum Likelihood Estimation, a very common principle in statistics and machine learning).</p><p>In simpler terms, the cross-entropy cost function is ultimately trying to:</p><ul><li>Make the model assign the highest possible probability to the correct class for each training example.</li><li>It does this by looking at the logarithm of the predicted probability for the true class.</li><li>A perfect score (probability 1 for the true class) results in a log-probability of 0, contributing zero to the (negative) cost.</li><li>A very poor score (probability near 0 for the true class) results in a very large negative log-probability, which, when negated by the cost function, becomes a very large positive cost.</li><li>The cost function therefore &ldquo;rewards&rdquo; the model for being confident and correct, and heavily &ldquo;punishes&rdquo; it for being confident and incorrect (or even just very uncertain about the correct class).</li></ul><p>Connection to Information Theory (as mentioned in the sidebar):</p><p>Cross-entropy is a concept from information theory.</p><ul><li>Imagine you have a true distribution of events <code>y</code> (e.g., true digit classes).</li><li>You have a model that produces a predicted distribution <code>p̂</code>.</li><li>Cross-entropy <code>H(y, p̂)</code> measures the average number of bits you would need to encode an event drawn from the true distribution <code>y</code>, if you used an encoding scheme optimized for your predicted distribution <code>p̂</code>.</li><li>If your predicted distribution <code>p̂</code> perfectly matches the true distribution <code>y</code>, then the cross-entropy is minimized and is equal to the <em>entropy</em> of <code>y</code> itself (the inherent minimum bits needed to describe <code>y</code>).</li><li>If <code>p̂</code> is different from <code>y</code>, the cross-entropy will be higher. The difference <code>H(y, p̂) - H(y)</code> is called the Kullback-Leibler (KL) divergence, which measures how much your predicted distribution diverges from the true one.</li></ul><p>So, when we minimize the cross-entropy cost function, we are essentially trying to make our model&rsquo;s predicted probability distribution <code>p̂</code> as close as possible to the true underlying distribution <code>y</code> of the class labels.</p><p>Why is it better than, say, trying to minimize the squared error between <code>p̂</code> and <code>y</code> for classification?</p><ol><li>Range of Output: <code>p̂</code> from softmax is a probability (0 to 1). <code>y</code> is usually 0 or 1. Squared error <code>(p̂ - y)²</code> could work, but log loss (cross-entropy) has properties that often make optimization more stable and faster, especially for probabilities.</li><li>Penalizing Confident Wrong Predictions: The <code>log</code> term in cross-entropy means that if the model predicts a very low probability (near 0) for the true class, the cost goes towards infinity. This is a very strong penalty. Squared error doesn&rsquo;t penalize confident wrong predictions as harshly. For <code>y=1</code>, if <code>p̂=0.01</code>, squared error is <code>(0.01-1)² ≈ 0.98</code>. If <code>p̂=0.0001</code>, squared error is <code>(0.0001-1)² ≈ 0.9998</code>. The increase isn&rsquo;t as dramatic as <code>log(0.01)</code> vs <code>log(0.0001)</code>.</li><li>Mathematical Properties for Gradient Descent: The gradients derived from the cross-entropy cost function for models like Softmax Regression (and logistic regression) have a nice, simple form (as seen in Equation 4-23), which is computationally convenient.</li></ol><p>This cost function is the workhorse for most classification problems where the model outputs probabilities. It effectively pushes the model to be accurate and appropriately confident in its predictions for the correct classes.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>