<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class=book-single><h1>Chapter 18: Reinforcement Learning</h1><span class=reading-time><em>18 min read</em></span><div class=book-details><div class=book-content><p><strong>(Page 609: Introduction - The Excitement of RL)</strong></p><p>The chapter starts by highlighting that <strong>Reinforcement Learning (RL)</strong> is one of the most exciting fields in Machine Learning today, yet it&rsquo;s also one of the oldest, with roots in the 1950s.</p><ul><li><strong>Historical Applications:</strong> It has seen interesting applications over the years, particularly in games (like TD-Gammon, a Backgammon program) and machine control, but it didn&rsquo;t often make headline news.</li><li><strong>The DeepMind Revolution (2013 onwards):</strong> A major turning point occurred in 2013 when researchers from DeepMind (a British startup, later bought by Google) demonstrated a system that could learn to play almost any Atari game from scratch, using only raw pixel inputs and no prior knowledge of the game rules. It eventually outperformed humans in most of them.<ul><li>This was followed by a series of amazing feats, most famously <strong>AlphaGo</strong> defeating legendary Go player Lee Sedol in 2016 and world champion Ke Jie in 2017. This was a monumental achievement, as Go is an incredibly complex game.</li></ul></li><li><strong>The &ldquo;Simple&rdquo; Idea Behind DeepMind&rsquo;s Success:</strong> With hindsight, the core idea was to apply the power of <strong>Deep Learning</strong> (which we&rsquo;ve been studying) to the field of Reinforcement Learning. The combination proved to be incredibly effective.</li><li><strong>Current State:</strong> The field of RL is now &ldquo;boiling with new ideas&rdquo; and has a wide range of potential applications.</li></ul><p><strong>Chapter Goals:</strong></p><ol><li>Explain what Reinforcement Learning is and what it&rsquo;s good at.</li><li>Present two of the most important techniques in <strong>Deep Reinforcement Learning (DRL)</strong>:<ul><li><strong>Policy Gradients (PG)</strong></li><li><strong>Deep Q-Networks (DQNs)</strong></li><li>This will include a discussion of <strong>Markov Decision Processes (MDPs)</strong>, which provide a formal framework for RL problems.</li></ul></li><li>Use these techniques to train models for classic RL tasks (e.g., balancing a pole on a cart).</li><li>Introduce the <strong>TF-Agents library</strong> (a TensorFlow library for RL) to build powerful RL systems and train an agent to play the Atari game Breakout.</li><li>Briefly look at some of the latest advances in the field.</li></ol><p><em>What this chapter is ultimately trying to achieve:</em> To give you a solid understanding of the fundamental principles of Reinforcement Learning, how deep learning is used to enhance it, and how to start building and training RL agents.*</p><p><strong>(Page 610-611: Learning to Optimize Rewards)</strong></p><p>This is the core definition of what RL is all about.</p><ul><li><strong>The Setup:</strong><ul><li>A <strong>software agent</strong> (our learning algorithm or program).</li><li>Makes <strong>observations</strong> from an <strong>environment</strong>.</li><li>Takes <strong>actions</strong> within that environment.</li><li>In return, it receives <strong>rewards</strong> (or penalties).</li></ul></li><li><strong>The Objective of the Agent:</strong> To learn to act in a way that will <strong>maximize its expected cumulative rewards over time.</strong></li><li><strong>Anthropomorphic View:</strong><ul><li>Positive rewards = &ldquo;pleasure.&rdquo;</li><li>Negative rewards = &ldquo;pain.&rdquo;</li><li>The agent learns by <strong>trial and error</strong> to maximize its pleasure and minimize its pain.</li></ul></li><li><strong>Broad Applicability:</strong> This is a very general framework.<ul><li><strong>Examples (Figure 18-1, page 611):</strong><ul><li><strong>a. Robotics:</strong> Agent is the robot&rsquo;s control program. Environment is the real world. Observations from sensors. Actions are motor commands. Rewards for reaching a target, penalties for wasting time/going wrong.</li><li><strong>b. Ms. Pac-Man:</strong> Agent is the game-playing program. Environment is the Atari game simulation. Actions are joystick moves. Observations are game screenshots. Rewards are game points.</li><li><strong>c. Go Player:</strong> Similar to Ms. Pac-Man, but for a board game.</li><li><strong>d. Smart Thermostat:</strong> Doesn&rsquo;t have to be a &ldquo;moving&rdquo; agent. Agent learns to anticipate human needs. Rewards for target temperature and energy saving, penalties if humans have to adjust it.</li><li><strong>e. Automatic Stock Trader:</strong> Observes market prices, decides to buy/sell. Rewards are monetary gains/losses.</li></ul></li></ul></li><li><strong>Nature of Rewards:</strong><ul><li>Rewards don&rsquo;t have to be positive. An agent in a maze might get a negative reward at every time step, so its goal is to find the exit as quickly as possible (to minimize total negative reward).</li></ul></li><li><strong>Other Applications:</strong> Self-driving cars, recommender systems, ad placement, controlling where an image classification system should focus its attention.</li></ul><p><em>What &ldquo;Learning to Optimize Rewards&rdquo; is ultimately trying to achieve:</em> It&rsquo;s about training an agent to develop a strategy (a &ldquo;policy&rdquo;) that leads to the best possible long-term outcomes, as measured by the sum of rewards it receives from the environment.* This is different from supervised learning (where you have explicit correct labels) and unsupervised learning (where you&rsquo;re finding structure in unlabeled data). In RL, the &ldquo;supervision&rdquo; comes from the sparse and often delayed reward signals.</p><p><strong>(Page 612-613: Policy Search)</strong></p><ul><li><p><strong>What is a Policy?</strong></p><ul><li>The algorithm or strategy a software agent uses to determine its actions is called its <strong>policy</strong>.</li><li><em>What a policy is ultimately trying to achieve:</em> It&rsquo;s the agent&rsquo;s &ldquo;brain&rdquo; or decision-making function. Given an observation from the environment, the policy outputs an action to take.</li><li>The policy could be a simple rule-based system, a lookup table, or, very commonly in Deep RL, a <strong>neural network</strong> (Figure 18-2). The neural network would take observations as input and output the action (or probabilities for actions).</li></ul></li><li><p><strong>Types of Policies:</strong></p><ul><li><strong>Deterministic:</strong> For a given observation, always outputs the same action.</li><li><strong>Stochastic:</strong> For a given observation, outputs a probability distribution over possible actions. The action is then sampled from this distribution.<ul><li>Example: A robotic vacuum cleaner&rsquo;s policy might be:<ul><li>Move forward with probability <code>p</code> each second.</li><li>Randomly rotate left or right (with probability <code>1-p</code>) by a random angle between <code>-r</code> and <code>+r</code>.</li></ul></li><li>This randomness (stochasticity) ensures the robot explores its environment. The question is, what values of <code>p</code> and <code>r</code> will maximize the dust collected in 30 minutes?</li></ul></li></ul></li><li><p><strong>Policy Search:</strong></p><ul><li>The process of finding the best policy parameters (like <code>p</code> and <code>r</code> in the vacuum example, or the weights of a neural network policy).</li><li><em>What policy search is ultimately trying to achieve:</em> To find the settings for the agent&rsquo;s decision-making process that lead to the maximum cumulative reward.</li></ul></li><li><p><strong>Methods for Policy Search:</strong></p><ol><li><p><strong>Brute Force (Figure 18-3, page 613):</strong></p><ul><li>Try out many different values for the policy parameters.</li><li>Pick the combination that performs best.</li><li>This is like searching for a needle in a haystack if the <strong>policy space</strong> (the set of all possible parameter combinations) is large, which it usually is.</li></ul></li><li><p><strong>Genetic Algorithms (Page 612):</strong></p><ul><li>An evolutionary approach.</li><li>Start with a first generation of, say, 100 randomly created policies.</li><li>Try them all out in the environment.</li><li>&ldquo;Kill&rdquo; the worst-performing ones (e.g., the bottom 80).</li><li>Let the survivors &ldquo;reproduce&rdquo; to create the next generation. Offspring are copies of their parent(s) plus some random variation (mutation).</li><li>Iterate through generations until a good policy is found.</li><li>(Footnote 8 mentions NEAT - NeuroEvolution of Augmenting Topologies - as an interesting example).</li></ul></li><li><p><strong>Optimization Techniques (Policy Gradients - Page 613):</strong></p><ul><li>This is a more direct approach that we&rsquo;ll focus on later in the chapter.</li><li>Evaluate the <strong>gradients of the rewards</strong> with respect to the policy parameters.</li><li>Tweak the parameters by following these gradients <em>towards higher rewards</em>. This is called <strong>Gradient Ascent</strong> (like Gradient Descent, but we want to <em>maximize</em> rewards, not minimize a cost).</li><li>Example (vacuum robot): Slightly increase <code>p</code> (probability of moving forward). Does it pick up more dust? If yes, increase <code>p</code> more. If no, reduce <code>p</code>.</li><li>This approach is called <strong>Policy Gradients (PG)</strong>.</li></ul></li></ol></li></ul><p><strong>The Need for an Environment to Train In:</strong></p><p>Before we can implement Policy Gradients (or most RL algorithms), we need an environment for the agent to interact with. This is a major challenge in RL.</p><ul><li>For Atari games, you need an Atari game simulator.</li><li>For a walking robot, the environment is the real world (with limitations: can&rsquo;t easily undo mistakes, can&rsquo;t speed up time, expensive to run many robots in parallel).</li><li>So, <strong>simulated environments</strong> are crucial, at least for initial &ldquo;bootstrap&rdquo; training.<ul><li>Libraries like PyBullet or MuJoCo are used for 3D physics simulation.</li></ul></li></ul><p><strong>(Page 613-616: Introduction to OpenAI Gym)</strong></p><p>This is where <strong>OpenAI Gym</strong> comes in.</p><ul><li><p><strong>What it is:</strong> A toolkit that provides a wide variety of <strong>simulated environments</strong> for RL.</p><ul><li>Atari games, board games, 2D and 3D physical simulations, etc.</li><li>It&rsquo;s a standard platform to train agents, compare different RL algorithms, or develop new ones.</li></ul></li><li><p><strong>Setting up OpenAI Gym (Page 614):</strong></p><ul><li>Activate your virtual environment (if using one).</li><li><code>pip install -U gym</code></li><li>May need extra libraries for rendering some environments (e.g., Mesa OpenGL Utility on Ubuntu).</li></ul></li><li><p><strong>Using OpenAI Gym - Example with CartPole (Page 614):</strong>
The CartPole environment (Figure 18-4, page 615) is a classic RL &ldquo;hello world.&rdquo;</p><ul><li>A cart can move left or right.</li><li>A pole is attached to the cart.</li><li><strong>Goal:</strong> Keep the pole balanced upright for as long as possible.</li></ul><ol><li><strong>Create an environment:</strong>
<code>import gym</code>
<code>env = gym.make("CartPole-v1")</code></li><li><strong>Reset the environment:</strong> Must be done before starting an episode. Returns the initial observation.
<code>obs = env.reset()</code>
<code>print(obs)</code> might give <code>array([-0.0125..., -0.0015..., 0.0420..., -0.0018...])</code><ul><li><strong>Observations:</strong> Depend on the environment. For CartPole:<ul><li>A 1D NumPy array with 4 floats:<ol><li>Cart horizontal position (0.0 = center).</li><li>Cart velocity (positive = right).</li><li>Pole angle (0.0 = vertical).</li><li>Pole angular velocity (positive = clockwise).</li></ol></li></ul></li></ul></li><li><strong>Render the environment (optional, for visualization - page 615):</strong>
<code>env.render()</code> (Opens a window showing the cart and pole).<ul><li>If on a headless server (no screen), rendering will fail unless you use a fake X server like Xvfb.</li><li><code>env.render(mode="rgb_array")</code> returns the image as a NumPy array.</li></ul></li><li><strong>Check Possible Actions (Page 615):</strong>
<code>print(env.action_space)</code> gives <code>Discrete(2)</code>.<ul><li>This means there are 2 discrete actions: integers 0 and 1.</li><li>For CartPole: 0 = accelerate left, 1 = accelerate right.</li><li>Other environments might have more actions, or continuous action spaces (e.g., apply force between -1.0 and 1.0).</li></ul></li><li><strong>Take a Step in the Environment (Page 616):</strong>
<code>action = 1 # accelerate right</code>
<code>obs, reward, done, info = env.step(action)</code>
The <code>step()</code> method executes the chosen <code>action</code> and returns four values:<ul><li><code>obs</code>: The <strong>new observation</strong> after the action.</li><li><code>reward</code>: The reward received for taking that action in the previous state.<ul><li>For CartPole: You get a reward of 1.0 at <em>every step</em>, no matter what you do.</li><li><em>What this reward structure ultimately trying to achieve:</em> The agent&rsquo;s goal is to keep the episode running as long as possible (to accumulate as many +1 rewards as possible).</li></ul></li><li><code>done</code>: A boolean. <code>True</code> if the episode is over.<ul><li>For CartPole, this happens if:<ul><li>Pole tilts too much.</li><li>Cart goes off the screen.</li><li>After 200 steps (in this version, a limit often exists). In this case, you&rsquo;ve &ldquo;won&rdquo; the episode.</li></ul></li><li>After <code>done</code> is <code>True</code>, you <em>must</em> call <code>env.reset()</code> before using it again.</li></ul></li><li><code>info</code>: An environment-specific dictionary with extra information (often empty, but can be useful for debugging or specific tasks, e.g., number of lives left in a game).</li></ul></li><li><strong>Close the Environment:</strong>
When done: <code>env.close()</code> to free resources.</li></ol></li><li><p><strong>Simple Hardcoded Policy Example (Page 617):</strong>
Let&rsquo;s try a very simple policy: if pole angle (<code>obs</code>) &lt; 0 (leaning left), accelerate left (action 0). If angle ≥ 0 (leaning right or vertical), accelerate right (action 1).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>basic_policy</span>(obs):
</span></span><span style=display:flex><span>    angle <span style=color:#f92672>=</span> obs[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>if</span> angle <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>totals <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> episode <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>500</span>):
</span></span><span style=display:flex><span>    episode_rewards <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    obs <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>reset()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> step <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>200</span>): <span style=color:#75715e># Max 200 steps per episode for CartPole-v1</span>
</span></span><span style=display:flex><span>        action <span style=color:#f92672>=</span> basic_policy(obs)
</span></span><span style=display:flex><span>        obs, reward, done, info <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>step(action)
</span></span><span style=display:flex><span>        episode_rewards <span style=color:#f92672>+=</span> reward
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> done:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    totals<span style=color:#f92672>.</span>append(episode_rewards)
</span></span></code></pre></div><ul><li>Run this for 500 episodes.</li><li>Result: <code>np.mean(totals)</code> is around 41-42. <code>np.max(totals)</code> might be around 68.</li><li>This means this simple policy can&rsquo;t even keep the pole up for the full 200 steps on average. Not great. The cart tends to oscillate more and more until the pole falls.</li></ul></li></ul><p><strong>Key Takeaway from OpenAI Gym Introduction:</strong>
OpenAI Gym provides a standardized way to interact with various simulated environments, which is essential for developing and testing RL algorithms. The core interaction loop is: <code>reset -> loop (get action from policy, step, observe reward/done) -> close</code>.</p><p><strong>(Page 617-618: Neural Network Policies)</strong></p><p>We just saw a simple, hardcoded policy for CartPole. Now, let&rsquo;s create a policy using a neural network.</p><ul><li><p><strong>Input:</strong> The neural network will take an <strong>observation</strong> from the environment as input.</p></li><li><p><strong>Output:</strong> It will output the <strong>action to be executed</strong>.</p></li><li><p><strong>Stochastic Policy (More Precisely):</strong> The neural network will usually estimate a <strong>probability for each possible action</strong>. We then select an action <em>randomly</em> according to these estimated probabilities (Figure 18-5, page 618).</p><ul><li><strong>CartPole Example:</strong><ul><li>Two possible actions: 0 (left) and 1 (right).</li><li>We only need <strong>one output neuron</strong> in our neural network.</li><li>This neuron will output <code>p</code>, the probability of action 0 (going left).</li><li>The probability of action 1 (going right) will then be <code>1 - p</code>.</li><li>If the network outputs <code>p = 0.7</code>, we&rsquo;ll pick action 0 with 70% probability and action 1 with 30% probability.</li></ul></li></ul></li><li><p><strong>Why Pick Randomly (Exploration vs. Exploitation - Page 618)?</strong></p><ul><li>Why not just always pick the action with the highest estimated probability (greedy approach)?</li><li>This is the classic <strong>exploration vs. exploitation dilemma</strong> in RL.<ul><li><strong>Exploitation:</strong> Choosing actions that are known to give good rewards based on current knowledge.</li><li><strong>Exploration:</strong> Trying out new actions to discover potentially even better rewards or to learn more about the environment.</li></ul></li><li>If you <em>only</em> exploit, you might get stuck with a suboptimal policy because you never try actions that could lead to better long-term outcomes. (Analogy: always ordering your favorite dish at a restaurant and never trying others that might be even better).</li><li>Sampling actions based on their probabilities allows the agent to strike a balance: mostly picking actions it thinks are good, but occasionally trying out less probable ones.</li></ul></li><li><p><strong>Considering Past Actions/Observations (State Representation - Page 618):</strong></p><ul><li><strong>CartPole Simplicity:</strong> In the CartPole environment, each observation (<code>cart position</code>, <code>cart velocity</code>, <code>pole angle</code>, <code>pole angular velocity</code>) contains the <em>environment&rsquo;s full state</em>. Past actions and observations can be safely ignored because the current observation tells you everything you need to know about the current situation.</li><li><strong>Hidden State in the Environment:</strong> If the environment had some hidden state (i.e., the observation doesn&rsquo;t fully describe the situation), then the agent might need to consider past actions and observations to infer the true state.<ul><li>Example: If the environment only revealed cart position but not velocity, the agent would need to look at the current and previous positions to estimate velocity.</li><li>Example: If observations are noisy, an agent might want to average a few past observations to get a more stable estimate of the current state.</li></ul></li><li><em>What this means for policy design:</em> For simple, fully observable environments like CartPole, a policy that only looks at the current observation is sufficient. For partially observable environments, the policy (or the agent&rsquo;s architecture) might need some form of memory (like an RNN, or by explicitly feeding sequences of observations).</li></ul></li><li><p><strong>Building the Neural Network Policy with <code>tf.keras</code> (Page 619):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> tensorflow <span style=color:#66d9ef>as</span> tf
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> tensorflow <span style=color:#f92672>import</span> keras
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n_inputs <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> <span style=color:#75715e># For CartPole: env.observation_space.shape[0]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>model <span style=color:#f92672>=</span> keras<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>5</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elu&#34;</span>, input_shape<span style=color:#f92672>=</span>[n_inputs]),
</span></span><span style=display:flex><span>    keras<span style=color:#f92672>.</span>layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;sigmoid&#34;</span>) <span style=color:#75715e># Output probability of action 0 (left)</span>
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><ul><li><strong>Input Layer:</strong> Implicitly defined by <code>input_shape=[n_inputs]</code> in the first <code>Dense</code> layer. <code>n_inputs</code> is 4 for CartPole.</li><li><strong>Hidden Layer:</strong> A single <code>Dense</code> layer with 5 neurons and &ldquo;elu&rdquo; activation. This is a simple problem, so a small hidden layer is likely sufficient.</li><li><strong>Output Layer:</strong> A single <code>Dense</code> neuron with &ldquo;sigmoid&rdquo; activation.<ul><li><em>Why sigmoid?</em> Sigmoid outputs a value between 0 and 1, which is perfect for representing the probability <code>p</code> of choosing action 0 (left).</li><li>If there were more than two possible actions (e.g., up, down, left, right), we would use one output neuron <em>per action</em> and a <strong>softmax</strong> activation function in the output layer to get a probability distribution over all actions.</li></ul></li></ul></li></ul><p>We now have a neural network policy! It takes observations and outputs action probabilities.
<strong>The Big Question:</strong> But how do we <em>train</em> it? We don&rsquo;t have explicit &ldquo;correct action&rdquo; labels like in supervised learning. This is where the &ldquo;credit assignment problem&rdquo; comes in.</p><p><strong>Key Takeaway for Neural Network Policies:</strong>
Neural networks provide a flexible and powerful way to define an agent&rsquo;s policy, mapping observations to action probabilities. Using probabilities allows for a natural way to balance exploration and exploitation. The next step is to figure out how to adjust the network&rsquo;s weights based on the rewards received.</p><p>Perfect! That concept of a neural network outputting action probabilities, which then guide the agent&rsquo;s choices (allowing for exploration), is fundamental to many RL approaches.</p><p>Now we hit a core challenge in Reinforcement Learning: <strong>Evaluating Actions: The Credit Assignment Problem</strong> (Pages 619-620).</p><p><strong>(Page 619: Evaluating Actions: The Credit Assignment Problem)</strong></p><p>We have our neural network policy that can suggest actions. But how do we train it?</p><ul><li><p><strong>If we knew the <em>best</em> action at each step:</strong> We could just do supervised learning. We&rsquo;d train the network to output a high probability for the &ldquo;correct&rdquo; action and low probabilities for others, likely by minimizing cross-entropy between its output distribution and the target distribution (which would be a one-hot vector for the correct action).</p></li><li><p><strong>The RL Reality:</strong> The <em>only guidance</em> the agent gets is through <strong>rewards</strong>, and these rewards are typically:</p><ul><li><strong>Sparse:</strong> You don&rsquo;t get a reward after every single action. You might only get a reward at the very end of an episode (e.g., winning or losing a game).</li><li><strong>Delayed:</strong> The action that truly led to a future reward might have occurred many steps earlier.</li></ul></li><li><p><strong>The Credit Assignment Problem:</strong></p><ul><li>When an agent receives a reward (positive or negative), it&rsquo;s hard for it to know <strong>which of its past actions actually contributed to that reward (or penalty)</strong>.</li><li>Example: If the CartPole agent balances the pole for 100 steps and then it falls, was the 100th action solely responsible? Probably not. Some earlier actions were good (kept it balanced), and some (perhaps the last few) were bad.</li><li>Analogy: Rewarding a dog hours after it behaved well. Will the dog understand what it&rsquo;s being rewarded for? Unlikely.</li><li><em>What the credit assignment problem is ultimately trying to solve:</em> How do we assign &ldquo;credit&rdquo; or &ldquo;blame&rdquo; to individual actions in a sequence when the feedback (reward) is sparse and delayed?</li></ul></li><li><p><strong>Common Strategy: Sum of Discounted Future Rewards (Returns)</strong></p><ul><li>To tackle this, a common strategy is to evaluate an action based on the <strong>sum of all the rewards that come <em>after</em> it</strong> in that episode.</li><li>Usually, we apply a <strong>discount factor <code>γ</code> (gamma)</strong> at each step.</li><li>This sum of discounted rewards is called the <strong>return</strong> for that action.</li><li><strong>Figure 18-6 (page 620)</strong> illustrates this:<ul><li>Agent takes action <code>A₁</code> -> gets <code>R₁ = +10</code></li><li>Agent takes action <code>A₂</code> -> gets <code>R₂ = 0</code></li><li>Agent takes action <code>A₃</code> -> gets <code>R₃ = -50</code></li><li>Assume discount factor <code>γ = 0.8</code>.</li><li><strong>Return for action <code>A₁</code>:</strong> <code>G₁ = R₁ + γ*R₂ + γ²*R₃ = 10 + (0.8 * 0) + (0.8² * -50) = 10 + 0 + (0.64 * -50) = 10 - 32 = -22</code>.</li><li><strong>Return for action <code>A₂</code>:</strong> <code>G₂ = R₂ + γ*R₃ = 0 + (0.8 * -50) = -40</code>.</li><li><strong>Return for action <code>A₃</code>:</strong> <code>G₃ = R₃ = -50</code>.</li></ul></li><li><strong>Discount Factor <code>γ</code>:</strong><ul><li>A value between 0 and 1.</li><li>If <code>γ</code> is close to 0: Future rewards don&rsquo;t count for much compared to immediate rewards. The agent becomes very &ldquo;short-sighted.&rdquo;</li><li>If <code>γ</code> is close to 1: Rewards far into the future count almost as much as immediate rewards. The agent becomes more &ldquo;far-sighted.&rdquo;</li><li>Typical values: 0.9 to 0.99.</li><li>For CartPole, actions have fairly short-term effects, so <code>γ = 0.95</code> is suggested as reasonable. (With <code>γ=0.95</code>, rewards 13 steps ahead are discounted by about half: <code>0.95¹³ ≈ 0.5</code>).</li></ul></li></ul></li><li><p><strong>From Returns to Action Advantage (Page 620, bottom):</strong></p><ul><li>A good action might be followed by a sequence of unlucky bad actions by the agent, leading to a low return for that initially good action.</li><li>However, if we run <strong>many episodes</strong>, on average, good actions will tend to get higher returns than bad ones.</li><li>We want to estimate how much better or worse an action is <em>compared to other possible actions on average</em>. This is called the <strong>action advantage</strong>.</li><li><strong>Estimating Advantage:</strong><ol><li>Run many episodes.</li><li>For each action taken in each episode, calculate its return (sum of discounted future rewards for that episode).</li><li><strong>Normalize</strong> all these action returns across all episodes (e.g., by subtracting the mean of all returns and dividing by their standard deviation).</li><li>After normalization:<ul><li>Actions with a <strong>positive advantage</strong> were probably good.</li><li>Actions with a <strong>negative advantage</strong> were probably bad.</li></ul></li></ol></li></ul></li><li><p><strong>The &ldquo;Perfect&rdquo; Moment:</strong> Now that we have a way to evaluate each action (by its normalized advantage), we are ready to train our first agent using <strong>Policy Gradients</strong>.</p></li></ul><p><strong>Key Takeaway for Credit Assignment and Returns:</strong>
The core challenge is linking delayed rewards back to the actions that caused them.</p><ul><li>The <strong>return</strong> (sum of discounted future rewards) is a way to estimate the long-term value of taking an action from a certain state.</li><li>By running many episodes and <strong>normalizing these returns into advantages</strong>, we get a good signal about which actions were &ldquo;good&rdquo; (positive advantage) and which were &ldquo;bad&rdquo; (negative advantage).</li><li><em>What this process is ultimately trying to achieve:</em> To generate a learning signal for each action taken, even if the explicit reward from the environment is sparse or delayed. This learning signal (the advantage) will tell the policy gradient algorithm whether to make that action more or less likely in the future.</li></ul><p>This concept of discounted returns is fundamental to many RL algorithms. It&rsquo;s how we assign value to actions that don&rsquo;t necessarily yield immediate rewards.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>