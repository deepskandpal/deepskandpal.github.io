<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul></nav></header><main><article class=book-single><h1>Chapter 3: Classification</h1><span class=reading-time><em>19 min read</em></span><div class=book-details><div class=book-content><p>This chapter is all about systems that predict a <em>category</em> or a <em>class</em> – Is this email spam or not? Is this image a cat or a dog? Is this handwritten digit a &lsquo;5&rsquo; or a &lsquo;3&rsquo;?</p><p>And speaking of handwritten digits, we&rsquo;re going to be working with a very famous dataset: <strong>MNIST</strong>.</p><ul><li>It&rsquo;s a set of 70,000 small images of digits (0-9) handwritten by high school students and US Census Bureau employees.</li><li>Each image is labeled with the digit it represents.</li><li>The book calls it the <strong>&ldquo;hello world&rdquo; of Machine Learning</strong> because it&rsquo;s a go-to dataset for testing new classification algorithms. Everyone who learns ML eventually plays with MNIST. It’s like a rite of passage!</li></ul><p>Scikit-Learn makes it super easy to fetch popular datasets like MNIST. The code shows:
<code>from sklearn.datasets import fetch_openml</code>
<code>mnist = fetch_openml('mnist_784', version=1)</code></p><p>This <code>mnist</code> object is a dictionary-like structure (a Scikit-Learn &ldquo;Bunch&rdquo; object, actually). The <code>mnist.keys()</code> output shows it contains:</p><ul><li><code>'data'</code>: The features (the pixel values of the images).</li><li><code>'target'</code>: The labels (the digit each image represents).</li><li><code>'feature_names'</code>: Names of the features.</li><li><code>'DESCR'</code>: A description of the dataset.</li><li>And a few others. This structure is common for datasets loaded with Scikit-Learn.</li></ul><p><strong>(Page 86: Exploring the MNIST Data)</strong></p><p>Let&rsquo;s look at the actual data arrays:
<code>X, y = mnist["data"], mnist["target"]</code>
<code>X.shape</code> gives <code>(70000, 784)</code>
<code>y.shape</code> gives <code>(70000,)</code></p><ul><li><strong>What does this mean?</strong><ul><li>We have 70,000 images (<code>X</code> has 70,000 rows).</li><li>Each image has 784 features (<code>X</code> has 784 columns). Why 784? Because each image is 28x28 pixels, and 28 * 28 = 784. Each feature represents the intensity of one pixel, typically from 0 (white) to 255 (black).</li><li><code>y</code> contains the 70,000 labels, one for each image.</li></ul></li></ul><p>Let&rsquo;s visualize one digit:</p><ol><li>Grab an instance&rsquo;s feature vector: <code>some_digit = X[0]</code> (this is a flat array of 784 pixel values).</li><li>Reshape it to a 28x28 array: <code>some_digit_image = some_digit.reshape(28, 28)</code>.</li><li>Display it using Matplotlib&rsquo;s <code>imshow()</code>:
<code>plt.imshow(some_digit_image, cmap="binary")</code> (cmap=&ldquo;binary&rdquo; gives a black and white image).
<code>plt.axis("off")</code> (to remove the axis ticks).
The image on page 86 clearly looks like a &lsquo;5&rsquo;.</li></ol><p>Let&rsquo;s check its label:
<code>y[0]</code> gives <code>'5'</code>.
Notice the label is a <em>string</em>. Most ML algorithms expect numbers, so we convert <code>y</code> to integers:
<code>y = y.astype(np.uint8)</code> (<code>np.uint8</code> is an unsigned 8-bit integer, good for values 0-255, perfect for digits 0-9).</p><p><strong>(Page 87: MNIST Dataset Structure & Test Set)</strong></p><p>Figure 3-1 shows a sample of the digits – you can see the variety and sometimes the messiness of handwriting!</p><p><strong>Crucially</strong>, just like in Chapter 2, we need a test set!
The MNIST dataset as loaded by <code>fetch_openml</code> is often already split:</p><ul><li>First 60,000 images for training.</li><li>Last 10,000 images for testing.
So, we can do:
<code>X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]</code></li></ul><p>The training set (<code>X_train</code>, <code>y_train</code>) is also typically pre-shuffled. This is good because:</p><ol><li>It ensures cross-validation folds will be similar (e.g., you don&rsquo;t want one fold missing all images of the digit &lsquo;7&rsquo;).</li><li>Some algorithms are sensitive to the order of training instances and perform poorly if they see many similar instances in a row. Shuffling prevents this. (The book notes shuffling isn&rsquo;t always good, e.g., for time series data where order matters).</li></ol><p><strong>(Page 88: Training a Binary Classifier)</strong></p><p>Let&rsquo;s start simple. Instead of classifying all 10 digits, let&rsquo;s try to identify just one digit – say, the number 5. This will be a <strong>binary classifier</strong>: it distinguishes between two classes, &ldquo;5&rdquo; and &ldquo;not-5&rdquo;.</p><ol><li><p><strong>Create target vectors for this binary task:</strong>
<code>y_train_5 = (y_train == 5)</code> <em># This will be True for all 5s, False for others.</em>
<code>y_test_5 = (y_test == 5)</code></p></li><li><p><strong>Pick a classifier and train it:</strong>
A good starting point is Scikit-Learn&rsquo;s <strong><code>SGDClassifier</code></strong> (Stochastic Gradient Descent classifier).</p><ul><li><strong>Why SGD?</strong> It&rsquo;s efficient and can handle very large datasets because it processes training instances one at a time (making it suitable for online learning, too).
<code>from sklearn.linear_model import SGDClassifier</code>
<code>sgd_clf = SGDClassifier(random_state=42)</code></li><li><em>Why <code>random_state=42</code>?</em> SGD relies on randomness during training (hence &ldquo;stochastic&rdquo;). Setting <code>random_state</code> ensures reproducible results. If you run the code again, you get the same model.
<code>sgd_clf.fit(X_train, y_train_5)</code></li></ul></li><li><p><strong>Make a prediction:</strong>
Let&rsquo;s use that <code>some_digit</code> (which was a &lsquo;5&rsquo;) we looked at earlier:
<code>sgd_clf.predict([some_digit])</code> returns <code>array([True])</code>.
The classifier correctly guessed it&rsquo;s a 5!</p></li></ol><p>But one correct guess doesn&rsquo;t mean much. We need to evaluate its overall performance.</p><p><strong>(Page 88-93: Performance Measures for Classifiers)</strong></p><p>Evaluating classifiers is often &ldquo;significantly trickier than evaluating a regressor.&rdquo; Get ready for new concepts!</p><ul><li><p><strong>Measuring Accuracy Using Cross-Validation (Page 89):</strong>
Just like in Chapter 2, cross-validation is a good way to evaluate.</p><ul><li><p><strong>Implementing Cross-Validation Manually:</strong> The book shows how you <em>could</em> implement cross-validation yourself using <code>StratifiedKFold</code>. This gives more control but is more work.</p><ul><li><code>StratifiedKFold</code> ensures each fold has a representative ratio of each class (important for skewed datasets, where one class is much more frequent).</li><li>The loop creates a clone of the classifier, trains on training folds, predicts on the test fold, and calculates accuracy for that fold.</li></ul></li><li><p><strong>Using <code>cross_val_score()</code>:</strong> Much easier!
<code>from sklearn.model_selection import cross_val_score</code>
<code>cross_val_score(sgd_clf, X_train, y_train_5, cv=3, scoring="accuracy")</code>
This performs K-fold cross-validation (here, 3 folds) and returns the accuracy for each fold.
The output is something like <code>array([0.96355, 0.93795, 0.95615])</code>.
Wow! Over 93% accuracy on all folds! Seems amazing, right?</p></li><li><p><strong>The Pitfall of Accuracy with Skewed Datasets:</strong> Before getting too excited, let&rsquo;s consider a &ldquo;dumb&rdquo; classifier:
<code>class Never5Classifier(BaseEstimator):</code>
<code>def fit(self, X, y=None): return self</code>
<code>def predict(self, X): return np.zeros((len(X), 1), dtype=bool) # Always predicts False (not-5)</code>
If we run <code>cross_val_score</code> on this <code>Never5Classifier</code> (page 90), we get over 90% accuracy!</p><ul><li><strong>Why?</strong> Only about 10% of the MNIST digits are 5s. So, if you always guess &ldquo;not a 5,&rdquo; you&rsquo;ll be right about 90% of the time.</li><li><strong>Key takeaway:</strong> Accuracy is generally <em>not</em> the preferred performance measure for classifiers, especially with <strong>skewed datasets</strong> (where some classes are much more frequent than others).</li></ul></li></ul></li><li><p><strong>Confusion Matrix (Page 90-91):</strong>
A much better way to evaluate! It counts how many times instances of class A are classified as class B.</p><ol><li><strong>Get &ldquo;clean&rdquo; predictions:</strong> Use <code>cross_val_predict()</code>:
<code>from sklearn.model_selection import cross_val_predict</code>
<code>y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)</code><ul><li>This performs K-fold CV but returns the predictions made on each test fold (so each prediction is &ldquo;clean&rdquo; – made by a model that hadn&rsquo;t seen that instance during its training).</li></ul></li><li><strong>Compute the confusion matrix:</strong>
<code>from sklearn.metrics import confusion_matrix</code>
<code>confusion_matrix(y_train_5, y_train_pred)</code>
The output (page 91) is a 2x2 matrix for our binary &ldquo;5&rdquo; vs &ldquo;not-5&rdquo; classifier:<pre tabindex=0><code>      Predicted: Not-5  Predicted: 5
Actual: Not-5  [[ TN,           FP ]]
Actual: 5      [[ FN,           TP ]]
</code></pre><ul><li><code>TN</code> (True Negatives): Correctly classified as not-5 (e.g., 53,057).</li><li><code>FP</code> (False Positives): Wrongly classified as 5 (they were not-5) (e.g., 1,522). Also called a <strong>Type I error</strong>.</li><li><code>FN</code> (False Negatives): Wrongly classified as not-5 (they <em>were</em> 5s) (e.g., 1,325). Also called a <strong>Type II error</strong>.</li><li><code>TP</code> (True Positives): Correctly classified as 5 (e.g., 4,096).
A perfect classifier would have only TPs and TNs (non-zero values only on the main diagonal).
Figure 3-2 (page 92) provides a nice illustration of this.</li></ul></li></ol></li><li><p><strong>Precision and Recall (Page 91-92):</strong>
The confusion matrix is great, but sometimes we want more concise metrics.</p><ul><li><strong>Precision (Equation 3-1):</strong> Accuracy of the positive predictions.
<code>precision = TP / (TP + FP)</code><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> Of all the instances the classifier <em>claimed</em> were positive (e.g., said were &lsquo;5&rsquo;s), what proportion were <em>actually</em> positive?</li><li>A trivial way to get 100% precision: make only one positive prediction and ensure it&rsquo;s correct. Not very useful!</li></ul></li><li><strong>Recall (Equation 3-2):</strong> Sensitivity or True Positive Rate (TPR). Ratio of positive instances that are correctly detected.
<code>recall = TP / (TP + FN)</code><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> Of all the instances that <em>were actually</em> positive (e.g., all actual &lsquo;5&rsquo;s), what proportion did the classifier <em>correctly identify</em>?</li></ul></li></ul><p>Scikit-Learn provides functions:
<code>from sklearn.metrics import precision_score, recall_score</code>
<code>precision_score(y_train_5, y_train_pred)</code> gives ~72.9%.
<code>recall_score(y_train_5, y_train_pred)</code> gives ~75.6%.
So, when our <code>sgd_clf</code> claims an image is a &lsquo;5&rsquo;, it&rsquo;s correct only 72.9% of the time. And it only detects 75.6% of all actual &lsquo;5&rsquo;s. Not as shiny as the 90%+ accuracy suggested!</p></li><li><p><strong>F₁ Score (Page 92):</strong>
It&rsquo;s often convenient to combine precision and recall into a single metric, especially for comparing classifiers. The <strong>F₁ score</strong> is the <em>harmonic mean</em> of precision and recall (Equation 3-3).
<code>F₁ = 2 * (precision * recall) / (precision + recall)</code></p><ul><li><em>What it&rsquo;s ultimately trying to achieve:</em> The F₁ score gives more weight to low values. So, a classifier only gets a high F₁ score if <em>both</em> precision and recall are high.</li><li><code>from sklearn.metrics import f1_score</code></li><li><code>f1_score(y_train_5, y_train_pred)</code> gives ~74.2%.</li></ul><p>The F₁ score isn&rsquo;t always what you want. Sometimes you care more about precision (e.g., kid-safe video filter – high precision, even if recall is low). Sometimes you care more about recall (e.g., shoplifter detection – high recall, even if precision is low and there are false alarms).</p></li><li><p><strong>Precision/Recall Trade-off (Page 93-96):</strong>
Unfortunately, you usually can&rsquo;t have it both ways: increasing precision tends to reduce recall, and vice-versa. This is the <strong>precision/recall trade-off</strong>.</p><ul><li><p><strong>How it works:</strong> Classifiers like <code>SGDClassifier</code> compute a <em>decision score</em> for each instance. If the score > threshold, it&rsquo;s positive; else, negative. (Figure 3-3 illustrates this).</p><ul><li>Raising the threshold: Fewer instances classified as positive. This usually increases precision (fewer false positives among the ones called positive) but decreases recall (more true positives get missed and become false negatives).</li><li>Lowering the threshold: More instances classified as positive. This usually increases recall (fewer true positives missed) but decreases precision (more false positives creep in).</li></ul></li><li><p>Scikit-Learn lets you access these decision scores:
<code>y_scores = sgd_clf.decision_function([some_digit])</code>
<code>SGDClassifier</code> uses a threshold of 0 by default.
If we set <code>threshold = 8000</code>, <code>(y_scores > threshold)</code> might become <code>False</code>, meaning a &lsquo;5&rsquo; is now missed (recall drops).</p></li><li><p><strong>Choosing a threshold:</strong></p><ol><li>Get decision scores for all training instances:
<code>y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3, method="decision_function")</code></li><li>Compute precision and recall for all possible thresholds:
<code>from sklearn.metrics import precision_recall_curve</code>
<code>precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)</code></li><li>Plot precision and recall vs. threshold (Figure 3-4, page 95).</li><li>Plot precision vs. recall (Figure 3-5, page 96).<figure><img src=/bookshelf/hands-on-ml/ch-3-pre-recall.png alt=image width=350></figure></li></ol></li><li><p>From these plots, you can choose a threshold that gives a good balance for your project. E.g., if you want 90% precision, find the threshold for that (around 8000 in the example, page 96). At this threshold, recall might be lower (e.g., 43.7%).<figure><img src=/bookshelf/hands-on-ml/ch-3-fig-3-5.png alt=image width=350></figure></p></li><li><p>As the book wisely notes: &ldquo;If someone says, &lsquo;Let&rsquo;s reach 99% precision,&rsquo; you should ask, &lsquo;At what recall?&rsquo;&rdquo;</p></li></ul></li><li><p><strong>The ROC Curve (Page 97-99):</strong>
Another common tool for binary classifiers: <strong>Receiver Operating Characteristic (ROC) curve</strong>.</p><ul><li>Plots <strong>True Positive Rate (TPR, which is just recall)</strong> against <strong>False Positive Rate (FPR)</strong>.<ul><li><code>FPR = FP / (FP + TN)</code>: Ratio of negative instances incorrectly classified as positive.</li><li>FPR is also <code>1 - True Negative Rate (TNR)</code>. TNR is called <strong>specificity</strong>.</li><li>So, ROC plots <code>sensitivity</code> (recall) vs. <code>1 - specificity</code>.</li></ul></li><li><strong>Plotting it:</strong><ol><li>Compute TPR and FPR for various thresholds:
<code>from sklearn.metrics import roc_curve</code>
<code>fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)</code> (using the same <code>y_scores</code> from <code>decision_function</code>).</li><li>Plot FPR vs. TPR using Matplotlib (Figure 3-6, page 98).</li></ol></li><li><strong>Interpretation:</strong><ul><li>Dotted diagonal line: Purely random classifier.</li><li>Good classifier: Stays as far away from the diagonal as possible (toward the top-left corner – high TPR, low FPR).</li><li>Trade-off: Higher TPR (recall) usually means more FPRs.</li></ul></li><li><strong>Area Under the Curve (AUC) or ROC AUC:</strong> A single number to compare classifiers.<ul><li>Perfect classifier: ROC AUC = 1.</li><li>Random classifier: ROC AUC = 0.5.</li><li><code>from sklearn.metrics import roc_auc_score</code></li><li><code>roc_auc_score(y_train_5, y_scores)</code> gives ~0.96 for <code>SGDClassifier</code>.</li></ul></li><li><strong>ROC vs. Precision-Recall (PR) Curve (Page 98 sidebar):</strong><ul><li>When to use which? Prefer PR curve when positive class is rare OR you care more about false positives than false negatives. Otherwise, ROC is fine.</li><li>MNIST &lsquo;5&rsquo;s are ~10% of data (positive class is somewhat rare). The ROC curve might look good because there are many true negatives. The PR curve might reveal more room for improvement.</li></ul></li><li><strong>Comparing with RandomForestClassifier (Page 98-99):</strong><ul><li><code>RandomForestClassifier</code> doesn&rsquo;t have <code>decision_function()</code>. It has <code>predict_proba()</code>.</li><li><code>predict_proba()</code> returns an array: one row per instance, one column per class, with the probability of that instance belonging to that class.</li><li>Get probabilities for the positive class: <code>y_probas_forest = cross_val_predict(forest_clf, ..., method="predict_proba")</code></li><li><code>y_scores_forest = y_probas_forest[:, 1]</code> (probabilities for the positive class, i.e., &lsquo;5&rsquo;).</li><li>Plot ROC for RandomForest (Figure 3-7, page 99). It&rsquo;s much closer to top-left.</li><li><code>roc_auc_score(y_train_5, y_scores_forest)</code> is ~0.998. Much better!</li><li>RandomForest also has much better precision (~99.0%) and recall (~86.6%).</li></ul></li></ul></li></ul><p><strong>(Page 100-102: Multiclass Classification)</strong></p><p>So far, binary (5 vs. not-5). Now, distinguishing all 10 digits (0-9). This is <strong>multiclass classification</strong> (or multinomial).</p><ul><li><p>Some algorithms (SGD, RandomForest, Naive Bayes) can handle multiple classes natively.</p></li><li><p>Others (Logistic Regression, SVMs) are strictly binary.</p></li><li><p><strong>Strategies for using binary classifiers for multiclass:</strong></p><ol><li><strong>One-versus-the-Rest (OvR) or One-versus-All (OvA):</strong><ul><li>Train N binary classifiers (one for each class). E.g., a 0-detector, a 1-detector, &mldr;, a 9-detector.</li><li>To classify a new image: get decision score from each of the 10 classifiers. Select the class whose classifier outputs the highest score.</li></ul></li><li><strong>One-versus-One (OvO):</strong><ul><li>Train a binary classifier for <em>every pair</em> of digits. 0-vs-1, 0-vs-2, &mldr;, 1-vs-2, &mldr;, 8-vs-9.</li><li>For N classes, this is N * (N-1) / 2 classifiers. For MNIST (N=10), it&rsquo;s 45 classifiers!</li><li>To classify: run image through all 45 classifiers. See which class &ldquo;wins&rdquo; the most duels.</li><li>Main advantage: Each classifier is trained only on the subset of data for the two classes it distinguishes. Good for algorithms that scale poorly with training set size (like SVMs). For most others, OvR is preferred.</li></ul></li></ol></li><li><p><strong>Scikit-Learn&rsquo;s behavior (page 101):</strong></p><ul><li>It detects if you use a binary classifier for a multiclass task and automatically runs OvR or OvO.</li><li>Example with <code>SVC</code> (Support Vector Classifier):
<code>from sklearn.svm import SVC</code>
<code>svm_clf = SVC()</code>
<code>svm_clf.fit(X_train, y_train)</code> <em>(Note: <code>y_train</code>, not <code>y_train_5</code>)</em>
<code>svm_clf.predict([some_digit])</code> correctly predicts <code>[5]</code>.<ul><li>Under the hood, SVC used OvO. It trained 45 binary classifiers.</li><li><code>svm_clf.decision_function([some_digit])</code> returns 10 scores (one per class). The highest score corresponds to class &lsquo;5&rsquo;.</li><li><code>svm_clf.classes_</code> shows the list of target classes.</li></ul></li><li>You can force OvO or OvR:
<code>from sklearn.multiclass import OneVsOneClassifier, OneVsRestClassifier</code>
<code>ovr_clf = OneVsRestClassifier(SVC())</code></li></ul></li><li><p><strong>SGDClassifier for multiclass (page 102):</strong></p><ul><li>SGD can do multiclass natively. Scikit-Learn doesn&rsquo;t need OvR/OvO.</li><li><code>sgd_clf.fit(X_train, y_train)</code></li><li><code>sgd_clf.decision_function([some_digit])</code> returns 10 scores. Class &lsquo;5&rsquo; has the highest score (2412.5), class &lsquo;3&rsquo; has a small positive score (573.5), others negative.</li><li>Evaluate with <code>cross_val_score(sgd_clf, X_train, y_train, cv=3, scoring="accuracy")</code> -> gets ~84-87%.</li><li>Scaling inputs (as in Ch 2) with <code>StandardScaler</code> improves accuracy to >89%!
<code>scaler = StandardScaler()</code>
<code>X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))</code>
<code>cross_val_score(sgd_clf, X_train_scaled, ...)</code></li></ul></li></ul><p><strong>(Page 103-105: Error Analysis)</strong></p><p>Assume you have a promising model. Now, analyze its errors to improve it.</p><ol><li><strong>Multiclass Confusion Matrix:</strong><ul><li>Get predictions: <code>y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv=3)</code></li><li><code>conf_mx = confusion_matrix(y_train, y_train_pred)</code></li><li>It&rsquo;s a 10x10 matrix. Plot it with <code>plt.matshow(conf_mx, cmap=plt.cm.gray)</code> (image on page 103).<ul><li>Most images on main diagonal (correctly classified).</li><li>The &lsquo;5&rsquo;s look slightly darker. Either fewer 5s, or classifier performs worse on 5s. (Book says both are true).</li></ul></li></ul></li><li><strong>Focus on errors:</strong><ul><li>Divide each value in confusion matrix by number of images in the <em>actual</em> class (row sums) to get error <em>rates</em>.
<code>row_sums = conf_mx.sum(axis=1, keepdims=True)</code>
<code>norm_conf_mx = conf_mx / row_sums</code></li><li>Fill diagonal with zeros to keep only errors. Plot <code>norm_conf_mx</code> (image on page 104).<ul><li>Rows = actual classes, Columns = predicted classes.</li><li>Column for class &lsquo;8&rsquo; is bright: many images get misclassified <em>as</em> 8s.</li><li>Row for class &lsquo;8&rsquo; is not too bad: actual 8s are generally classified correctly.</li><li>3s and 5s often get confused (in both directions).</li></ul></li></ul></li><li><strong>What to do?</strong><ul><li>Improve classification of digits that look like 8s (but aren&rsquo;t). Gather more such training data.</li><li>Engineer new features (e.g., count closed loops: 8 has two, 6 has one, 5 has none).</li><li>Preprocess images to make patterns stand out (Scikit-Image, Pillow, OpenCV).</li></ul></li><li><strong>Analyzing individual errors (page 104-105):</strong><ul><li>Plot examples of 3s classified as 5s, 5s classified as 3s, etc. (Figure on page 105).</li><li>Some errors are understandable (even humans would struggle).</li><li>Many seem like obvious errors. Why does <code>SGDClassifier</code> (a linear model) make them? It assigns a weight per pixel per class and sums weighted intensities. 3s and 5s differ by only a few pixels.</li><li>Sensitivity to shifting/rotation. Preprocessing (centering, de-skewing) could help.</li></ul></li></ol><p><strong>(Page 106-107: Multilabel Classification)</strong></p><p>Sometimes, an instance can belong to <em>multiple binary classes</em>.</p><ul><li>Example: Face recognition – if Alice and Charlie are in a picture, output should be [Alice:yes, Bob:no, Charlie:yes] or <code>[1, 0, 1]</code>.</li><li>Simpler example with MNIST:<ul><li>Label 1: Is the digit large (7, 8, or 9)? <code>y_train_large = (y_train >= 7)</code></li><li>Label 2: Is the digit odd? <code>y_train_odd = (y_train % 2 == 1)</code></li><li>Combine into <code>y_multilabel = np.c_[y_train_large, y_train_odd]</code> (each instance has two labels).</li></ul></li><li>Train a classifier (e.g., <code>KNeighborsClassifier</code>, which supports multilabel):
<code>knn_clf = KNeighborsClassifier()</code>
<code>knn_clf.fit(X_train, y_multilabel)</code></li><li>Prediction for <code>some_digit</code> (a &lsquo;5&rsquo;): <code>knn_clf.predict([some_digit])</code> gives <code>array([[False, True]])</code>. Correct! (5 is not large, 5 is odd).</li><li><strong>Evaluation:</strong> Measure F₁ score for each label, then average.
<code>f1_score(y_multilabel, y_train_knn_pred, average="macro")</code> (&ldquo;macro&rdquo; gives equal weight to each label).
Can set <code>average="weighted"</code> to weight by support (number of instances per label).</li></ul><p><strong>(Page 107-108: Multioutput Classification)</strong></p><p>Generalization of multilabel: each label can be multiclass (not just binary).</p><ul><li>Example: Image denoising.<ul><li>Input: Noisy digit image (each pixel is an input feature).</li><li>Output: Clean digit image (each pixel is a label, and each label can have values 0-255).</li><li>This is multilabel (one label per pixel) and each label is multiclass (0-255 intensity).</li></ul></li><li>Create noisy data: <code>X_train_mod = X_train + noise</code>. Target is clean image: <code>y_train_mod = X_train</code>.</li><li>Train <code>KNeighborsClassifier</code>: <code>knn_clf.fit(X_train_mod, y_train_mod)</code>.</li><li>Predict on a noisy test image: <code>clean_digit = knn_clf.predict([X_test_mod[some_index]])</code>.</li><li>The result (image on page 108) looks close to the target!</li></ul><p>The line between classification and regression can be blurry here (predicting pixel intensity). Multioutput systems can even mix class labels and value labels.</p><p><strong>(Page 108-109: Exercises)</strong>
The chapter concludes with some excellent exercises:</p><ol><li>Build a >97% accuracy classifier for MNIST (hint: <code>KNeighborsClassifier</code> with grid search).</li><li>Data augmentation: shift images, add to training set, retrain.</li><li>Tackle Titanic dataset (Kaggle).</li><li>Build a spam classifier (challenging!).</li></ol><hr><h1 id=glossary>Glossary</h1><h2 id=q--why-does-roc-curve-exist-only-for-binary-classifiier>Q . why does ROC curve exist only for binary classifiier?</h2><p>That&rsquo;s a sharp question! You&rsquo;re right to notice that the ROC curve, as we&rsquo;ve discussed it so far (plotting True Positive Rate vs. False Positive Rate), is <strong>fundamentally designed for and most intuitively understood in the context of binary classification.</strong></p><p>Let&rsquo;s break down why:</p><ol><li><p><strong>Clear Definition of &ldquo;Positive&rdquo; and &ldquo;Negative&rdquo; Classes:</strong></p><ul><li>In binary classification, you have a clear distinction: one class is designated as &ldquo;positive&rdquo; (e.g., &ldquo;is a 5,&rdquo; &ldquo;is spam,&rdquo; &ldquo;has disease&rdquo;) and the other as &ldquo;negative&rdquo; (e.g., &ldquo;is not a 5,&rdquo; &ldquo;is not spam,&rdquo; &ldquo;does not have disease&rdquo;).</li><li>This allows for unambiguous definitions of:<ul><li><strong>True Positives (TP):</strong> Correctly identifying a positive instance.</li><li><strong>False Positives (FP):</strong> Incorrectly identifying a negative instance as positive.</li><li><strong>True Negatives (TN):</strong> Correctly identifying a negative instance.</li><li><strong>False Negatives (FN):</strong> Incorrectly identifying a positive instance as negative.</li></ul></li><li>TPR (Recall) = TP / (TP + FN)</li><li>FPR = FP / (FP + TN)
These metrics are the axes of the ROC curve.</li></ul></li><li><p><strong>Single Decision Threshold:</strong></p><ul><li>Binary classifiers often output a score or probability that an instance belongs to the <em>positive</em> class. A single threshold is then used on this score to make the binary decision.</li><li>The ROC curve visualizes performance across <em>all possible values of this single threshold</em>.</li></ul></li></ol><p><strong>Why it&rsquo;s tricky for multiclass classification (more than 2 classes):</strong></p><p>When you have, say, 3 classes (A, B, C), the concepts of TP, FP, TN, FN become less straightforward if you try to apply them in the same way.</p><ul><li><strong>What is &ldquo;positive&rdquo;?</strong> If you&rsquo;re trying to detect class A, then A is &ldquo;positive,&rdquo; and B and C combined are &ldquo;negative.&rdquo; You could make an ROC curve for this &ldquo;A vs. Not-A&rdquo; scenario.</li><li><strong>What about class B?</strong> You&rsquo;d then need a separate &ldquo;B vs. Not-B&rdquo; (where Not-B is A and C) scenario and its own ROC curve.</li><li>And another for &ldquo;C vs. Not-C.&rdquo;</li></ul><p>So, for a multiclass problem with <code>N</code> classes, you can&rsquo;t draw a single, simple ROC curve in the same 2D TPR vs. FPR space that directly represents the performance across all classes simultaneously.</p><p><strong>How ROC is often adapted or used in multiclass settings:</strong></p><p>Even though a single ROC curve isn&rsquo;t a direct fit, the underlying principles can be extended, typically using a <strong>One-vs-Rest (OvR) or One-vs-One (OvO) approach:</strong></p><ol><li><p><strong>One-vs-Rest (OvR) ROC Curves:</strong></p><ul><li>You can create <code>N</code> separate binary classification problems. For each class <code>i</code>, you treat class <code>i</code> as the positive class and all other classes (<code>N-1</code> of them) as the negative class.</li><li>You can then compute an ROC curve and its AUC for each of these <code>N</code> binary problems.</li><li>This gives you <code>N</code> ROC curves and <code>N</code> AUC scores.</li><li>You can then, for example, average these AUC scores (e.g., macro-average or weighted-average) to get an overall performance metric for the multiclass classifier. Some libraries might even plot all N curves on the same graph or an &ldquo;averaged&rdquo; ROC curve, but this average curve can be harder to interpret directly than a binary ROC.</li></ul></li><li><p><strong>One-vs-One (OvO) ROC Curves:</strong></p><ul><li>You could, in theory, create an ROC curve for each pair of classes (N*(N-1)/2 curves). This becomes unwieldy very quickly and isn&rsquo;t commonly done for overall visualization.</li></ul></li></ol><p><strong>The Key Idea:</strong></p><p>The ROC curve&rsquo;s power lies in visualizing the trade-off for a <em>single decision boundary</em> between two distinct outcomes as you vary the threshold. In multiclass, you inherently have multiple potential decision boundaries between multiple classes, or you&rsquo;re reducing it to multiple binary problems.</p><p><strong>Think of it intuitively:</strong></p><ul><li><strong>Binary:</strong> &ldquo;How good am I at separating the &lsquo;good guys&rsquo; from the &lsquo;bad guys&rsquo; as I change my definition of &lsquo;suspicious activity&rsquo; (the threshold)?&rdquo;</li><li><strong>Multiclass:</strong> If you have apples, oranges, and bananas, how would you define a single TPR and FPR that captures the misclassification rates between all pairs (apples called oranges, oranges called bananas, apples called bananas, etc.) on a single 2D plot in the same way? It&rsquo;s not directly possible with the original TPR/FPR definitions.</li></ul><p><strong>In summary:</strong></p><p>The standard ROC curve (TPR vs. FPR) is a tool specifically tailored for visualizing the performance of a <strong>binary classifier</strong> by showing its ability to distinguish between a positive and a negative class across various decision thresholds. While the concept can be extended to multiclass scenarios by breaking the problem down into multiple binary subproblems (like OvR), you won&rsquo;t typically see a single, direct &ldquo;multiclass ROC curve&rdquo; in the same simple 2D form. Instead, you&rsquo;d look at metrics derived from these multiple binary evaluations or other multiclass-specific evaluation tools (like a full confusion matrix for all classes).</p></div></div></article></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer></body></html>