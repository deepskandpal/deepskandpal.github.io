<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#what-this-chapter-is-ultimately-trying-to-achieve>What this chapter is ultimately trying to achieve</a></li><li><a href=#core-idea-parallel-processing-with-attention>Core Idea: Parallel Processing with Attention</a></li><li><a href=#41-decoder-block-the-building-block>4.1 Decoder Block (The Building Block)</a></li><li><a href=#42-self-attention-the-heart-of-the-transformer>4.2 Self-Attention (The Heart of the Transformer)</a></li><li><a href=#43-position-wise-multilayer-perceptron-mlp>4.3 Position-Wise Multilayer Perceptron (MLP)</a></li><li><a href=#44-rotary-position-embedding-rope>4.4 Rotary Position Embedding (RoPE)</a></li><li><a href=#45-residual-connections--layer-normalization-revisited>4.5 Residual Connections & Layer Normalization (Revisited)</a></li><li><a href=#46-key-value-caching-for-inference>4.6 Key-Value Caching (For Inference)</a></li><li><a href=#49-transformer-in-python-implementation>4.9 Transformer in Python (Implementation)</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 4: Transformer</h1><span class=reading-time><em>9 min read</em></span><div class=book-details><div class=book-content><h2 id=what-this-chapter-is-ultimately-trying-to-achieve>What this chapter is ultimately trying to achieve</h2><p>To introduce and explain the core mechanisms of the Transformer architecture, specifically focusing on the <strong>decoder-only</strong> variant, which is prevalent in autoregressive language models like GPT. The key is to understand how it processes input sequences, attends to relevant information, and incorporates positional context, all without the sequential recurrence of RNNs.</p><p>Let&rsquo;s break down the key concepts:</p><h2 id=core-idea-parallel-processing-with-attention>Core Idea: Parallel Processing with Attention</h2><p>Unlike RNNs that process tokens one by one, Transformers can process all tokens in an input sequence <em>simultaneously</em> (or at least in parallel up to the context window length). The &ldquo;magic&rdquo; that allows them to understand relationships between tokens in this parallel setup is the <strong>self-attention mechanism</strong>.</p><h2 id=41-decoder-block-the-building-block>4.1 Decoder Block (The Building Block)</h2><ul><li><strong>What it&rsquo;s ultimately trying to achieve:</strong>
A Transformer model is typically a stack of identical &ldquo;decoder blocks&rdquo; (or encoder blocks, or both, depending on the variant). Each block takes a sequence of token representations as input and outputs a refined sequence of representations of the same length.</li><li><strong>Decoder-Only Focus:</strong> For autoregressive language modeling (predicting the next token), we typically use a stack of decoder blocks. The input is the sequence of tokens seen so far, and the output of the final block is used to predict the next token.</li><li><strong>Structure of a Decoder Block:</strong> Each block has two main sub-layers:<ol><li><strong>Masked Multi-Head Self-Attention:</strong> Allows each token to &ldquo;look at&rdquo; other tokens in the sequence (including itself) to gather contextual information. The &ldquo;masked&rdquo; part is crucial for autoregressive models to prevent a token from seeing future tokens during training.</li><li><strong>Position-Wise Feedforward Network (MLP):</strong> A standard fully connected feedforward network applied independently to each token&rsquo;s representation after the attention step.</li></ol></li><li><strong>Additional Components within a block (crucial for making it work):</strong><ul><li><strong>Residual Connections (Skip Connections):</strong> The input to each sub-layer is added to its output. This helps with gradient flow and enables training much deeper networks.</li><li><strong>Layer Normalization (RMSNorm in the book):</strong> Applied before each sub-layer to stabilize the activations and improve training.</li></ul></li></ul><h2 id=42-self-attention-the-heart-of-the-transformer>4.2 Self-Attention (The Heart of the Transformer)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
For each token in the input sequence, self-attention calculates a new representation by taking a weighted sum of the representations of <em>all</em> tokens in the sequence (respecting the causal mask for decoders). The weights determine how much &ldquo;attention&rdquo; each token should pay to every other token (including itself) when computing its updated representation.</p></li><li><p><strong>The QKV (Query, Key, Value) Analogy:</strong>
Imagine you&rsquo;re looking up information in a library (this is a common analogy):</p><ul><li><strong>Query (Q):</strong> For the current token you&rsquo;re trying to update, you formulate a &ldquo;query&rdquo; representing what kind of information it&rsquo;s looking for.</li><li><strong>Key (K):</strong> Every token in the sequence (including the current one) has a &ldquo;key&rdquo; that acts like an index tag, describing what kind of information it holds.</li><li><strong>Value (V):</strong> Every token also has a &ldquo;value,&rdquo; which is the actual content or representation of that token.
The process:</li></ul><ol><li><strong>Project Inputs:</strong> The input embedding for each token <code>x_t</code> is projected into three different vectors: <code>q_t</code> (query), <code>k_t</code> (key), and <code>v_t</code> (value) using learnable weight matrices (WQ, WK, WV).</li><li><strong>Calculate Attention Scores:</strong> For a given query <code>q_t</code>, its &ldquo;compatibility&rdquo; or &ldquo;similarity&rdquo; with every key <code>k_j</code> in the sequence is calculated, usually via a dot product: <code>score(q_t, k_j) = q_t ⋅ k_j</code>.</li><li><strong>Scale Scores:</strong> The scores are scaled down (typically by the square root of the key vector&rsquo;s dimension, <code>sqrt(d_k)</code>) to prevent very large values, which can lead to vanishing gradients in the softmax.</li><li><strong>Apply Causal Mask (for Decoders):</strong> To ensure autoregression (a token can&rsquo;t see future tokens), scores corresponding to attention to future positions are set to negative infinity before the softmax. This makes their softmax probability zero.</li><li><strong>Convert Scores to Weights (Softmax):</strong> The masked, scaled scores are passed through a softmax function. This converts the scores into positive attention weights that sum to 1 across all tokens in the sequence. These weights indicate how much <code>q_t</code> should attend to each <code>v_j</code>.</li><li><strong>Compute Output:</strong> The output representation for token <code>t</code> (<code>g_t</code> in the book) is a weighted sum of all value vectors <code>v_j</code>, where the weights are the attention weights computed in the previous step: <code>g_t = sum_j (attention_weight_tj * v_j)</code>.</li></ol></li><li><p><strong>Multi-Head Attention:</strong></p><ul><li><em>Intuition:</em> Instead of having one set of Q, K, V matrices, self-attention is often performed multiple times in parallel, each with <em>different</em> learned Q, K, V projection matrices. These are called &ldquo;heads.&rdquo;</li><li><em>Benefit:</em> Each head can learn to focus on different types of relationships or different aspects of the input sequence (e.g., one head might focus on syntactic relationships, another on semantic ones over a longer distance).</li><li><em>Process:</em> The input is split (or projected) into multiple smaller-dimensional Q, K, V sets. Attention is computed independently for each head. The outputs of all heads are then concatenated and linearly projected back to the original embedding dimension.</li></ul></li></ul><h2 id=43-position-wise-multilayer-perceptron-mlp>4.3 Position-Wise Multilayer Perceptron (MLP)</h2><ul><li><strong>What it&rsquo;s ultimately trying to achieve:</strong>
After the self-attention mechanism has aggregated contextual information into each token&rsquo;s representation, the MLP provides further non-linear processing.</li><li><strong>How it works:</strong>
It&rsquo;s a standard two-layer feedforward network (e.g., Linear -> ReLU -> Linear). Crucially, the <em>same</em> MLP (with the same weights) is applied <em>independently</em> to the representation of <em>each token</em> in the sequence.<ul><li>The book describes it as <code>z_t = W2(ReLU(W1 * g_t + b1)) + b2</code>.</li><li>Often, the intermediate layer in the MLP is larger than the input/output dimension (e.g., 4x the embedding dimension), allowing the model to learn more complex transformations before projecting back down.</li></ul></li></ul><h2 id=44-rotary-position-embedding-rope>4.4 Rotary Position Embedding (RoPE)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To inject information about the absolute and relative positions of tokens into the model, since the self-attention mechanism itself is permutation-invariant (shuffling input tokens doesn&rsquo;t change the raw attention scores if there&rsquo;s no positional info). RNNs get position info for free due to sequential processing. Transformers need an explicit way.</p></li><li><p><strong>The Core Idea: Relative Position from Absolute Rotation</strong>
RoPE is an elegant solution that encodes the absolute position of a token in a way that allows the attention mechanism to easily deduce the <em>relative</em> positions between tokens. Imagine you have a spinning compass needle for each word&rsquo;s query (Q) and key (K) vectors.</p><ol><li><p><strong>Absolute Position as Spin:</strong> For a word at <strong>position <code>m</code></strong>, its Q and K compass needles are spun by an amount proportional to <code>m</code>. A word at position 1 spins a little, a word at position 2 spins twice as much, and so on. The final orientation of a needle tells you the word&rsquo;s absolute position.</p></li><li><p><strong>Attention as Needle Alignment:</strong> To calculate attention between two words, the model compares the orientation of the first word&rsquo;s Q-needle to the second word&rsquo;s K-needle. The &ldquo;comparison&rdquo; measures how well the needles are aligned.</p></li><li><p><strong>The Magic - Relative Distance Emerges:</strong> Due to the mathematical properties of rotation (using sine and cosine), the alignment between two needles—one spun by <code>m</code> units and the other by <code>n</code> units—depends only on the <em>difference</em> in their spin, <code>m - n</code>. The absolute positions don&rsquo;t matter for the comparison, only the relative distance.</p></li></ol><p>This is powerful because the model learns relational patterns, like &ldquo;the word 2 positions after a verb is often an object,&rdquo; regardless of where that verb appears in the sentence.</p></li><li><p><strong>Key Advantages of RoPE:</strong></p><ol><li><strong>Relative from Absolute:</strong> It encodes absolute positions, but the self-attention score naturally becomes sensitive to relative distance, which is more intuitive for language.</li><li><strong>Multi-Scale Information:</strong> It uses different rotation speeds for different parts of the vector, allowing it to capture both local (fast-rotating) and global (slow-rotating) positional context.</li><li><strong>Excellent Extrapolation:</strong> It generalizes well to sequence lengths longer than those seen during training—a significant advantage for long documents.</li><li><strong>No Extra Parameters:</strong> RoPE modifies existing Q and K vectors with fixed rotations, avoiding extra learnable parameters for positional information.</li></ol></li></ul><h2 id=45-residual-connections--layer-normalization-revisited>4.5 Residual Connections & Layer Normalization (Revisited)</h2><ul><li><strong>Residual Connections:</strong> As in Chapter 1&rsquo;s general NN discussion and as seen in the block diagram, the input to a sub-layer (e.g., self-attention or MLP) is added to its output: <code>x_output = SubLayer(x_input) + x_input</code>. This is critical for training deep stacks of decoder blocks by preventing vanishing gradients.</li><li><strong>Layer Normalization (RMSNorm):</strong> Applied <em>before</em> each sub-layer (self-attention and MLP) and after the residual addition.<ul><li><code>RMSNorm(x) = (x / sqrt(mean(x^2) + epsilon)) * gamma</code> (where <code>gamma</code> is a learnable scaling parameter and <code>epsilon</code> is for numerical stability).</li><li>It normalizes the features for each token independently across its embedding dimension. This helps stabilize training, making it less sensitive to the scale of parameters and activations, and allows for faster convergence.</li></ul></li></ul><h2 id=46-key-value-caching-for-inference>4.6 Key-Value Caching (For Inference)</h2><ul><li><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To speed up text generation (inference) which is autoregressive (one token at a time).</li><li><strong>The Problem:</strong> During training, we can compute attention over the whole sequence in parallel. But during inference, when generating token <code>t+1</code>, we&rsquo;ve already computed the Key (K) and Value (V) matrices for tokens <code>1...t</code>. Without caching, we&rsquo;d recompute these K and V vectors for all previous tokens every time we generate a new token.</li><li><strong>The Solution:</strong>
Cache (store) the K and V vectors for all previously generated tokens in each layer. When generating the next token:<ol><li>Only compute the Q, K, V vectors for the <em>newly generated</em> token.</li><li>Append the new K and V vectors to their respective cached K and V matrices.</li><li>The new Q vector attends to all the K vectors in the updated cache.
This significantly reduces computation because the K and V projections for past tokens don&rsquo;t change.</li></ol></li></ul><h2 id=49-transformer-in-python-implementation>4.9 Transformer in Python (Implementation)</h2><ul><li><strong>Putting it all together in PyTorch:</strong><ul><li><code>AttentionHead</code> class: Implements a single attention head, including QKV projections, RoPE, scaled dot-product attention, and masking.</li><li><code>MultiHeadAttention</code> class: Contains multiple <code>AttentionHead</code> instances, concatenates their outputs, and applies a final linear projection.</li><li><code>MLP</code> class: The position-wise feedforward network.</li><li><code>RMSNorm</code> class.</li><li><code>DecoderBlock</code> class: Combines <code>MultiHeadAttention</code>, <code>MLP</code>, <code>RMSNorm</code>, and residual connections.</li><li><code>DecoderLanguageModel</code> class: Stacks multiple <code>DecoderBlock</code>s, includes an embedding layer at the input, and a final linear layer to project outputs to vocabulary logits. The <code>forward</code> method also creates the causal mask.</li></ul></li></ul><p>The training loop for this Transformer decoder is conceptually very similar to the RNN LM training loop: prepare input and (shifted) target sequences, pass through the model, compute cross-entropy loss, backpropagate, and update.</p></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>