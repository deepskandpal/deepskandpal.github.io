<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#what-this-chapter-is-ultimately-trying-to-achieve>What this chapter is ultimately trying to achieve</a></li><li><a href=#51-why-larger-is-better>5.1 Why Larger Is Better</a></li><li><a href=#52-supervised-finetuning-sft>5.2 Supervised Finetuning (SFT)</a></li><li><a href=#53-finetuning-a-pretrained-model-practical-example>5.3 Finetuning a Pretrained Model (Practical Example)</a></li><li><a href=#54-sampling-from-language-models>5.4 Sampling From Language Models</a></li><li><a href=#55-low-rank-adaptation-lora>5.5 Low-Rank Adaptation (LoRA)</a></li><li><a href=#56-llm-as-a-classifier-alternative-to-generation>5.6 LLM as a Classifier (Alternative to Generation)</a></li><li><a href=#57-prompt-engineering>5.7 Prompt Engineering</a></li><li><a href=#58-hallucinations>5.8 Hallucinations</a></li><li><a href=#59-llms-copyright-and-ethics>5.9 LLMs, Copyright, and Ethics</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 5: Large Language Model</h1><span class=reading-time><em>8 min read</em></span><div class=book-details><div class=book-content><h2 id=what-this-chapter-is-ultimately-trying-to-achieve>What this chapter is ultimately trying to achieve</h2><p>To explain <em>why</em> &ldquo;large&rdquo; matters in language models, what &ldquo;large&rdquo; actually entails, and how these scaled-up pretrained models are then adapted (finetuned) to become useful for a wide range of tasks beyond just predicting the next token. We also delve into practical aspects like interacting with them (sampling, prompt engineering) and addressing their inherent limitations (hallucinations, ethics).</p><p>Let&rsquo;s break down the key sections:</p><h2 id=51-why-larger-is-better>5.1 Why Larger Is Better</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To establish that the remarkable abilities of LLMs (like understanding complex instructions, generating coherent long-form text, some forms of reasoning, few-shot learning) are not just incremental improvements but often <strong>emergent properties</strong> that arise when model size, data size, and compute cross certain thresholds.</p></li><li><p><strong>The Core Idea (Scale is Key):</strong>
Pretraining a Transformer (like the decoder we built in Chapter 4) on a massive dataset of text (trillions of tokens) with a huge number of parameters (billions to trillions) and a large context window (thousands to hundreds of thousands of tokens) allows it to learn intricate patterns, world knowledge, and even some rudimentary reasoning skills simply from the task of predicting the next token.</p><ul><li>The example of CRISPR-Cas9 in the book illustrates this: to predict the next token accurately in a scientific text, the model <em>must</em> implicitly learn a lot about the underlying concepts.</li></ul></li><li><p><strong>The &ldquo;Large&rdquo; Factors:</strong></p><ol><li><strong>Large Parameter Count:</strong><ul><li>Our decoder model had ~8 million parameters. Modern LLMs (Llama 3.1 70B, Gemma 2 27B) have billions.</li><li>More parameters mean more capacity to store information, learn complex patterns, and represent nuances of language and knowledge.</li></ul></li><li><strong>Large Context Size:</strong><ul><li>Our decoder used 30 tokens. LLMs can handle thousands (e.g., GPT-3&rsquo;s 2K-4K) to over a hundred thousand (e.g., Llama 3.1&rsquo;s 128K, some models even 1M+).</li><li>A larger context allows the model to understand and generate text that maintains coherence over much longer spans, remember earlier parts of a conversation or document, and tackle tasks requiring access to more information.</li><li>Achieving this involves architectural improvements like grouped-query attention and FlashAttention, and specialized training stages like <strong>long-context pretraining</strong>.</li></ul></li><li><strong>Large Training Dataset:</strong><ul><li>Our RNN was trained on ~25 million tokens. LLMs are trained on trillions of tokens from diverse sources (books, web pages, code, academic papers, social media).</li><li>This diversity exposes the model to a vast range of language styles, topics, and knowledge.</li><li>Typically, due to the sheer size, models are trained for a <strong>single epoch</strong>.</li></ul></li><li><strong>Large Amount of Compute:</strong><ul><li>Training these models requires enormous computational resources (thousands of GPUs running for months, costing millions of dollars).</li><li>This involves sophisticated parallelization techniques (tensor, pipeline, context, and data parallelism â€“ 4D parallelism).</li></ul></li></ol></li></ul><h2 id=52-supervised-finetuning-sft>5.2 Supervised Finetuning (SFT)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To transform a base pretrained LLM (which is good at next-token prediction but not necessarily at following instructions) into a helpful and instruction-following assistant or a model specialized for specific tasks.</p></li><li><p><strong>The Core Idea (Teaching to Behave):</strong>
While pretraining gives the model its raw knowledge and language understanding, SFT teaches it the <em>format</em> of interaction.</p><ul><li>The model is further trained on a smaller, high-quality dataset of <strong>instruction-response pairs</strong> (or dialogue turns).</li><li>Examples:<ul><li>Instruction: &ldquo;Translate &lsquo;Good night&rsquo; into Spanish.&rdquo; Response: &ldquo;Buenas noches.&rdquo;</li><li>Instruction: &ldquo;Write a poem about a cat.&rdquo; Response: &ldquo;[A poem about a cat]&rdquo;</li></ul></li><li>The model is still trained to predict the next token, but the &ldquo;context&rdquo; is now the instruction, and the &ldquo;target&rdquo; is the desired response.</li><li>This process &ldquo;unlocks&rdquo; the pretrained knowledge and makes it accessible in a conversational or task-oriented way. The book shows the difference between a base <code>gemma-2-2b</code> (just completes text) and <code>gemma-2-2b-it</code> (instruction-tuned, follows the list continuation prompt).</li></ul></li></ul><h2 id=53-finetuning-a-pretrained-model-practical-example>5.3 Finetuning a Pretrained Model (Practical Example)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To walk through the practical steps of finetuning an existing open-weight LLM (like GPT-2 in the book&rsquo;s example) for a specific task, such as emotion classification.</p></li><li><p><strong>Key Steps & Concepts:</strong></p><ol><li><strong>Baseline:</strong> Always good to establish a baseline with a simpler model (e.g., logistic regression with BoW for text classification) to gauge if the complex LLM approach is providing significant benefits.</li><li><strong>Data Formatting:</strong><ul><li>For <strong>emotion generation</strong> (LLM outputs the emotion word): Convert examples into a &ldquo;task description + solution&rdquo; format. E.g., <code>Input: "Predict emotion: I feel very happy\nEmotion:"</code>, <code>Target: "joy [EOS]"</code>.</li><li>The <code>labels</code> tensor for training masks out the input part (e.g., by using -100) so the loss is only computed on the target completion.</li><li><code>attention_mask</code> is used to tell the model which tokens are real and which are padding.</li></ul></li><li><strong>Model Loading:</strong> Using libraries like Hugging Face Transformers (<code>AutoModelForCausalLM</code>, <code>AutoTokenizer</code>). Setting <code>tokenizer.pad_token = tokenizer.eos_token</code> if the model doesn&rsquo;t have a dedicated pad token.</li><li><strong>Finetuning to Follow Instructions (General Case):</strong><ul><li>Requires a <strong>prompting format/style</strong> (e.g., Vicuna, Alpaca, ChatML). This defines how instructions and solutions are structured. Consistency with this format is important during inference.</li><li>The dataset consists of <code>(instruction, solution)</code> pairs.</li><li>The book mentions generating an emotion (like &ldquo;joy&rdquo;) as text output. This is a form of instruction following.</li></ul></li></ol></li></ul><h2 id=54-sampling-from-language-models>5.4 Sampling From Language Models</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To control the way tokens are selected from the model&rsquo;s output probability distribution, balancing creativity and coherence. Greedy decoding (always picking the most probable token) can be repetitive or dull.</p></li><li><p><strong>Techniques:</strong></p><ol><li><strong>Basic Sampling with Temperature:</strong><ul><li>Softmax output probabilities are adjusted by a temperature <code>T</code>.</li><li><code>T > 1</code>: Flatter distribution, more randomness (creative).</li><li><code>T &lt; 1</code>: Sharper distribution, less randomness (focused).</li><li><code>T = 1</code>: Standard softmax.</li></ul></li><li><strong>Top-k Sampling:</strong> Consider only the <code>k</code> most probable tokens and renormalize their probabilities before sampling.</li><li><strong>Top-p (Nucleus) Sampling:</strong> Consider the smallest set of tokens whose cumulative probability exceeds <code>p</code> (e.g., 0.9) and renormalize before sampling. This is adaptive: if the model is very confident (one token has high probability), <code>p</code> might be met by just a few tokens. If uncertain, many tokens might be included.</li><li><strong>Penalties:</strong><ul><li><strong>Frequency Penalty:</strong> Reduces the probability of tokens that have already appeared frequently in the generated text.</li><li><strong>Presence Penalty:</strong> Reduces the probability of tokens that have appeared at all, encouraging new topics.</li></ul></li></ol></li></ul><h2 id=55-low-rank-adaptation-lora>5.5 Low-Rank Adaptation (LoRA)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To significantly reduce the computational cost and memory requirements of finetuning large LLMs, making it accessible to users with limited resources. This is a type of <strong>Parameter-Efficient Finetuning (PEFT)</strong>.</p></li><li><p><strong>The Core Idea (Small Changes, Big Impact):</strong>
Instead of updating all the billions of parameters in an LLM, LoRA freezes the original pretrained weights and introduces a small number of new, trainable &ldquo;adapter&rdquo; matrices.</p><ul><li>For a large weight matrix <code>W_0</code> (e.g., in an attention or MLP layer), LoRA adds two much smaller matrices, <code>A</code> (shape <code>d x r</code>) and <code>B</code> (shape <code>r x k</code>), where <code>r</code> (the rank) is small (e.g., 8, 16).</li><li>During finetuning, only <code>A</code> and <code>B</code> are trained.</li><li>The effective weight matrix becomes <code>W = W_0 + (alpha/r) * B @ A</code>. (The book has <code>AB</code> which might be a slight difference in convention or a typo in my summary; typically it&rsquo;s a low-rank update <code>BA</code> or <code>AB</code> depending on how <code>A</code> and <code>B</code> are defined, the key is the product of two smaller matrices).</li><li>The Hugging Face PEFT library (<code>LoraConfig</code>, <code>get_peft_model</code>) simplifies applying LoRA. You specify which layers/modules to adapt (e.g., query, key, value projections in attention).</li></ul></li></ul><h2 id=56-llm-as-a-classifier-alternative-to-generation>5.6 LLM as a Classifier (Alternative to Generation)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To use an LLM for traditional classification tasks by having it output logits for predefined classes, rather than generating class names as text.</p></li><li><p><strong>How it works:</strong></p><ul><li>Instead of <code>AutoModelForCausalLM</code>, use <code>AutoModelForSequenceClassification</code>.</li><li>This class typically adds a <strong>classification head</strong> (a linear layer + softmax) on top of the final hidden state of the LLM (often the embedding of the last token or a special [CLS] token).</li><li>This head is trained to map the LLM&rsquo;s contextual representation to class probabilities.</li></ul></li></ul><h2 id=57-prompt-engineering>5.7 Prompt Engineering</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To guide a finetuned chat LLM to produce desired outputs by carefully crafting the input prompt, without further changing the model&rsquo;s weights.</p></li><li><p><strong>Features of a Good Prompt:</strong></p><ol><li><strong>Situation:</strong> Context for the request.</li><li><strong>Role:</strong> Persona for the LLM to adopt.</li><li><strong>Task:</strong> Clear, specific instructions.</li><li><strong>Output Format:</strong> JSON, bullet points, etc.</li><li><strong>Constraints:</strong> Limitations, preferences.</li><li><strong>Quality Criteria:</strong> What makes a good response.</li><li><strong>Examples (Few-Shot Prompting / In-Context Learning):</strong> Provide input-output examples.</li><li><strong>Call to Action:</strong> Restate the task.</li></ol></li><li><p><strong>Followup Actions:</strong> Iterating with the LLM, asking for corrections, using different LLMs for review.</p></li><li><p><strong>Code Generation:</strong> Using detailed docstrings and requirements.</p></li><li><p><strong>Documentation Synchronization:</strong> Using LLMs to help keep documentation updated with code changes.</p></li></ul><h2 id=58-hallucinations>5.8 Hallucinations</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To understand why LLMs sometimes generate plausible-sounding but factually incorrect or nonsensical information, and how to mitigate this.</p></li><li><p><strong>Reasons:</strong></p><ul><li>Models optimize for next-token prediction (coherence) not factual accuracy.</li><li>Gaps in training data.</li><li>Low-quality or biased training data.</li><li>Error propagation in token-by-token generation.</li></ul></li><li><p><strong>Prevention/Mitigation:</strong></p><ul><li><strong>Retrieval-Augmented Generation (RAG):</strong> Ground responses in externally retrieved, verified information. The LLM uses this retrieved context to formulate its answer.</li><li><strong>Domain-Specific Pretraining/Finetuning:</strong> Further train on reliable, domain-specific data.</li><li>Multi-step verification workflows, human review.</li></ul></li></ul><h2 id=59-llms-copyright-and-ethics>5.9 LLMs, Copyright, and Ethics</h2><ul><li><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To highlight the complex legal and ethical issues surrounding LLMs.</li><li><strong>Key Issues:</strong><ol><li><strong>Training Data:</strong> Use of copyrighted material in training datasets (fair use debates).</li><li><strong>Generated Content:</strong> Copyright status of AI-generated content, potential for reproducing copyrighted material.</li><li><strong>Open-Weight Models:</strong> Legal implications of sharing weights trained on copyrighted data.</li><li><strong>Broader Ethics:</strong><ul><li><strong>Explainability:</strong> LLM explanations are post-hoc rationalizations, not true transparency into their decision-making process.</li><li><strong>Bias:</strong> LLMs can absorb and amplify societal biases from training data.</li></ul></li></ol></li></ul></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>