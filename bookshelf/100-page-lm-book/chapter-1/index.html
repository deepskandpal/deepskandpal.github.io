<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#chapter-1-machine-learning-basics>Chapter 1: Machine Learning Basics</a></li><li><a href=#chapter-2-language-modeling-basics>Chapter 2: Language Modeling Basics</a></li><li><a href=#chapter-3-recurrent-neural-network-rnn>Chapter 3: Recurrent Neural Network (RNN)</a></li><li><a href=#chapter-4-transformer>Chapter 4: Transformer</a></li><li><a href=#chapter-5-large-language-model-llm>Chapter 5: Large Language Model (LLM)</a></li><li><a href=#chapter-6-further-reading>Chapter 6: Further Reading</a></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 1: Machine Learning Basics</h1><span class=reading-time><em>6 min read</em></span><div class=book-details><div class=book-content><h2 id=chapter-1-machine-learning-basics>Chapter 1: Machine Learning Basics</h2><p>Even for seasoned practitioners, a quick refresher on the fundamentals, especially as they pertain to language models, is key.</p><ul><li><strong>AI and Machine Learning:</strong> We start with a brief history – from the early days of AI with concepts like the Perceptron and ELIZA, through AI winters, to the rise of modern ML with deep learning.</li><li><strong>Model:</strong> At its heart, a model <code>y = f(x)</code>. We explore the simple linear model <code>wx + b</code>, understand parameters (weights and bias), and the crucial concept of a <strong>loss function</strong> (like Mean Squared Error for regression) to quantify error.</li><li><strong>Four-Step ML Process:</strong> This is the core loop:<ol><li>Collect a dataset.</li><li>Define the model&rsquo;s structure.</li><li>Define the loss function.</li><li>Minimize the loss (often using derivatives).</li></ol></li><li><strong>Vector and Matrix:</strong> We then move to representing data and parameters using vectors (feature vectors, dot products, norms, cosine similarity) and matrices (matrix multiplication, transpose). This is vital for understanding how neural networks process data efficiently.</li><li><strong>Neural Network:</strong> We introduce non-linearity with <strong>activation functions</strong> (ReLU, sigmoid, tanh). We look at feedforward neural networks (FNNs), multilayer perceptrons (MLPs), and how layers combine hierarchically.</li><li><strong>Gradient Descent:</strong> Since analytical solutions for minimizing loss in complex NNs are often infeasible, we rely on <strong>gradient descent</strong>. I walk through an example of binary classification using logistic regression, introducing binary cross-entropy loss.</li><li><strong>Automatic Differentiation (Autograd):</strong> Manually deriving gradients is impractical. Modern frameworks like PyTorch automate this with autograd. We see a practical PyTorch example, understanding the <code>forward</code> and <code>backward</code> passes, and the role of tensors.</li></ul><h2 id=chapter-2-language-modeling-basics>Chapter 2: Language Modeling Basics</h2><p>This is where we start tailoring our ML knowledge to text.</p><ul><li><strong>Bag of Words (BoW):</strong> One of the simplest ways to convert text to numbers for tasks like classification. We discuss corpus, vocabulary, tokenization (words and subwords), and vectorization (document-term matrix). For multi-class classification, we introduce the <strong>softmax</strong> activation and <strong>cross-entropy loss</strong>. A PyTorch example shows how to build a simple text classifier.</li><li><strong>Word Embeddings:</strong> BoW has limitations (sparsity, no semantic understanding). Word embeddings (like those from <strong>word2vec&rsquo;s skip-gram</strong> model) represent words as dense vectors where similar words have similar vectors. This allows for capturing semantic similarity and dimensionality reduction.</li><li><strong>Byte-Pair Encoding (BPE):</strong> A common subword tokenization algorithm. It helps manage vocabulary size and handle out-of-vocabulary words by breaking words into smaller, frequently occurring units.</li><li><strong>Language Model Definition:</strong> Formally, a language model predicts the next token in a sequence given previous tokens, P(next_token | context). We focus on <strong>autoregressive (or causal) language models</strong>.</li><li><strong>Count-Based Language Models:</strong> Before neural nets, n-gram models were standard. We look at how they estimate probabilities (e.g., trigram probability P(w3 | w1, w2) based on counts). We discuss challenges like zero probabilities for unseen n-grams and solutions like <strong>backoff</strong> and <strong>Laplace (add-one) smoothing</strong>.</li><li><strong>Evaluating Language Models:</strong><ul><li><strong>Perplexity:</strong> A core metric. Lower is better, indicating the model is less &ldquo;surprised&rdquo; by the test data. It&rsquo;s derived from the average negative log-likelihood.</li><li><strong>ROUGE:</strong> For evaluating models on tasks like summarization, comparing model output to reference (ground truth) texts. We touch on ROUGE-N and ROUGE-L.</li><li><strong>Human Evaluation:</strong> Essential for qualities automated metrics miss. We discuss Likert scales and pairwise comparisons with Elo ratings.</li></ul></li></ul><h2 id=chapter-3-recurrent-neural-network-rnn>Chapter 3: Recurrent Neural Network (RNN)</h2><p>RNNs were a breakthrough for sequential data like text.</p><ul><li><strong>Elman RNN:</strong> The basic RNN structure, where the output at a given step depends on the current input and the hidden state from the previous step. This &ldquo;memory&rdquo; allows RNNs to capture sequential dependencies.</li><li><strong>Mini-Batch Gradient Descent:</strong> A practical necessity for training large models, processing data in small batches.</li><li><strong>Programming an RNN:</strong> We&rsquo;d build an Elman RNN from scratch in PyTorch, understanding how hidden states are passed and updated.</li><li><strong>RNN as a Language Model:</strong> How to use the RNN architecture to predict the next token.</li><li><strong>Embedding Layer:</strong> PyTorch&rsquo;s <code>nn.Embedding</code> layer, which is essentially a lookup table for token embeddings, often trained as part of the model.</li><li><strong>Dataset and DataLoader:</strong> PyTorch utilities for efficiently loading and batching data for training.</li></ul><h2 id=chapter-4-transformer>Chapter 4: Transformer</h2><p>This is the architecture that powers modern LLMs.</p><ul><li><strong>Decoder-Only Architecture:</strong> We focus on this variant, common for autoregressive LMs.</li><li><strong>Key Innovations:</strong><ul><li><strong>Self-Attention:</strong> Allows the model to weigh the importance of different tokens in the input sequence when processing a particular token. We&rsquo;d cover query, key, and value matrices.</li><li><strong>Positional Encoding:</strong> Since transformers process tokens in parallel (unlike RNNs), they need a way to incorporate word order. <strong>Rotary Position Embedding (RoPE)</strong> is a key technique here.</li></ul></li><li><strong>Decoder Block Components:</strong><ul><li>Masked Multi-Head Self-Attention (with RoPE)</li><li>Position-Wise Multilayer Perceptron (MLP)</li><li>Residual Connections (Skip Connections): Crucial for training deep networks by mitigating the vanishing gradient problem.</li><li>Layer Normalization (specifically, <strong>RMSNorm</strong>): Stabilizes training.</li></ul></li><li><strong>Key-Value Caching:</strong> An optimization for faster inference by caching past key and value states.</li><li><strong>Python Implementation:</strong> We build a decoder-only Transformer in PyTorch, piece by piece.</li></ul><h2 id=chapter-5-large-language-model-llm>Chapter 5: Large Language Model (LLM)</h2><p>Here, we scale up and look at practical applications.</p><ul><li><strong>Why Larger is Better:</strong> The impact of scale – more parameters, larger context windows, vast training data, and massive compute – leads to emergent capabilities.</li><li><strong>Supervised Finetuning (SFT):</strong> Pretrained LLMs predict the next token. SFT trains them to follow instructions, answer questions, or engage in dialogue using high-quality instruction-response pairs. We&rsquo;d compare a base pretrained model with its instruction-tuned version.</li><li><strong>Finetuning a Pretrained Model:</strong> Practical steps using a model like GPT-2. We&rsquo;d cover formatting data for tasks like emotion generation (text-to-label) or instruction following (using formats like ChatML).</li><li><strong>Sampling Strategies:</strong> Beyond greedy decoding.<ul><li><strong>Temperature:</strong> Controls randomness.</li><li><strong>Top-k sampling:</strong> Limits selection to k most probable tokens.</li><li><strong>Top-p (Nucleus) sampling:</strong> Selects from the smallest set of tokens whose cumulative probability exceeds p.</li><li><strong>Penalties:</strong> Frequency and presence penalties to discourage repetition.</li></ul></li><li><strong>Low-Rank Adaptation (LoRA):</strong> A parameter-efficient finetuning (PEFT) technique. Instead of finetuning all model weights, LoRA adds and trains small &ldquo;adapter&rdquo; matrices, significantly reducing computational cost.</li><li><strong>LLM as a Classifier:</strong> Attaching a classification head to an LLM.</li><li><strong>Prompt Engineering:</strong> Crafting effective prompts (situation, role, task, format, constraints, examples, call to action). Discussing few-shot prompting and followup strategies.</li><li><strong>Hallucinations:</strong> Why they happen (models optimize for coherence, not truth) and how to mitigate them (e.g., Retrieval-Augmented Generation - RAG, domain-specific pretraining).</li><li><strong>Copyright and Ethics:</strong> Critical considerations around training data and generated content.</li></ul><h2 id=chapter-6-further-reading>Chapter 6: Further Reading</h2><p>Pointers to more advanced topics for continued learning.</p><ul><li><strong>Mixture of Experts (MoE):</strong> Increases model capacity efficiently by routing tokens to specialized sub-networks.</li><li><strong>Model Merging:</strong> Combining multiple pretrained models.</li><li><strong>Model Compression:</strong> Techniques like quantization (e.g., QLoRA) and pruning.</li><li><strong>Preference-Based Alignment:</strong> Methods like RLHF (Reinforcement Learning from Human Feedback) and Constitutional AI to align LLMs with user values.</li><li><strong>Advanced Reasoning:</strong> Chain-of-Thought (CoT), Tree of Thought (ToT), ReAct.</li><li><strong>Security:</strong> Jailbreak attacks, prompt injection.</li><li><strong>Vision Language Models (VLMs):</strong> Models that understand both text and images.</li><li><strong>Preventing Overfitting:</strong> Regularization, dropout, early stopping, validation sets.</li></ul></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>