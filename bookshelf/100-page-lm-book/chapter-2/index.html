<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><ul><li><a href=#21-bag-of-words-bow>2.1 Bag of Words (BoW)</a></li><li><a href=#22-word-embeddings>2.2 Word Embeddings</a></li><li><a href=#23-byte-pair-encoding-bpe>2.3 Byte-Pair Encoding (BPE)</a></li><li><a href=#24-language-model-the-core-definition>2.4 Language Model (The Core Definition)</a></li><li><a href=#25-count-based-language-model-eg-n-gram-models>2.5 Count-Based Language Model (e.g., n-gram models)</a></li><li><a href=#26-evaluating-language-models>2.6 Evaluating Language Models</a></li></ul></li></ul></nav></nav></aside><article class=book-single><h1>Chapter 2: Language Modeling Basics</h1><span class=reading-time><em>10 min read</em></span><div class=book-details><div class=book-content><h2 id=21-bag-of-words-bow>2.1 Bag of Words (BoW)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
The most fundamental problem when dealing with text in machine learning is that algorithms understand numbers, not words. BoW is one of the simplest, oldest, yet often effective, methods to convert a piece of text (a document) into a numerical vector that an ML model can then use, typically for tasks like <strong>classification</strong> (e.g., &ldquo;Is this email spam or not?&rdquo; or &ldquo;What is the topic of this news article?&rdquo;).</p></li><li><p><strong>The Intuition (The &ldquo;Bag&rdquo;):</strong>
Imagine you have a document. You take all the words, throw them into a &ldquo;bag,&rdquo; shake it up, and then count how many times each unique word appears (or simply note its presence/absence). The order of words is lost, just like items in a bag.</p><ul><li><strong>Corpus:</strong> This is just the collection of all documents you&rsquo;re working with.</li><li><strong>Tokenization:</strong> Before you can count, you need to define what a &ldquo;word&rdquo; (or more generally, a &ldquo;token&rdquo;) is. This involves splitting text into pieces – usually words, but sometimes subwords. We often convert everything to lowercase and remove punctuation to treat &ldquo;The&rdquo; and &ldquo;the&rdquo; as the same.</li><li><strong>Vocabulary:</strong> This is the list of all unique tokens found across your entire corpus.</li><li><strong>Vectorization:</strong> For each document, you create a vector. The length of this vector is the size of your vocabulary. Each position in the vector corresponds to a unique word in the vocabulary. The value at that position can be:<ul><li><strong>Binary:</strong> 1 if the word is in the document, 0 if not.</li><li><strong>Count:</strong> The number of times the word appears in the document.</li><li>(Later, we&rsquo;d see TF-IDF, but for basic BoW, counts or binary are common).
This collection of vectors forms a <strong>Document-Term Matrix (DTM)</strong>, where rows are documents and columns are terms (tokens) from the vocabulary.</li></ul></li></ul></li><li><p><strong>Realism and Limitations:</strong></p><ul><li><strong>Sparsity:</strong> Most documents only contain a small subset of the entire vocabulary. So, these BoW vectors are usually very sparse (mostly zeros), which can be inefficient.</li><li><strong>Loss of Order:</strong> &ldquo;Man bites dog&rdquo; and &ldquo;Dog bites man&rdquo; would have very similar (or identical) BoW representations, even though their meanings are opposite. Context is lost.</li><li><strong>No Semantic Understanding:</strong> &ldquo;Automobile&rdquo; and &ldquo;car&rdquo; are treated as completely different words, even though they are synonyms. The model has no inherent understanding of their similarity.</li><li><strong>Out-of-Vocabulary (OOV) words:</strong> If a new word appears during prediction that wasn&rsquo;t in the training corpus (and thus not in the vocabulary), BoW has no way to represent it.</li></ul></li><li><p><strong>Connecting to ML (for classification, as in the book):</strong>
Once you have these numerical vectors for your documents, and you have labels (e.g., &ldquo;Cinema,&rdquo; &ldquo;Music,&rdquo; &ldquo;Science&rdquo;), you can train a classifier. For more than two classes (multiclass classification), we typically use the <strong>softmax activation function</strong> in the output layer of a neural network. Softmax converts raw scores (logits) from the network into a probability distribution over the classes – each class gets a probability, and they all sum to 1. The <strong>cross-entropy loss</strong> is then used to measure how far these predicted probabilities are from the true (one-hot encoded) labels.</p></li></ul><h2 id=22-word-embeddings>2.2 Word Embeddings</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To overcome the limitations of BoW, especially the lack of semantic understanding and sparsity. Word embeddings aim to represent words as <strong>dense, lower-dimensional vectors</strong> such that words with similar meanings have similar vector representations (i.e., they are &ldquo;close&rdquo; in the vector space).</p></li><li><p><strong>The Intuition (Words as Dense Vectors):</strong>
Instead of a massive, sparse vector where only one position is &lsquo;1&rsquo; (like in a one-hot encoding of a word from BoW), each word gets a shorter vector (e.g., 100-300 dimensions instead of 50,000) where most numbers are non-zero. These numbers aren&rsquo;t just counts; they are <em>learned</em> parameters that capture semantic properties. The classic example is that the vector operation <code>vector("king") - vector("man") + vector("woman")</code> results in a vector very close to <code>vector("queen")</code>.</p></li><li><p><strong>How it&rsquo;s typically done (conceptual, like with Word2vec&rsquo;s skip-gram):</strong>
The core idea, popularized by algorithms like Word2vec (Tomáš Mikolov&rsquo;s work!), is that <em>words that appear in similar contexts tend to have similar meanings</em>.</p><ul><li>A neural network is trained on a large corpus of text. Its task isn&rsquo;t classification, but something like: given a word (the &ldquo;target&rdquo; word), predict its surrounding words (the &ldquo;context&rdquo; words), or vice-versa.</li><li>The magic happens in the &ldquo;embedding layer&rdquo; of this network. After training, this layer contains the dense vector representations for each word in the vocabulary. We then discard the rest of the network and just keep these learned embeddings.</li><li>These embeddings are learned from unlabeled text – you don&rsquo;t need explicit labels like &ldquo;spam&rdquo; or &ldquo;sports&rdquo; for every document.</li></ul></li><li><p><strong>Benefits:</strong></p><ul><li><strong>Semantic Similarity:</strong> Cosine similarity between word vectors can quantify how similar words are in meaning.</li><li><strong>Dimensionality Reduction:</strong> Vectors are much smaller than BoW vocabularies.</li><li><strong>Improved Generalization:</strong> Models can generalize better because they understand that &ldquo;car&rdquo; and &ldquo;automobile&rdquo; are related.</li></ul></li><li><p><strong>Realism:</strong> These embeddings are powerful but are only as good as the data they were trained on. They can still inherit biases present in the training text.</p></li></ul><h2 id=23-byte-pair-encoding-bpe>2.3 Byte-Pair Encoding (BPE)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To address two main problems:</p><ol><li><strong>Huge Vocabularies:</strong> If you treat every unique word as a token, vocabularies can become enormous, especially with morphologically rich languages or typos.</li><li><strong>Out-of-Vocabulary (OOV) Words:</strong> Word embedding models still struggle if a word was never seen during their training.
BPE is a <strong>subword tokenization</strong> algorithm. It breaks words into smaller, frequently occurring units (subwords).</li></ol></li><li><p><strong>The Intuition (Smart Splitting):</strong>
Start by treating every individual character as a token. Then, iteratively find the most frequent pair of adjacent tokens (characters or already formed subwords) in your corpus and merge them into a new, single token. Repeat this for a fixed number of merges or until your vocabulary reaches a desired size.
For example, &ldquo;lowest&rdquo; might initially be <code>l o w e s t</code>. If <code>es</code> is a frequent pair, it becomes <code>l o w es t</code>. If <code>est</code> then becomes frequent, it&rsquo;s <code>l o w est</code>. The underscore <code>_</code> is often added to mark the start of a word (e.g., <code>_low est</code>) to differentiate subwords at the beginning of words from those in the middle.</p></li><li><p><strong>Benefits:</strong></p><ul><li><strong>Manages Vocabulary Size:</strong> You can control the final vocabulary size.</li><li><strong>Handles OOV Words:</strong> Unknown words can often be represented as a sequence of known subwords (e.g., &ldquo;unfamiliarword&rdquo; might become &ldquo;_un&rdquo;, &ldquo;famil&rdquo;, &ldquo;iar&rdquo;, &ldquo;word&rdquo;).</li><li><strong>Captures Morphology:</strong> &ldquo;running&rdquo; might be tokenized as &ldquo;_runn&rdquo;, &ldquo;ing&rdquo;, sharing the &ldquo;_runn&rdquo; part with &ldquo;runner.&rdquo;</li></ul></li><li><p><strong>Realism:</strong> The choice of vocabulary size is a hyperparameter. There are other subword tokenization methods too (like WordPiece, SentencePiece). BPE is a common and foundational one.</p></li></ul><h2 id=24-language-model-the-core-definition>2.4 Language Model (The Core Definition)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To assign a probability to a sequence of tokens. More practically, and more commonly for autoregressive models (which we focus on), it&rsquo;s about <strong>predicting the next token in a sequence given all the preceding tokens.</strong>
<code>P(current_token | previous_tokens)</code></p></li><li><p><strong>The Intuition (Super Autocomplete):</strong>
Think of the autocomplete on your phone, but much more powerful. Given &ldquo;The cat sat on the&mldr;&rdquo;, a good language model would assign a high probability to &ldquo;mat,&rdquo; a lower one to &ldquo;table,&rdquo; and a very low one to &ldquo;banana.&rdquo;</p></li><li><p><strong>Key Idea:</strong> It learns the statistical patterns of language. It&rsquo;s not <em>understanding</em> in a human sense, but it&rsquo;s very good at figuring out what typically follows what. The output for the next token is a <strong>probability distribution over the entire vocabulary</strong>.</p></li></ul><h2 id=25-count-based-language-model-eg-n-gram-models>2.5 Count-Based Language Model (e.g., n-gram models)</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To implement the language model definition <code>P(current_token | previous_tokens)</code> using simple frequency counts of n-grams from a large text corpus. &ldquo;n-gram&rdquo; just means a sequence of &rsquo;n&rsquo; tokens.</p></li><li><p><strong>The Intuition (Simple Frequencies):</strong>
If we want to predict the word after &ldquo;the cat sat on,&rdquo; we look at our corpus and see how many times &ldquo;the cat sat on&rdquo; appears. Then, among those occurrences, we count how many times each different word followed.</p><ul><li>A <strong>unigram</strong> model considers only the current word&rsquo;s frequency (P(word)).</li><li>A <strong>bigram</strong> model considers the previous word (P(word_i | word_{i-1})).</li><li>A <strong>trigram</strong> model (as in the book example) considers the two previous words (P(word_i | word_{i-2}, word_{i-1})).
The probability is calculated as:
<code>P(w_i | w_{i-2}, w_{i-1}) = count(w_{i-2}, w_{i-1}, w_i) / count(w_{i-2}, w_{i-1})</code>
This is a <strong>Maximum Likelihood Estimate (MLE)</strong>.</li></ul></li><li><p><strong>Realism and Limitations:</strong></p><ul><li><strong>Sparsity & Zero Probabilities:</strong> What if the specific trigram <code>(w_{i-2}, w_{i-1}, w_i)</code> or even the bigram <code>(w_{i-2}, w_{i-1})</code> never appeared in your training corpus? You&rsquo;d get a zero probability, which is bad because it means the model thinks a perfectly valid sequence is impossible.</li><li><strong>Solutions:</strong><ul><li><strong>Backoff:</strong> If the trigram count is zero, &ldquo;back off&rdquo; and use the bigram probability. If that&rsquo;s zero, use the unigram probability.</li><li><strong>Smoothing (e.g., Laplace / Add-one Smoothing):</strong> Add a small count (like 1) to all observed n-gram counts, and adjust the denominator accordingly. This ensures no probability is ever strictly zero.</li></ul></li><li><strong>Limited Context:</strong> N-gram models can only look back &rsquo;n-1&rsquo; tokens. They can&rsquo;t capture long-range dependencies in text (e.g., a pronoun referring to a noun many sentences earlier).</li><li><strong>Storage:</strong> Storing counts for all possible n-grams (especially for n > 3 or 4) can become massive.</li></ul></li></ul><h2 id=26-evaluating-language-models>2.6 Evaluating Language Models</h2><ul><li><p><strong>What it&rsquo;s ultimately trying to achieve:</strong>
To objectively measure how good a language model is. This is crucial for comparing different models or different versions of the same model during development.</p></li><li><p><strong>Key Metrics:</strong></p><ul><li><strong>Perplexity (PPL):</strong><ul><li><em>Intuition:</em> A measure of how &ldquo;surprised&rdquo; or &ldquo;perplexed&rdquo; the model is by a sequence of text it hasn&rsquo;t seen before (the test set). <strong>Lower perplexity is better.</strong> It&rsquo;s related to the average number of choices the model effectively has at each step of prediction. If PPL is 10, it&rsquo;s as if the model is choosing uniformly from 10 words at each step.</li><li><em>Calculation:</em> It&rsquo;s the exponential of the average negative log-likelihood of the test set words. The negative log-likelihood is high if the model assigns low probabilities to the words that actually occurred.</li></ul></li><li><strong>ROUGE (Recall-Oriented Understudy for Gisting Evaluation):</strong><ul><li><em>Intuition:</em> Primarily used for evaluating tasks like text summarization or machine translation, where the model generates a chunk of text. It measures the overlap (e.g., of unigrams, bigrams, or longest common subsequences) between the model-generated text and one or more human-written reference texts (ground truth).</li><li><em>Variants:</em> ROUGE-1 (unigram overlap), ROUGE-N (n-gram overlap), ROUGE-L (longest common subsequence). Higher is generally better.</li></ul></li><li><strong>Human Evaluation:</strong><ul><li><em>Intuition:</em> Automated metrics don&rsquo;t capture everything (e.g., fluency, coherence, factual correctness, engagingness). Humans are often the gold standard.</li><li><em>Methods:</em><ul><li><strong>Likert Scales:</strong> Raters score model outputs on predefined scales (e.g., 1-5 for fluency).</li><li><strong>Pairwise Comparison / Elo Ratings:</strong> Raters are shown outputs from two different models and choose which one is better. Over many comparisons, this can produce a relative ranking (like Elo ratings in chess).</li></ul></li></ul></li></ul></li><li><p><strong>Realism:</strong> No single metric is perfect. The best metric often depends on the specific downstream task the language model is intended for. Comparing perplexity scores is only meaningful if the models use the exact same vocabulary and tokenization.</p></li></ul></div></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>