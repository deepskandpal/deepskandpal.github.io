<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class="post-single page-strings"><h1>Strings</h1><span class=reading-time><em>14 min read</em></span><div class=post-content><p>Absolutely! That 6-step process you&rsquo;ve outlined is GOLD. It&rsquo;s precisely how you build deep, intuitive understanding, especially for recursive problems which can feel like black magic otherwise. You&rsquo;re essentially becoming the debugger and the CPU, tracing the logic yourself.</p><p>For Chapter 6 (Strings) in EPI Python, here are a few &ldquo;keystone&rdquo; problems that lend themselves exceptionally well to your 6-step deep dive method. These problems either involve recursion (like your Towers of Hanoi example) or intricate iterative logic where hand-simulation is invaluable.</p><p><strong>Top Keystone Problems for Your 6-Step Method:</strong></p><ol><li><p><strong>6.7 Compute All Mnemonics for a Phone Number (Page 74)</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> This is a classic recursion/backtracking problem. You&rsquo;re exploring a tree of possibilities. Your 6-step method is <em>perfect</em> for this. Understanding how the <code>partial_mnemonic</code> is built up and how the <code>digit_index</code> drives the recursion is key.</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: For each digit, try all its possible letters.</li><li>Parameters: Current digit index being processed, the partially built mnemonic string.</li><li>Base Case: All digits processed.</li><li>Hand-simulation: Crucial for N=2 or N=3 digits to see the call stack unfold.</li><li>Pseudocode: Will clearly show the loop for letters and the recursive call.</li></ul></li></ul></li><li><p><strong>6.10 Compute All Valid IP Addresses (Page 77)</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> Another excellent recursion/backtracking problem. It&rsquo;s about partitioning a string into 4 valid parts. Slightly more complex than mnemonics due to segment validation rules (0-255, no leading zeros for multi-digit segments).</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: Try to make 3 cuts in the string to form 4 segments.</li><li>Parameters: Index in the input string to start forming the current segment, number of segments already formed, list of current segments.</li><li>Base Case: 4 segments formed AND the entire input string is consumed.</li><li>Hand-simulation: With a short string like &ldquo;19216811&rdquo; or even &ldquo;2552551111&rdquo;, trying to place the dots.</li></ul></li></ul></li><li><p><strong>6.2 Base Conversion (Page 69) - Specifically, the <code>construct_from_base</code> part, or the &ldquo;integer to string in base b2&rdquo; logic.</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> While the overall problem has two parts (string_base1 -> int, then int -> string_base2), the second part is often naturally recursive. It&rsquo;s a simpler recursion than mnemonics but beautifully illustrates the &ldquo;divide problem, solve subproblem, combine result&rdquo; pattern. The variant in 6.3 (Integer to Spreadsheet Column ID) is very similar.</li><li><strong>Fits your 6 Steps (for int to string_base_b2):</strong><ul><li>High-level: To convert N to base B, get the last digit (N % B), then convert N // B to base B and append the digit.</li><li>Parameters: The integer to convert, the target base.</li><li>Base Case: Integer is 0.</li><li>Hand-simulation: Convert 10 (decimal) to base 2. <code>construct_from_base(10, 2)</code>.</li></ul></li></ul></li><li><p><strong>6.4 Replace and Remove (Page 71) - For iterative deep dive.</strong></p><ul><li><strong>Why it&rsquo;s Keystone (Iterative):</strong> This problem is a gem for understanding multi-pass algorithms and in-place manipulation using two (or more) pointers within an array (or list of characters). It&rsquo;s not recursive, but your hand-simulation step (Step 2) and pseudocode (Step 3) are vital for getting the pointer logic correct.</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: First pass to remove &lsquo;b&rsquo;s and count &lsquo;a&rsquo;s (to know final size). Second pass (backwards) to do the &lsquo;a&rsquo; -> &lsquo;dd&rsquo; replacement.</li><li>Parameters (for helper functions or main logic): The character array/list, current read index, current write index, count of &lsquo;a&rsquo;s.</li><li>Base Case (for loops): Reaching end of array / start of array.</li><li>Hand-simulation: Absolutely critical! Track <code>read_idx</code>, <code>write_idx</code>, <code>a_count</code> on paper with an example like <code>(a,c,d,b,b,c,a)</code>.</li></ul></li></ul></li></ol><p><strong>Recommendation:</strong></p><p>Start with <strong>6.7 Compute All Mnemonics for a Phone Number</strong>. It&rsquo;s the purest example of recursion in this list that directly mirrors the &ldquo;Towers of Hanoi&rdquo; style of thinking (exploring choices at each step).</p><p>Let&rsquo;s imagine you pick <strong>6.7 Compute All Mnemonics for a Phone Number</strong>. Here&rsquo;s how you might approach it with your 6 steps, and I can guide you through it:</p><ul><li><p><strong>Your Step 1: Go through my teaching / EPI explanation.</strong></p><ul><li><em>My Teaching (High Level):</em> The goal is to generate all possible letter sequences for a given phone number string (e.g., &ldquo;23&rdquo;). Digit &lsquo;2&rsquo; maps to &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;. Digit &lsquo;3&rsquo; maps to &lsquo;D&rsquo;, &lsquo;E&rsquo;, &lsquo;F&rsquo;. We need to combine these: &ldquo;AD&rdquo;, &ldquo;AE&rdquo;, &ldquo;AF&rdquo;, &ldquo;BD&rdquo;, &ldquo;BE&rdquo;, &ldquo;BF&rdquo;, &ldquo;CD&rdquo;, &ldquo;CE&rdquo;, &ldquo;CF&rdquo;. This sounds like we make a choice for the first digit, then for that choice, we make a choice for the second digit, and so on. This &ldquo;and so on&rdquo; hints at recursion!</li><li><em>Parameters (for the recursive helper function):</em><ol><li><code>digit_index</code>: Which digit of the phone number are we currently trying to find a letter for?</li><li><code>partial_mnemonic</code>: A list (or array) of characters representing the mnemonic built <em>so far</em> up to <code>digit_index - 1</code>.</li></ol></li><li><em>Base Case:</em> What&rsquo;s the simplest state? When we&rsquo;ve processed all digits! If <code>digit_index</code> is equal to the length of the phone number, it means we&rsquo;ve successfully chosen a letter for every digit. So, we add the <code>partial_mnemonic</code> (joined into a string) to our list of results.</li></ul></li><li><p><strong>Your Step 2 (NEW - Hand-Simulate with Pen and Paper FOR A SMALL CASE):</strong></p><ul><li>Let <code>phone_number = "23"</code>. <code>MAPPING = {..., '2':"ABC", '3':"DEF", ...}</code>.
Let <code>results = []</code>, <code>partial_mnemonic = [_, _]</code> (length of phone_number).</li><li><code>mnemonic_helper(digit_index=0, partial_mnemonic)</code>:<ul><li>Current digit is <code>phone_number[0]</code> which is &lsquo;2&rsquo;. Letters are &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;.</li><li><strong>Try &lsquo;A&rsquo;</strong>: <code>partial_mnemonic[0] = 'A'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['A',_])</code>.<ul><li>Current digit is <code>phone_number[1]</code> which is &lsquo;3&rsquo;. Letters are &lsquo;D&rsquo;, &lsquo;E&rsquo;, &lsquo;F&rsquo;.</li><li><strong>Try &lsquo;D&rsquo;</strong>: <code>partial_mnemonic[1] = 'D'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','D'])</code>.<ul><li><code>digit_index (2) == len("23") (2)</code>. Base Case! Add &ldquo;AD&rdquo; to <code>results</code>. Return.</li></ul></li><li><strong>Try &lsquo;E&rsquo;</strong>: <code>partial_mnemonic[1] = 'E'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','E'])</code>.<ul><li>Base Case! Add &ldquo;AE&rdquo; to <code>results</code>. Return.</li></ul></li><li><strong>Try &lsquo;F&rsquo;</strong>: <code>partial_mnemonic[1] = 'F'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','F'])</code>.<ul><li>Base Case! Add &ldquo;AF&rdquo; to <code>results</code>. Return.</li></ul></li><li>Done with letters for digit &lsquo;3&rsquo; (when first digit was &lsquo;A&rsquo;). Return from this call.</li></ul></li><li><strong>Try &lsquo;B&rsquo;</strong>: <code>partial_mnemonic[0] = 'B'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['B',_])</code>.<ul><li>&mldr; (similar logic, will generate &ldquo;BD&rdquo;, &ldquo;BE&rdquo;, &ldquo;BF&rdquo;)</li></ul></li><li><strong>Try &lsquo;C&rsquo;</strong>: <code>partial_mnemonic[0] = 'C'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['C',_])</code>.<ul><li>&mldr; (similar logic, will generate &ldquo;CD&rdquo;, &ldquo;CE&rdquo;, &ldquo;CF&rdquo;)</li></ul></li><li>Done with letters for digit &lsquo;2&rsquo;. Return from initial call.</li></ul></li><li>Wow! Doing this on paper, you actually <em>see</em> the depth-first traversal of the decision tree.</li></ul></li><li><p><strong>Your Step 3 (NEW - Pseudocode/Skeleton Code):</strong></p><pre tabindex=0><code>MAPPING = {&#39;0&#39;:&#39;0&#39;, &#39;1&#39;:&#39;1&#39;, &#39;2&#39;:&#39;ABC&#39;, ...} // Global or passed in

function generate_mnemonics(phone_number_string):
    results_list = []
    current_partial_mnemonic = array_of_chars of size len(phone_number_string)

    mnemonic_recursive_helper(digit_idx = 0, current_partial_mnemonic, results_list, phone_number_string)
    return results_list

function mnemonic_recursive_helper(digit_idx, partial_mnemonic_chars, all_results, original_phone_num):
    if digit_idx == len(original_phone_num): // Base Case
        add join(partial_mnemonic_chars) to all_results
        return

    current_digit_char = original_phone_num[digit_idx]
    possible_letters_for_digit = MAPPING[current_digit_char]

    for each letter L in possible_letters_for_digit:
        partial_mnemonic_chars[digit_idx] = L
        mnemonic_recursive_helper(digit_idx + 1, partial_mnemonic_chars, all_results, original_phone_num)
        // No cleanup needed for partial_mnemonic_chars[digit_idx] here because the next iteration 
        // of the loop (or the call from a higher stack frame) will overwrite it.
</code></pre></li><li><p><strong>Your Step 4: Translate to Actual Code.</strong>
Now you&rsquo;d try to write the Python code. You&rsquo;d initialize <code>MAPPING</code>, the main function, and the helper. The <code>partial_mnemonic</code> in Python is often a list of characters which you then <code>"".join()</code> in the base case.</p></li><li><p><strong>Your Step 5 (CRUCIAL - Debug and Test):</strong>
Run with &ldquo;2&rdquo;, then &ldquo;23&rdquo;. Add <code>print()</code> statements inside the helper:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Helper called: digit_idx=</span><span style=color:#e6db74>{</span>digit_idx<span style=color:#e6db74>}</span><span style=color:#e6db74>, partial_mnemonic_so_far=</span><span style=color:#e6db74>{</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(partial_mnemonic_chars[:digit_idx])<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  Current digit: </span><span style=color:#e6db74>{</span>original_phone_num[digit_idx]<span style=color:#e6db74>}</span><span style=color:#e6db74>, Letters: </span><span style=color:#e6db74>{</span>possible_letters_for_digit<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># In the base case:</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;    Base Case Reached! Adding: </span><span style=color:#e6db74>{</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(partial_mnemonic_chars)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>This tracing is invaluable.</p></li><li><p><strong>Your Step 6: Reflect and Solidify.</strong></p><ul><li>&ldquo;Base case was when <code>digit_idx</code> reached the end of the phone number.&rdquo;</li><li>&ldquo;Problem got smaller by incrementing <code>digit_idx</code>, focusing on the next digit.&rdquo;</li><li>&ldquo;Arguments changed: <code>digit_idx</code> increased. <code>partial_mnemonic_chars</code> had one more character filled in.&rdquo;</li><li>&ldquo;The loop iterates through choices for the <em>current</em> digit. The recursive call solves the problem for the <em>rest</em> of the digits given that choice.&rdquo;</li></ul></li></ul><p><strong>Core Concept 1: What a Number Represents (Positional Notation)</strong></p><p>When we see a number like <strong>345</strong> (in our everyday base 10):</p><ul><li>It&rsquo;s NOT &ldquo;three and four and five.&rdquo;</li><li>It IS:<ul><li><strong>3</strong> hundreds (3 * 10²)</li><li><strong>4</strong> tens (4 * 10¹)</li><li><strong>5</strong> ones (5 * 10⁰)</li></ul></li></ul><p>The <strong>position</strong> of a digit tells us what <strong>power of the base</strong> it&rsquo;s multiplying.
The base here is 10 because we use 10 unique symbols (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).</p><p><strong>Generalizing to any base <code>B</code>:</strong>
If you have a number string <code>d_k ... d_2 d_1 d_0</code> in base <code>B</code> (where each <code>d_i</code> is a digit valid for that base, i.e., 0 to B-1):
Its value in base 10 is:
<code>d_k * (B^k) + ... + d_2 * (B^2) + d_1 * (B^1) + d_0 * (B^0)</code></p><p><strong>Example: &ldquo;101&rdquo; in base 2 (binary)</strong>
Base <code>B = 2</code>. Digits are 0, 1.
&ldquo;101&rdquo; means:</p><ul><li>1 * (2²) = 1 * 4 = 4</li><li>0 * (2¹) = 0 * 2 = 0</li><li>1 * (2⁰) = 1 * 1 = 1
Total value in base 10 = 4 + 0 + 1 = <strong>5</strong>.</li></ul><p><strong>Example: &ldquo;1A&rdquo; in base 16 (hexadecimal)</strong>
Base <code>B = 16</code>. Digits are 0-9, A(10), B(11), C(12), D(13), E(14), F(15).
&ldquo;1A&rdquo; means:</p><ul><li>1 * (16¹) = 1 * 16 = 16</li><li>A (which is 10) * (16⁰) = 10 * 1 = 10
Total value in base 10 = 16 + 10 = <strong>26</strong>.</li></ul><p><strong>Core Concept 2: Converting a String in Base <code>B</code> to its Base 10 Integer Value</strong></p><p>This is what we did in:</p><ul><li><code>string_to_int</code> (for base 10)</li><li>Part 1 of <code>convert_base</code> (for generic <code>b1</code>)</li><li><code>ss_decode_col_id</code> (a variation for base 26 with digits 1-26)</li></ul><p><strong>The Algorithm (Iterative, Left-to-Right):</strong></p><ol><li>Initialize <code>value_in_base10 = 0</code>.</li><li>For each <code>digit_char</code> in the input string (from left to right):
a. Convert <code>digit_char</code> to its integer <code>digit_value</code> (e.g., &lsquo;A&rsquo; -> 10).
b. <code>value_in_base10 = value_in_base10 * B + digit_value</code>.</li><li>The final <code>value_in_base10</code> is your answer.</li></ol><p><strong>Why does <code>value_in_base10 = value_in_base10 * B + digit_value</code> work?</strong>
Let the string be <code>d_2 d_1 d_0</code> in base B.</p><ul><li>Initially: <code>value = 0</code></li><li>Process <code>d_2</code>: <code>value = 0 * B + d_2_val = d_2_val</code></li><li>Process <code>d_1</code>: <code>value = d_2_val * B + d_1_val</code></li><li>Process <code>d_0</code>: <code>value = (d_2_val * B + d_1_val) * B + d_0_val</code>
<code>= d_2_val * B^2 + d_1_val * B + d_0_val</code>
This exactly matches the formula from Core Concept 1!</li></ul><hr><p><strong>Core Concept 3: Converting a Base 10 Integer to a String in Base <code>B</code></strong></p><p>This is what we did in:</p><ul><li><code>int_to_string</code> (for base 10)</li><li>Part 2 of <code>convert_base</code> (the <code>construct_from_base</code> part, for generic <code>b2</code>)</li><li>The &ldquo;integer to spreadsheet column&rdquo; variant.</li></ul><p><strong>The Algorithm (Iterative, gets digits in reverse order):</strong></p><ol><li>Let <code>num</code> be the integer value in base 10.</li><li>Initialize an empty list <code>result_digits_reversed</code>.</li><li>While <code>num > 0</code>:
a. <code>remainder = num % B</code> (This <code>remainder</code> is the <em>last</em> digit in base <code>B</code>).
b. Convert <code>remainder</code> to its <code>char_representation</code> (e.g., 10 -> &lsquo;A&rsquo;).
c. Add <code>char_representation</code> to <code>result_digits_reversed</code>.
d. <code>num = num // B</code> (Integer division; effectively removes the last digit we just processed).</li><li>If <code>result_digits_reversed</code> is empty (meaning original <code>num</code> was 0), the answer is &ldquo;0&rdquo;.</li><li>Otherwise, reverse <code>result_digits_reversed</code> and join the characters to form the final string.</li></ol><p><strong>Why does <code>num % B</code> give the last digit and <code>num // B</code> give the rest?</strong>
Consider <code>345</code> (base 10) converting to base 10 (just for illustration). <code>B=10</code>.</p><ul><li><code>num = 345</code><ul><li><code>345 % 10 = 5</code> (last digit)</li><li><code>345 // 10 = 34</code> (the rest of the number without the last digit)</li></ul></li><li><code>num = 34</code><ul><li><code>34 % 10 = 4</code> (new last digit)</li><li><code>34 // 10 = 3</code> (the rest)</li></ul></li><li><code>num = 3</code><ul><li><code>3 % 10 = 3</code></li><li><code>3 // 10 = 0</code>
Stop. Digits collected (in reverse): 5, 4, 3. Reversed: 3, 4, 5. String: &ldquo;345&rdquo;.</li></ul></li></ul><p>This logic works for <em>any</em> target base <code>B</code>.
Example: <code>26</code> (base 10) to base 16. <code>B=16</code>.</p><ul><li><code>num = 26</code><ul><li><code>26 % 16 = 10</code> (Digit &lsquo;A&rsquo;)</li><li><code>26 // 16 = 1</code>
Digits list: <code>['A']</code></li></ul></li><li><code>num = 1</code><ul><li><code>1 % 16 = 1</code> (Digit &lsquo;1&rsquo;)</li><li><code>1 // 16 = 0</code>
Digits list: <code>['A', '1']</code>
Stop. Reversed list joined: &ldquo;1A&rdquo;.</li></ul></li></ul><p><strong>Spreadsheet Column Variation (1-indexed &ldquo;digits&rdquo;):</strong></p><ul><li><p><strong>String to Int (&ldquo;AA&rdquo; -> 27):</strong>
This is like Core Concept 2, <code>result = result * 26 + digit_value</code>, but <code>digit_value</code> is 1 for &lsquo;A&rsquo;, 2 for &lsquo;B&rsquo;, &mldr;, 26 for &lsquo;Z&rsquo;.
&ldquo;AA&rdquo;:
<code>result = 0</code>
&lsquo;A&rsquo; (val 1): <code>result = 0 * 26 + 1 = 1</code>
&lsquo;A&rsquo; (val 1): <code>result = 1 * 26 + 1 = 27</code></p></li><li><p><strong>Int to String (27 -> &ldquo;AA&rdquo;):</strong>
This is like Core Concept 3, but because the &ldquo;digits&rdquo; are 1-26 (not 0-25), we use a trick.
To get a 0-25 index for our character map (&lsquo;A&rsquo; at index 0): <code>(num - 1) % 26</code>.
To update <code>num</code> for the next iteration: <code>num = (num - 1) // 26</code>.
<code>num = 27</code>:
<code>idx = (27-1)%26 = 0</code> (&lsquo;A&rsquo;)
<code>num = (27-1)//26 = 1</code>
List: <code>['A']</code>
<code>num = 1</code>:
<code>idx = (1-1)%26 = 0</code> (&lsquo;A&rsquo;)
<code>num = (1-1)//26 = 0</code>
List: <code>['A', 'A']</code>
Reversed: &ldquo;AA&rdquo;.</p></li></ul><p><strong>Key Takeaways for Base Problems:</strong></p><ol><li><strong>Understand Positional Value:</strong> A digit&rsquo;s worth depends on its place and the base.</li><li><strong>String to Integer (Any Base <code>B</code> to Base 10):</strong><ul><li><code>value = 0</code></li><li>Loop: <code>value = value * B + current_digit_numeric_value</code></li></ul></li><li><strong>Integer to String (Base 10 to Any Base <code>B</code>):</strong><ul><li>Loop:<ul><li><code>remainder = number % B</code> (this is your next digit, in reverse order)</li><li><code>number = number // B</code></li></ul></li><li>Collect remainders, then reverse.</li></ul></li><li><strong>Character to Digit Value:</strong> You need a way to map &lsquo;0&rsquo;-&lsquo;9&rsquo;, &lsquo;A&rsquo;-&lsquo;F&rsquo; to their numeric values (0-9, 10-15). <code>ord()</code> helps.</li><li><strong>Digit Value to Character:</strong> You need a way to map numeric values back to characters. <code>chr()</code> helps.</li></ol><p>Does this focused revision on the number system concepts themselves make more sense for approaching these types of problems? The string part is often just how you get the digits in or how you format the digits out. The <em>math</em> is the core.</p><p>That&rsquo;s a great, specific question! That piece of code is a common trick to convert an alphabet character (specifically &lsquo;a&rsquo; through &lsquo;f&rsquo;, or &lsquo;A&rsquo; through &lsquo;F&rsquo; for hexadecimal) into its corresponding integer value (10 through 15).</p><p>Let&rsquo;s break it down piece by piece, assuming <code>char_digit</code> is something like &lsquo;A&rsquo;, &lsquo;b&rsquo;, &lsquo;C&rsquo;, etc.</p><ol><li><p><strong><code>char_digit.lower()</code></strong></p><ul><li>This first converts the character to its lowercase equivalent.</li><li>If <code>char_digit</code> is &lsquo;A&rsquo;, <code>char_digit.lower()</code> becomes &lsquo;a&rsquo;.</li><li>If <code>char_digit</code> is &lsquo;b&rsquo;, <code>char_digit.lower()</code> remains &lsquo;b&rsquo;.</li><li>If <code>char_digit</code> is &lsquo;F&rsquo;, <code>char_digit.lower()</code> becomes &lsquo;f&rsquo;.</li><li><strong>Why?</strong> This standardizes the input so we only have to compare against lowercase &lsquo;a&rsquo; through &lsquo;f&rsquo;. It makes the subsequent logic simpler.</li></ul></li><li><p><strong><code>ord(...)</code></strong></p><ul><li>The <code>ord()</code> function in Python returns the Unicode code point (which for common English characters is the same as its ASCII value) of a given character.</li><li>For example:<ul><li><code>ord('a')</code> might be 97 (this value can vary slightly by system encoding but the relative differences are constant for ASCII).</li><li><code>ord('b')</code> would then be 98.</li><li><code>ord('c')</code> would be 99.</li><li>&mldr;</li><li><code>ord('f')</code> would be 102.</li></ul></li><li>The key is that alphabetical characters have consecutive <code>ord()</code> values.</li></ul></li><li><p><strong><code>ord(char_digit.lower()) - ord('a')</code></strong></p><ul><li>This part calculates the &ldquo;offset&rdquo; or &ldquo;distance&rdquo; of our character from &lsquo;a&rsquo;.</li><li>Let&rsquo;s see some examples:<ul><li>If <code>char_digit</code> was &lsquo;A&rsquo; (so <code>char_digit.lower()</code> is &lsquo;a&rsquo;):
<code>ord('a') - ord('a')</code> = <code>97 - 97</code> = <code>0</code></li><li>If <code>char_digit</code> was &lsquo;B&rsquo; (so <code>char_digit.lower()</code> is &lsquo;b&rsquo;):
<code>ord('b') - ord('a')</code> = <code>98 - 97</code> = <code>1</code></li><li>If <code>char_digit</code> was &lsquo;C&rsquo; (so <code>char_digit.lower()</code> is &lsquo;c&rsquo;):
<code>ord('c') - ord('a')</code> = <code>99 - 97</code> = <code>2</code></li><li>&mldr;</li><li>If <code>char_digit</code> was &lsquo;F&rsquo; (so <code>char_digit.lower()</code> is &lsquo;f&rsquo;):
<code>ord('f') - ord('a')</code> = <code>102 - 97</code> = <code>5</code></li></ul></li><li>So, this expression gives us:<ul><li>0 if the character is &lsquo;a&rsquo; or &lsquo;A&rsquo;</li><li>1 if the character is &lsquo;b&rsquo; or &lsquo;B&rsquo;</li><li>&mldr;</li><li>5 if the character is &lsquo;f&rsquo; or &lsquo;F&rsquo;</li></ul></li></ul></li><li><p><strong><code>... + 10</code></strong></p><ul><li>Finally, we add 10 to the result from step 3.</li><li><strong>Why 10?</strong> In hexadecimal (base 16) or other bases greater than 10:<ul><li>The digits 0-9 have their usual values.</li><li>&lsquo;A&rsquo; represents the value 10.</li><li>&lsquo;B&rsquo; represents the value 11.</li><li>&mldr;</li><li>&lsquo;F&rsquo; represents the value 15.</li></ul></li><li>So, continuing our examples:<ul><li>For &lsquo;A&rsquo; (offset 0): <code>0 + 10 = 10</code></li><li>For &lsquo;B&rsquo; (offset 1): <code>1 + 10 = 11</code></li><li>For &lsquo;C&rsquo; (offset 2): <code>2 + 10 = 12</code></li><li>&mldr;</li><li>For &lsquo;F&rsquo; (offset 5): <code>5 + 10 = 15</code></li></ul></li></ul></li></ol><p><strong>In summary, <code>ord(char_digit.lower()) - ord('a') + 10</code> is a formula to:</strong>
Take a character that is expected to be one of &lsquo;A&rsquo;/&lsquo;a&rsquo;, &lsquo;B&rsquo;/&lsquo;b&rsquo;, &mldr;, &lsquo;F&rsquo;/&lsquo;f&rsquo;, and convert it to its corresponding integer value 10, 11, &mldr;, 15.</p><p>This is typically used when converting a number string from a base like hexadecimal (base 16) into an integer. The part of the code that uses this would first check if <code>char_digit</code> is a numeric digit (&lsquo;0&rsquo;-&lsquo;9&rsquo;). If it&rsquo;s not, it then assumes it&rsquo;s one of these letter-digits and uses this formula to get its value.</p><p>For example, in <code>string_in_base_b1_to_int_base10('1A', 16)</code>:</p><ul><li>For &lsquo;1&rsquo;: <code>int('1')</code> gives <code>1</code>.</li><li>For &lsquo;A&rsquo;: This formula would be used:
<code>ord('a') - ord('a') + 10</code> = <code>0 + 10 = 10</code>.</li></ul><p>This makes it a compact way to handle the A-F characters without a long <code>if/elif</code> chain or a dictionary lookup for just these 6 characters.</p></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>