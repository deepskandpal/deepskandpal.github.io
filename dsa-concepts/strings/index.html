<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents></nav></nav></aside><article class="post-single page-strings"><h1>Strings</h1><span class=reading-time><em>7 min read</em></span><div class=post-content><p>Absolutely! That 6-step process you&rsquo;ve outlined is GOLD. It&rsquo;s precisely how you build deep, intuitive understanding, especially for recursive problems which can feel like black magic otherwise. You&rsquo;re essentially becoming the debugger and the CPU, tracing the logic yourself.</p><p>For Chapter 6 (Strings) in EPI Python, here are a few &ldquo;keystone&rdquo; problems that lend themselves exceptionally well to your 6-step deep dive method. These problems either involve recursion (like your Towers of Hanoi example) or intricate iterative logic where hand-simulation is invaluable.</p><p><strong>Top Keystone Problems for Your 6-Step Method:</strong></p><ol><li><p><strong>6.7 Compute All Mnemonics for a Phone Number (Page 74)</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> This is a classic recursion/backtracking problem. You&rsquo;re exploring a tree of possibilities. Your 6-step method is <em>perfect</em> for this. Understanding how the <code>partial_mnemonic</code> is built up and how the <code>digit_index</code> drives the recursion is key.</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: For each digit, try all its possible letters.</li><li>Parameters: Current digit index being processed, the partially built mnemonic string.</li><li>Base Case: All digits processed.</li><li>Hand-simulation: Crucial for N=2 or N=3 digits to see the call stack unfold.</li><li>Pseudocode: Will clearly show the loop for letters and the recursive call.</li></ul></li></ul></li><li><p><strong>6.10 Compute All Valid IP Addresses (Page 77)</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> Another excellent recursion/backtracking problem. It&rsquo;s about partitioning a string into 4 valid parts. Slightly more complex than mnemonics due to segment validation rules (0-255, no leading zeros for multi-digit segments).</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: Try to make 3 cuts in the string to form 4 segments.</li><li>Parameters: Index in the input string to start forming the current segment, number of segments already formed, list of current segments.</li><li>Base Case: 4 segments formed AND the entire input string is consumed.</li><li>Hand-simulation: With a short string like &ldquo;19216811&rdquo; or even &ldquo;2552551111&rdquo;, trying to place the dots.</li></ul></li></ul></li><li><p><strong>6.2 Base Conversion (Page 69) - Specifically, the <code>construct_from_base</code> part, or the &ldquo;integer to string in base b2&rdquo; logic.</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> While the overall problem has two parts (string_base1 -> int, then int -> string_base2), the second part is often naturally recursive. It&rsquo;s a simpler recursion than mnemonics but beautifully illustrates the &ldquo;divide problem, solve subproblem, combine result&rdquo; pattern. The variant in 6.3 (Integer to Spreadsheet Column ID) is very similar.</li><li><strong>Fits your 6 Steps (for int to string_base_b2):</strong><ul><li>High-level: To convert N to base B, get the last digit (N % B), then convert N // B to base B and append the digit.</li><li>Parameters: The integer to convert, the target base.</li><li>Base Case: Integer is 0.</li><li>Hand-simulation: Convert 10 (decimal) to base 2. <code>construct_from_base(10, 2)</code>.</li></ul></li></ul></li><li><p><strong>6.4 Replace and Remove (Page 71) - For iterative deep dive.</strong></p><ul><li><strong>Why it&rsquo;s Keystone (Iterative):</strong> This problem is a gem for understanding multi-pass algorithms and in-place manipulation using two (or more) pointers within an array (or list of characters). It&rsquo;s not recursive, but your hand-simulation step (Step 2) and pseudocode (Step 3) are vital for getting the pointer logic correct.</li><li><strong>Fits your 6 Steps:</strong><ul><li>High-level: First pass to remove &lsquo;b&rsquo;s and count &lsquo;a&rsquo;s (to know final size). Second pass (backwards) to do the &lsquo;a&rsquo; -> &lsquo;dd&rsquo; replacement.</li><li>Parameters (for helper functions or main logic): The character array/list, current read index, current write index, count of &lsquo;a&rsquo;s.</li><li>Base Case (for loops): Reaching end of array / start of array.</li><li>Hand-simulation: Absolutely critical! Track <code>read_idx</code>, <code>write_idx</code>, <code>a_count</code> on paper with an example like <code>(a,c,d,b,b,c,a)</code>.</li></ul></li></ul></li></ol><p><strong>Recommendation:</strong></p><p>Start with <strong>6.7 Compute All Mnemonics for a Phone Number</strong>. It&rsquo;s the purest example of recursion in this list that directly mirrors the &ldquo;Towers of Hanoi&rdquo; style of thinking (exploring choices at each step).</p><p>Let&rsquo;s imagine you pick <strong>6.7 Compute All Mnemonics for a Phone Number</strong>. Here&rsquo;s how you might approach it with your 6 steps, and I can guide you through it:</p><ul><li><p><strong>Your Step 1: Go through my teaching / EPI explanation.</strong></p><ul><li><em>My Teaching (High Level):</em> The goal is to generate all possible letter sequences for a given phone number string (e.g., &ldquo;23&rdquo;). Digit &lsquo;2&rsquo; maps to &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;. Digit &lsquo;3&rsquo; maps to &lsquo;D&rsquo;, &lsquo;E&rsquo;, &lsquo;F&rsquo;. We need to combine these: &ldquo;AD&rdquo;, &ldquo;AE&rdquo;, &ldquo;AF&rdquo;, &ldquo;BD&rdquo;, &ldquo;BE&rdquo;, &ldquo;BF&rdquo;, &ldquo;CD&rdquo;, &ldquo;CE&rdquo;, &ldquo;CF&rdquo;. This sounds like we make a choice for the first digit, then for that choice, we make a choice for the second digit, and so on. This &ldquo;and so on&rdquo; hints at recursion!</li><li><em>Parameters (for the recursive helper function):</em><ol><li><code>digit_index</code>: Which digit of the phone number are we currently trying to find a letter for?</li><li><code>partial_mnemonic</code>: A list (or array) of characters representing the mnemonic built <em>so far</em> up to <code>digit_index - 1</code>.</li></ol></li><li><em>Base Case:</em> What&rsquo;s the simplest state? When we&rsquo;ve processed all digits! If <code>digit_index</code> is equal to the length of the phone number, it means we&rsquo;ve successfully chosen a letter for every digit. So, we add the <code>partial_mnemonic</code> (joined into a string) to our list of results.</li></ul></li><li><p><strong>Your Step 2 (NEW - Hand-Simulate with Pen and Paper FOR A SMALL CASE):</strong></p><ul><li>Let <code>phone_number = "23"</code>. <code>MAPPING = {..., '2':"ABC", '3':"DEF", ...}</code>.
Let <code>results = []</code>, <code>partial_mnemonic = [_, _]</code> (length of phone_number).</li><li><code>mnemonic_helper(digit_index=0, partial_mnemonic)</code>:<ul><li>Current digit is <code>phone_number[0]</code> which is &lsquo;2&rsquo;. Letters are &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;.</li><li><strong>Try &lsquo;A&rsquo;</strong>: <code>partial_mnemonic[0] = 'A'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['A',_])</code>.<ul><li>Current digit is <code>phone_number[1]</code> which is &lsquo;3&rsquo;. Letters are &lsquo;D&rsquo;, &lsquo;E&rsquo;, &lsquo;F&rsquo;.</li><li><strong>Try &lsquo;D&rsquo;</strong>: <code>partial_mnemonic[1] = 'D'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','D'])</code>.<ul><li><code>digit_index (2) == len("23") (2)</code>. Base Case! Add &ldquo;AD&rdquo; to <code>results</code>. Return.</li></ul></li><li><strong>Try &lsquo;E&rsquo;</strong>: <code>partial_mnemonic[1] = 'E'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','E'])</code>.<ul><li>Base Case! Add &ldquo;AE&rdquo; to <code>results</code>. Return.</li></ul></li><li><strong>Try &lsquo;F&rsquo;</strong>: <code>partial_mnemonic[1] = 'F'</code>. Call <code>mnemonic_helper(digit_index=2, partial_mnemonic_now_is_['A','F'])</code>.<ul><li>Base Case! Add &ldquo;AF&rdquo; to <code>results</code>. Return.</li></ul></li><li>Done with letters for digit &lsquo;3&rsquo; (when first digit was &lsquo;A&rsquo;). Return from this call.</li></ul></li><li><strong>Try &lsquo;B&rsquo;</strong>: <code>partial_mnemonic[0] = 'B'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['B',_])</code>.<ul><li>&mldr; (similar logic, will generate &ldquo;BD&rdquo;, &ldquo;BE&rdquo;, &ldquo;BF&rdquo;)</li></ul></li><li><strong>Try &lsquo;C&rsquo;</strong>: <code>partial_mnemonic[0] = 'C'</code>. Call <code>mnemonic_helper(digit_index=1, partial_mnemonic_now_is_['C',_])</code>.<ul><li>&mldr; (similar logic, will generate &ldquo;CD&rdquo;, &ldquo;CE&rdquo;, &ldquo;CF&rdquo;)</li></ul></li><li>Done with letters for digit &lsquo;2&rsquo;. Return from initial call.</li></ul></li><li>Wow! Doing this on paper, you actually <em>see</em> the depth-first traversal of the decision tree.</li></ul></li><li><p><strong>Your Step 3 (NEW - Pseudocode/Skeleton Code):</strong></p><pre tabindex=0><code>MAPPING = {&#39;0&#39;:&#39;0&#39;, &#39;1&#39;:&#39;1&#39;, &#39;2&#39;:&#39;ABC&#39;, ...} // Global or passed in

function generate_mnemonics(phone_number_string):
    results_list = []
    current_partial_mnemonic = array_of_chars of size len(phone_number_string)

    mnemonic_recursive_helper(digit_idx = 0, current_partial_mnemonic, results_list, phone_number_string)
    return results_list

function mnemonic_recursive_helper(digit_idx, partial_mnemonic_chars, all_results, original_phone_num):
    if digit_idx == len(original_phone_num): // Base Case
        add join(partial_mnemonic_chars) to all_results
        return

    current_digit_char = original_phone_num[digit_idx]
    possible_letters_for_digit = MAPPING[current_digit_char]

    for each letter L in possible_letters_for_digit:
        partial_mnemonic_chars[digit_idx] = L
        mnemonic_recursive_helper(digit_idx + 1, partial_mnemonic_chars, all_results, original_phone_num)
        // No cleanup needed for partial_mnemonic_chars[digit_idx] here because the next iteration 
        // of the loop (or the call from a higher stack frame) will overwrite it.
</code></pre></li><li><p><strong>Your Step 4: Translate to Actual Code.</strong>
Now you&rsquo;d try to write the Python code. You&rsquo;d initialize <code>MAPPING</code>, the main function, and the helper. The <code>partial_mnemonic</code> in Python is often a list of characters which you then <code>"".join()</code> in the base case.</p></li><li><p><strong>Your Step 5 (CRUCIAL - Debug and Test):</strong>
Run with &ldquo;2&rdquo;, then &ldquo;23&rdquo;. Add <code>print()</code> statements inside the helper:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Helper called: digit_idx=</span><span style=color:#e6db74>{</span>digit_idx<span style=color:#e6db74>}</span><span style=color:#e6db74>, partial_mnemonic_so_far=</span><span style=color:#e6db74>{</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(partial_mnemonic_chars[:digit_idx])<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  Current digit: </span><span style=color:#e6db74>{</span>original_phone_num[digit_idx]<span style=color:#e6db74>}</span><span style=color:#e6db74>, Letters: </span><span style=color:#e6db74>{</span>possible_letters_for_digit<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># In the base case:</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;    Base Case Reached! Adding: </span><span style=color:#e6db74>{</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(partial_mnemonic_chars)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>This tracing is invaluable.</p></li><li><p><strong>Your Step 6: Reflect and Solidify.</strong></p><ul><li>&ldquo;Base case was when <code>digit_idx</code> reached the end of the phone number.&rdquo;</li><li>&ldquo;Problem got smaller by incrementing <code>digit_idx</code>, focusing on the next digit.&rdquo;</li><li>&ldquo;Arguments changed: <code>digit_idx</code> increased. <code>partial_mnemonic_chars</code> had one more character filled in.&rdquo;</li><li>&ldquo;The loop iterates through choices for the <em>current</em> digit. The recursive call solves the problem for the <em>rest</em> of the digits given that choice.&rdquo;</li></ul></li></ul><p>Which of these keystone problems would you like to start your deep dive with? I&rsquo;m ready to walk through it using your 6 steps!</p></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></body></html>