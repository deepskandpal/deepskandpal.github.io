<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>404EngineerNotFound</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js></script><script src=https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js></script></head><body>\<header><nav><div class=logo><a href=/>404EngineerNotFound</a></div><ul class=main-nav><li class="nav-item has-dropdown"><a href=#>Writings <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/stories/>Stories</a></li><li class=dropdown-item><a href=/thoughts/>Thoughts</a></li><li class=dropdown-item><a href=/fitness-log/>Fitness Log</a></li></ul></li><li class="nav-item has-dropdown"><a href=#>Tech Lab <i class="fas fa-caret-down fa-xs"></i></a><ul class=dropdown-menu><li class=dropdown-item><a href=/papershelf/>Papershelf</a></li><li class=dropdown-item><a href=/creations/>Creations</a></li><li class=dropdown-item><a href=/dsa-log/>DSA Log</a></li><li class=dropdown-item><a href=/tech-writings/>Technical Writings</a></li></ul></li><li class=nav-item><a href=/bookshelf/>Bookshelf</a></li><li class=nav-item><a href=/about/>About</a></li></ul><div class=search-container><input type=search id=search-input placeholder=Search...>
<i class="fa fa-search"></i></div></nav><div id=search-results-container><ul id=search-results></ul></div></header><main><div class=single-content-wrapper><aside class=article-sidebar><nav><h4>On this page</h4><nav id=TableOfContents><ul><li><a href=#introduction-to-arrays>Introduction to Arrays</a></li></ul></nav></nav></aside><article class="post-single page-arrays"><h1>Arrays</h1><span class=reading-time><em>5 min read</em></span><div class=post-content><h2 id=introduction-to-arrays>Introduction to Arrays</h2><p>Okay, I&rsquo;ve reviewed the OCR of Chapter 5 (Arrays) from EPI that you provided. This is an excellent chapter with many fundamental array manipulations.</p><p>Based on common interview patterns, the importance of the underlying techniques, and how well they illustrate core array concepts, here are my suggestions for <strong>Keystone Problems</strong> from this chapter to focus on with the 6-step (or revised time-constrained) process:</p><p><strong>Keystone Problems for Chapter 5 (Arrays):</strong></p><ol><li><p><strong>5.1 THE DUTCH NATIONAL FLAG PROBLEM (Page 39-42):</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> This is a classic partitioning problem. The single-pass <code>O(N)</code> time, <code>O(1)</code> space solution (the one with <code>smaller</code>, <code>equal</code>, and <code>larger</code> pointers/sections) is a beautiful and frequently asked pattern. It tests your ability to manipulate subarrays in place using multiple pointers and maintain invariants.</li><li><strong>Core Concepts:</strong> In-place modification, multiple pointers, partitioning, loop invariants.</li><li><strong>Focus:</strong> Definitely the single-pass, three-pointer solution (bottom of page 41, top of page 42). The earlier O(N^2) or two-pass O(N) solutions are good for understanding the evolution, but the one-pass is the target.</li></ul></li><li><p><strong>5.2 INCREMENT AN ARBITRARY-PRECISION INTEGER (Page 43):</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> Deals with representing large numbers using arrays and performing arithmetic. The &ldquo;schoolbook&rdquo; addition algorithm (right-to-left with carry) is fundamental. Handles edge cases like <code>becoming</code>.</li><li><strong>Core Concepts:</strong> Array as a number representation, right-to-left processing, carry propagation, handling array resizing (or prepending).</li><li><strong>Focus:</strong> The logic of iterating from the end, handling the carry, and the special case of an all-9s input that requires an extra digit.</li></ul></li><li><p><strong>5.6 BUY AND SELL A STOCK ONCE (Page 46-47):</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> A very common interview problem. The <code>O(N)</code> solution requires a clever insight about tracking the minimum price seen so far and calculating potential profit at each step. It&rsquo;s simple once you see it, but a good test of problem-solving.</li><li><strong>Core Concepts:</strong> Iterating and maintaining state (min price, max profit), identifying the right greedy-like choice at each step.</li><li><strong>Focus:</strong> The single-pass <code>O(N)</code> solution.</li></ul></li><li><p><strong>5.9 ENUMERATE ALL PRIMES TO N (Sieve of Eratosthenes) (Page 49-50):</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> The Sieve of Eratosthenes is a classic algorithm with applications beyond just finding primes. It demonstrates efficient marking/elimination in an array (used as a boolean map).</li><li><strong>Core Concepts:</strong> Using an array as a boolean lookup, marking multiples, understanding why you only need to sieve up to <code>sqrt(n)</code> for primality testing of <code>n</code> (though here you sieve multiples of primes found). The optimization to start sieving from <code>p^2</code> is also good.</li><li><strong>Focus:</strong> The basic Sieve logic first, then the optimization of starting to mark from <code>p*p</code>.</li></ul></li><li><p><strong>5.11 COMPUTE THE NEXT PERMUTATION (Page 52-53):</strong></p><ul><li><strong>Why it&rsquo;s Keystone:</strong> This is a more complex but very insightful array manipulation problem. It requires careful observation of patterns to find the &ldquo;next lexicographically greater&rdquo; permutation. The steps (find inversion point, find swap element, reverse suffix) are a specific algorithm worth understanding.</li><li><strong>Core Concepts:</strong> Lexicographical order, finding patterns from the right end of the array, in-place swaps and reversals.</li><li><strong>Focus:</strong> Understanding the 4 steps outlined in the solution. This one might take more time for the &ldquo;hand-simulation&rdquo; and &ldquo;pseudocode&rdquo; steps to really get the logic.</li></ul></li></ol><p><strong>Why these?</strong></p><ul><li>They cover a range of array manipulation techniques: partitioning, arithmetic, dynamic state tracking, using arrays as lookups/boolean maps, and complex in-place reordering.</li><li>They are frequently asked or form the basis of variations asked in interviews.</li><li>Understanding these deeply will give you a strong foundation for tackling other array problems.</li></ul><p><strong>How to approach the &ldquo;Scan&rdquo; Problems from this chapter (after deep dives on keystones):</strong></p><ul><li><strong>Array boot camp (even_odd, Page 37):</strong> This is a simpler version of Dutch Flag (2-way partition). Good to see the connection.</li><li><strong>5.3 Multiply Two Arbitrary-Precision Integers:</strong> Extends the idea from 5.2. Understand the schoolbook multiplication. The nested loops and sum accumulation in the <code>result</code> array are key.</li><li><strong>5.4 Advancing Through an Array:</strong> Greedy approach. Understand why simple &ldquo;jump as far as possible&rdquo; might not work and why tracking <code>furthest_reach_so_far</code> is better.</li><li><strong>5.5 Delete Duplicates from a Sorted Array:</strong> Classic two-pointer (read/write pointer) technique for in-place modification of sorted arrays. Very common pattern.</li><li><strong>5.7 Buy and Sell a Stock Twice:</strong> This is a precursor to Dynamic Programming. The idea of splitting the problem and using precomputed results (max profit up to day <code>i</code>, max profit from day <code>i</code> onwards) is important.</li><li><strong>5.8 Computing an Alternation:</strong> Interesting problem on local swaps. The <code>O(N)</code> solution without full sorting is clever.</li><li><strong>5.12 Sample Offline Data (Random Sampling):</strong> Knuth-Fisher-Yates shuffle variant. Important for random selection.</li><li><strong>5.17 Sudoku Checker Problem, 5.18 Spiral Ordering, 5.19 Rotate a 2D Array:</strong> These are good 2D array manipulation problems. Focus on how indices are transformed or how layers/boundaries are processed. For rotation, the layer-by-layer in-place swap is key.</li></ul><p>Start with the 5 keystone problems. If you find you have more time or want more practice, pick from the &ldquo;scan&rdquo; list based on areas you feel weaker in (e.g., 2D arrays, more two-pointer problems).</p><p>This should give you a solid and manageable plan for tackling the Arrays chapter effectively!</p></div></article></div></main><footer><p>&copy; 2025 Deepanshu Kandpal</p></footer><a id=scrollTopBtn title="Go to top"><i class="fa-solid fa-arrow-up"></i></a>
<script src=/js/search.js></script><script>var mybutton=document.getElementById("scrollTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.classList.add("show"):mybutton.classList.remove("show")}mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e,t){const n=document.createElement("div");n.className="mermaid",n.textContent=e.textContent,n.id="mermaid-"+t,e.parentNode.parentNode.replaceChild(n,e.parentNode)}),mermaid.initialize({startOnLoad:!0,theme:"default",themeVariables:{primaryColor:"#4a90e2",primaryTextColor:"#333",primaryBorderColor:"#4a90e2",lineColor:"#333"}}),mermaid.init()})</script></body></html>