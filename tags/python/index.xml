<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 404EngineerNotFound</title><link>https://deepskandpal.github.io/tags/python/</link><description>Recent content in Python on 404EngineerNotFound</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 29 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://deepskandpal.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Restore Ip Addresses</title><link>https://deepskandpal.github.io/dsa-log/restore-ip-addresses/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/restore-ip-addresses/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;Given a string &lt;code&gt;s&lt;/code&gt; containing only digits, return all possible valid IP addresses that can be formed by inserting three dots into &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros (e.g., &amp;ldquo;01&amp;rdquo; is invalid, but &amp;ldquo;0&amp;rdquo; is valid).&lt;/p&gt;
&lt;p&gt;For example, given &lt;code&gt;s = &amp;quot;25525511135&amp;quot;&lt;/code&gt;, the valid IP addresses are &lt;code&gt;[&amp;quot;255.255.11.135&amp;quot;]&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>LangChef - End-to-End LLM Workflow Platform</title><link>https://deepskandpal.github.io/creations/langchef/</link><pubDate>Sun, 15 Dec 2024 22:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/creations/langchef/</guid><description>&lt;h2 id="langchef-end-to-end-llm-workflow-platform"&gt;LangChef: End-to-End LLM Workflow Platform&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A comprehensive platform for prompt engineering, dataset management, and LLM experimentation that streamlines the entire lifecycle of LLM applications.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="-what-is-langchef"&gt;ðŸŽ¯ What is LangChef?&lt;/h3&gt;
&lt;p&gt;LangChef is a production-ready platform designed for teams who need to iterate fast and maintain quality in their AI workflows. It addresses the complete LLM development lifecycle from initial prompt engineering to production evaluation and monitoring.&lt;/p&gt;
&lt;h3 id="-key-features"&gt;ðŸš€ Key Features&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Prompt Management&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create, version, and organize prompts with full lifecycle tracking&lt;/li&gt;
&lt;li&gt;A/B test prompt variations with statistical significance&lt;/li&gt;
&lt;li&gt;Template management and reusable prompt components&lt;/li&gt;
&lt;li&gt;Performance tracking across different prompt versions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dataset Management&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Count And Say</title><link>https://deepskandpal.github.io/dsa-log/count-and-say/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/count-and-say/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://colab.research.google.com/drive/1udH4eyb9bToLC_ZPPaK-n3T-jPdbAANw#scrollTo=pD7bP8UR5oiP"&gt;rough nb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The count-and-say sequence is a sequence of digit strings defined by the recursive formula:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;countAndSay(1) = &amp;quot;1&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;countAndSay(n)&lt;/code&gt; is the way you would &amp;ldquo;say&amp;rdquo; the digit string from &lt;code&gt;countAndSay(n-1)&lt;/code&gt;, which is then converted into a new digit string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.&lt;/p&gt;</description></item><item><title>Letter Combinations Of A Phone Number</title><link>https://deepskandpal.github.io/dsa-log/letter-combinations-of-a-phone-number/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/letter-combinations-of-a-phone-number/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://colab.research.google.com/drive/1udH4eyb9bToLC_ZPPaK-n3T-jPdbAANw#scrollTo=pD7bP8UR5oiP"&gt;rough nb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a string containing digits from &lt;code&gt;2-9&lt;/code&gt; inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&lt;/p&gt;
&lt;p&gt;A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: digits = &amp;#34;23&amp;#34;
Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: digits = &amp;#34;&amp;#34;
Output: []
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;This problem is a classic example of a backtracking or recursion problem. We need to explore all possible combinations of letters for the given digits.&lt;/p&gt;</description></item><item><title>Zigzag Conversion</title><link>https://deepskandpal.github.io/dsa-log/zigzag-conversion/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/zigzag-conversion/</guid><description>&lt;h2 id="problem-description"&gt;Problem Description&lt;/h2&gt;
&lt;p&gt;The string &lt;code&gt;PAYPALISHIRING&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;P A H N
A P L S I I G
Y I R
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then read line by line: &lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows.&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;The problem asks us to reconstruct a string that is formed by reading a zigzag pattern row by row. We can solve this by simulating the placement of each character into its corresponding row.&lt;/p&gt;</description></item><item><title>Two Sum</title><link>https://deepskandpal.github.io/dsa-log/two-sum/</link><pubDate>Wed, 01 May 2024 10:00:00 +0000</pubDate><guid>https://deepskandpal.github.io/dsa-log/two-sum/</guid><description>&lt;h2 id="problem-description-optional-summary"&gt;Problem Description (Optional Summary)&lt;/h2&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;target&lt;/code&gt;, return indices of the two numbers such that they add up to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="solution-approach"&gt;Solution Approach&lt;/h2&gt;
&lt;p&gt;Use a hash map (dictionary in Python) to store numbers encountered so far and their indices. For each number, check if &lt;code&gt;target - current_number&lt;/code&gt; exists in the hash map. If it does, we found the pair. Otherwise, add the current number and its index to the map.&lt;/p&gt;</description></item></channel></rss>